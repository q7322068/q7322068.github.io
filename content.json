{"meta":{"title":"足迹|成长之路","subtitle":"实战经验梳理，分享与你，分享与自己！","description":"spring boot，spring cloud，微服务，java web编程实战","author":"杨文魁","url":"http://www.onecoderspace.com"},"pages":[{"title":"","date":"2017-09-16T03:13:44.000Z","updated":"2017-09-16T03:13:13.000Z","comments":true,"path":"5435542637.html","permalink":"http://www.onecoderspace.com/5435542637.html","excerpt":"","text":""},{"title":"","date":"2017-09-15T15:27:58.000Z","updated":"2017-09-15T15:27:58.000Z","comments":true,"path":"404.html","permalink":"http://www.onecoderspace.com/404.html","excerpt":"","text":""},{"title":"关于我","date":"2017-09-10T12:49:14.000Z","updated":"2017-09-10T13:18:59.000Z","comments":true,"path":"about/index.html","permalink":"http://www.onecoderspace.com/about/index.html","excerpt":"","text":"有志之人立长志，无志之人常立志 杨文魁一个程序猿技术上，主要从事java web开发，一直在中小公司工作，对于系统设计、数据库设计、代码开发、前端、部署都有较多的经验。但怎么说呢，各个地方都会，但很少有大并发、大数据量的实践场景，对于技术的掌握也感觉没有达到很精深的程度，希望能在后续的时间内梳理自己过往实践中用过的技术、解决的问题，总结过往，找到深入研究的方向，在技术上继续提升自己的能力。 近期博客里会写一系列最近在开发中用到的spring boot,spring cloud等技术，从项目实战的角度来来阐述这些技术的使用及中间遇到的各种大大小小的问题。"}],"posts":[{"title":"Java编程规范（自我总结版一）","slug":"coding-guidelines","date":"2017-11-05T11:23:03.000Z","updated":"2017-11-06T13:55:49.000Z","comments":true,"path":"2017/11/05/coding-guidelines/","link":"","permalink":"http://www.onecoderspace.com/2017/11/05/coding-guidelines/","excerpt":"又一次阅读阿里编程规范，发现有不少条目又给忘了，离上次阅读大概一个多月。我的阅读习惯应该还不错，每次看书籍之类的不会只看一遍，因为之前的经验发现，只看一遍的内容，会特别快的遗忘，在脑子里只会留下淡淡的印象，知道看过哪块的内容，但详细的内容就模糊了，面试时经历过这样尴尬的场面…","text":"又一次阅读阿里编程规范，发现有不少条目又给忘了，离上次阅读大概一个多月。我的阅读习惯应该还不错，每次看书籍之类的不会只看一遍，因为之前的经验发现，只看一遍的内容，会特别快的遗忘，在脑子里只会留下淡淡的印象，知道看过哪块的内容，但详细的内容就模糊了，面试时经历过这样尴尬的场面…现在我看书，通常是第一遍通读，了解大概；第二遍细度核心知识点，强化理解核心内容；然后在脑中回思书中的核心内容，有不明白的地方就再翻书看一遍，做到理解，转化为自己的知识，效果来看还不错，你也可以试下！ 但发现在阿里编程规范这里还是会有问题，条目太多，按照顺序记忆可以做到一段时间内不忘记，但很多条目是日常编程不会用到的，时间稍长就会出现遗忘的情形，在编程的过程中万一不小心踩了雷就有点伤，所以尝试从自己思考问题的角度重新组织日常编码需要的注意事项，争取转化为编程时的本能^_^ 一、环境准备检查下自己的IDE设置，确保设置为以下内容，以mac eclipse为例。 IDE的text file encoding设置为 UTF-8；IDE中文件的换行符使用Unix格式，不要使用 Windows 格式（Eclipse -&gt; 偏好设置 -&gt; General -&gt; WorkSpace -&gt; 设置Text file encoding 和New text file line delimiter）。 采用4个空格缩进，禁止使用tab字符，如果使用tab缩进，必须设置1个tab为4个空格（Eclipse -&gt; 偏好设置 -&gt; General -&gt; Editors -&gt; Text Editors -&gt; 设置Displayed tab width为4 -&gt; 勾选Insert spaces for tabs）。 Code Templates设置：为了统一编码规范，通常团队会有一个通用的Code Templates，问下同事，让他们导一份codetemplates.xml给你，如果你需要自己构建一个，百度一下吧，这里不再展开了。 安装阿里云代码规范插件，历史代码或新项目里面，通过插件扫码，可以发现很多不规范的点，个人认为是java开发必装插件之一（eclipse插件中文安装手册）； 二、命名通用约束 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 杜绝完全不规范的缩写，避免望文不知义。反例:AbstractClass“缩写”命名成 AbsClass。 为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意，如从远程仓库拉取代码的类命名为 PullCodeFromRemoteRepository。 如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。 在日常开发中常见的涉及命名的点有：项目名称、包名、类名、方法名、变量名、数据库名、表名、字段名、索引名称、URL命名、文件名。 1. 项目名称小写字母或数字，不能使用数字开头，多个单词之间使用中划线连接，能准确的表达出项目的核心作用，如code-generator。（个人推荐） 2. 包名 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。 如果表示版本关系等特殊情况，可以使用数字，如org.apache.commons.lang3.StringUtils 3. 类名 类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外:DO / BO / DTO / VO / AO。 抽象类命名使用 Abstract 或 Base 开头;异常类命名使用 Exception 结尾;测试类命名以它要测试的类的名称开始，以 Test 结尾。 对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。 枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开，如：枚举名字为ProcessStatusEnum的成员名称:SUCCESS / UNKOWN_REASON。 禁止使用非字母字符，特殊情况下可以使用2、4等数字。 4. 属性名 使用 lowerCamelCase 风格，必须遵从驼峰形式。 POJO类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误，如标记删除字段用deleted而不是isDeleted。 尽量不要使用非字母字符 5. 方法名 使用 lowerCamelCase 风格，必须遵从驼峰形式； Service/DAO层方法命名规约 1) 获取单个对象的方法用get做前缀。 2) 获取多个对象的方法用list做前缀。 3) 获取统计值的方法用count做前缀。 4) 插入的方法用save/insert做前缀。 5) 删除的方法用remove/delete做前缀。 6) 修改的方法用update做前缀。 尽量不要使用非字母字符，如数字，下划线，中划线等。 6. 参数名、变量名使用 lowerCamelCase 风格，必须遵从驼峰形式。 7. 常量 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 不允许任何魔法值(即未经定义的常量)直接出现在代码中。反例:String key = “Id#taobao_” + tradeId; 8. 数据库名尽量和项目名称保持一致，如出现特殊情况按照项目名称命名规则进行命名。 9. 表名 必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只 出现数字，不允许出现任何大写字母，建议将类名内不同单词用下划线分割作为表名。 表名不使用复数名词，表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数 形式，符合表达习惯。 表的命名可以考虑加上“业务名称_表的作用”，但需要规范统一命名，不要多种方式混合使用，如果表数据不是特别大，没有必要使用。 禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。 10. 字段名 必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只 出现数字，不允许出现任何大写字母，建议将属性名内不同单词用下划线分割作为字段名。 禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。 表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint ( 1表示是，0表示否)。如标记删除字段deleted对应的字段名为is_deleted。 11. 索引名 主键索引名为 pk_字段名; 唯一索引名为 uk_字段名; 普通索引名则为 idx_字段名。 12. 文件名必须使用小写字母或数字，禁止数字开头，多个单词使用中划线连接，涉及的内容有：js文件、图片、css文件、jsp页面等（个人推荐）。 13. URL命名 必须使用小写字母或数字，禁止数字开头，多个单词使用中划线连接。 限制URL层级不要太深（个人感觉3层以内较好）。 三、代码风格代码风格实际上就是合理使用缩进、空格、换行，目的是让代码可读性更强。大家记忆时记清楚用什么样的缩进，哪些时候使用空格，哪些时候使用换行，单行代码不要太长就可以，这部分内容通过两三次的回顾很容易养成习惯，因为是编码中最长用到的。请看以下代码： public static void main(String[] args) { // 缩进 4 个空格 String say = &quot;hello&quot;; // 运算符的左右必须有一个空格 int flag = 0; // 关键词if/for/while/switch/do与括号之间必须有一个空格，括号内的 flag 与左括号，0 与右括号不需要空格 if (flag == 0) { System.out.println(say); } // 左大括号前加空格且不换行;左大括号后换行 if (flag == 1) { System.out.println(&quot;world&quot;); // 右大括号前换行，右大括号后有 else，不用换行 } else { System.out.println(&quot;ok&quot;); // 在右大括号后直接结束，则必须换行 } StringBuffer sb = new StringBuffer(); // 超过120个字符的情况下，换行缩进4个空格，点号和方法名称一起换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)... .append(&quot;huang&quot;)... .append(&quot;huang&quot;)... .append(&quot;huang&quot;); // 任何二目、三目运算符的左右两边都需要加一个空格 int result = flag == 0 ? 1 : 0; } 下边是另外几点需要注意的： 注释的双斜线与注释内容之间有且仅有一个空格。 方法参数在定义和传入时，多个参数逗号后边必须加空格，如method(“a”, “b”)。 没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。 方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义 之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。没有必要插入多个空行进行隔开。 四、注释1. 项目项目建议提供注释，说明项目的作用，核心逻辑或需要注意的特别事项，方便其他人快速对项目形成整体了解。添加方式有两种： 在根目录下创建README.md或README.txt 在根目录下创建doc文件夹，在其创建README.md或README.txt，还可以在该目录下存储一些初始化语句、索引创建语句等内容 2. 包说明该包的核心作用，注释可在package-info.java内设置，建议在核心包上有选择添加。 3. 类所有类都需要添加注释，类注释采用javadoc规范的方式( /* / ),注释包括：该类的主要作用及使用时的一些注意事项、创建者和创建日期，可通过codetemplate来统一格式。 4. 类方法类方法注释采用javadoc规范的方式( /* / )，注释包括：该方法的作用、使用注意事项、参数、返回值、抛出异常信息，可通过codetemplate来统一格式，添加注释时可以模仿jdk内方法的注释。 如果注释的工作量太大，对于私有方法，可以简化注释，做到能清晰说明其作用即可。但是所有的抽象方法(包括接口中的方法)的注释必须严格的按照javadoc规范进行添加，需要额外指出对子类的实现要求，或者调用注意事项。 当然也会有例外情况，如controller内使用swagger2提供在线文档，那就没必要再提供javadoc注释了。 5. 类属性所有的类属性都需要添加注释，所有可用通过类名.属性、对象实例.属性调用的类属性都应该使用javadoc进行注释，如常量、枚举类型字段；POJO类的属性个人感觉使用行内注释会更合适一些，普通实例变量建议使用javadoc方式。 6. 方法内方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/ /注释，注意与代码对齐。 可以这样记忆// 和 / /只在方法内部和POJO内使用，其他时候都使用javadoc方式的注释。 7. 其他建议 注释使用中文，专有名词与关键字保持英文原文即可。 代码修改的同时，注释也要进行相应的修改。 如果一段代码需要注释掉，在上方详细说明；如果代码已无用，直接删除更好。 TODO（待办事宜），FIXME（错误，不能工作）这类特殊注释标记，添加时留下添加人、时间、预计处理时间，并及时处理，不要写了就不管了。 对于注释的要求:第一、能够准确反应设计思想和代码逻辑;第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路;注释也是给继任者看的，使其能够快速接替自己的工作。 额外的，好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端:过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。 五、日志1.日志配置主要有日志文件名称、日志输出级别、日志是否向上层传递、日志保留时间。 日志文件推荐至少保存15天，因为有些异常具备以“周”为频次发生的特点。 避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false 谨慎地记录日志。生产环境禁止输出 debug 日志;有选择地输出 info 日志;如果使 用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。 应用中的扩展日志(如打点、临时监控、访问日志等)命名方式:appName_logType_logName.log。logType:日志类型，推荐分类有stats/desc/monitor/visit 等;logName:日志描述。这种命名的好处:通过文件名就可知 道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。 2.日志使用 应用中不可直接使用日志系统(Log4j、Logback)中的 API，而应依赖使用日志框架SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。 异常信息应该包括两类信息:案发现场信息和异常堆栈信息。如果不处理，那么通过 关键字 throws 往上抛出。推荐logger.error(各类参数或者对象toString + &quot;_&quot; + e.getMessage(), e);这种格式，不要简单的输出e.getMessage()，那样具体的错误信息都被隐藏，很不利于排查问题。 注意日志输出级别和使用场景，避免大量调试日志被生成，最近就遇到过一次在高频接口输出调试信息，忘记清理，在调用高峰拖死了tomcat；在生成环境，尽量只记录异常信息和较重要的业务信息，且控制其量。 while、for循环等内部的异常需要特别注意发生异常的条件，曾经遇到过while循环从redis队列内取值（事件），redis服务宕机，结果异常日志刷爆磁盘的情况。 六、异常处理主要涉及什么情况下添加异常处理，捕获异常后的处理方式，finally内注意事项及其它几点建议。 1. 异常捕获 不要捕获IndexOutOfBoundsException、NullPointerException等运行时异常，这类异常可以通过条件判断避免；也不要使用异常来做流程控制，异常的处理效率比条件分支低； 不要对大段代码进行try-catch，只在可能发生异常且需要对异常处理的场景有针对性的进行try-catch捕获异常； 2. 异常处理 捕获异常后严禁什么也不做或者直接e.printStackTrace()输出信息至控制台；如果不想处理，将该异常抛给上层，最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容； 在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须 使用“错误码”;而应用内部推荐异常抛出;跨应用间 RPC 调用优先考虑使用 Result 方式，封 装 isSuccess()方法、“错误码”、“错误简短信息”。 定义时区分unchecked/checked 异常，避免直接抛出newRuntimeException()， 更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。 3. finally使用 在finally块中进行资源回收（关闭资源对象、流对象）时，有异常也要做try-catch finally块中不能使用return，finally块中的Return返回后方法结束执行，不会执行try-catch块中的return语句； 4. 其它建议 有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回 滚事务。 防止 NPE，是程序员的基本修养，注意 NPE 产生的场景； 七、单元测试1. 单元测试要求 单元测试代码必须写在如下工程目录:src/test/java，不允许写在业务代码目录下 单元测试应该是有测试框架定时自动执行的，不需要人工参与；单元测试用例之间不能互相调用，也不能依赖执行的先后次序；单元测试时可以重复执行的，不能受到外界环境的影响。 单元测试通常是方法级别，至多类级别。 单元测试作为一种质量保障手段，不建议项目发布后补充单元测试用例，建议在项目提测前完成单元测试。核心业务、核心应用、核心模块的增量代码确保单元测试通过. 在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例(UC)。 单元测试的基本目标:语句覆盖率达到 70%;核心模块的语句覆盖率和分支覆盖率都 要达到 100% 2. 单元测试实现建议 对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。 和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。 对于不可测的代码建议做必要的重构，使代码变得可测，避免为了达到测试要求而 书写不规范测试代码。 编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量。1）B:Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。2）C:Correct，正确的输入，并得到预期的结果。3）D:Design，与设计文档相结合，来编写单元测试。4）E:Error，强制错误信息输入(如:非法数据、异常流程、非业务允许输入等)，并得 到预期的结果。 ps:如何写出合格的单元测试代码我也有点蒙，目前是核心service代码会写单元测试进行功能验证，有相关经验的朋友希望能给点建议。 八、安全规约1. 操作权限隶属于用户个人的页面或者功能必须进行权限控制校验。防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信 内容、修改他人的订单。 2. XSS跨站脚本攻击(Cross Site Scripting)，可以对用户录入内容进行白名单过滤，去除非法信息。禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。 3. CSRFCSRF（Cross-site request forgery）跨站请求伪造，是一类常见编程漏洞。对于存在 CSRF 漏洞的应用/网站，攻击者可以事先构造好URL，只要受害者用户一访问，后台便在用户不知情情况下对数据库中用户参数进行相应修改。表单、AJAX提交必须执行 CSRF 安全过滤，通常可以通过额外的token字段来实现。 4. SQL注入用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。 5. 用户请求参数有效性验证忽略参数校验可能导致: page size 过大导致内存溢出 恶意 order by 导致数据库慢查询 任意重定向 SQL 注入 反序列化注入 正则输入源串拒绝服务 ReDoS，Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。 6. 防重放限制在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制， 如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。 如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费（曾经阿里云的短信被一晚上刷了几百块的…）。 7. 防刷发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略，敏感词过滤可以考虑阿里云的绿网服务。 8. 信息脱敏用户敏感数据禁止直接展示，必须对展示数据进行脱敏。 查看个人手机号码会显示成:158**9119，隐藏中间 4 位，防止隐私泄露。 MySQL和编程实践（集合、并发处理）等部分后续另起一篇文章来写。","categories":[{"name":"java实战","slug":"java实战","permalink":"http://www.onecoderspace.com/categories/java实战/"}],"tags":[{"name":"java实战","slug":"java实战","permalink":"http://www.onecoderspace.com/tags/java实战/"},{"name":"编程规范","slug":"编程规范","permalink":"http://www.onecoderspace.com/tags/编程规范/"}]},{"title":"代码生成器","slug":"code-generator","date":"2017-10-29T11:14:45.000Z","updated":"2017-10-29T12:51:39.000Z","comments":true,"path":"2017/10/29/code-generator/","link":"","permalink":"http://www.onecoderspace.com/2017/10/29/code-generator/","excerpt":"在规模较小的公司里，大部分的项目规模不是特别大，技术实现难度不是很高，关注点更多是在业务功能的开发及保证业务流程的正确性上。当有一个新的项目来时，通常会找一个项目进行copy，删除不用的包和类，然后以此为基础，进行后续的开发，开发某个模块，就copy出一份controller、service、serviceImpl、dao、daoImpl、model、jsp，然后改变类名。项目内40%以上的代码都是模板性的，如果用手工copy、修改的方式来实现，就太烦人也没效率，而这时就是代码生成器小展身手的时候，使用代码生成器生成模板性的代码，减少手工操作的繁琐，集中精力在业务开发上，提升开发效率，代码生成器是一个很简单的东西，一点都不高深。","text":"在规模较小的公司里，大部分的项目规模不是特别大，技术实现难度不是很高，关注点更多是在业务功能的开发及保证业务流程的正确性上。当有一个新的项目来时，通常会找一个项目进行copy，删除不用的包和类，然后以此为基础，进行后续的开发，开发某个模块，就copy出一份controller、service、serviceImpl、dao、daoImpl、model、jsp，然后改变类名。项目内40%以上的代码都是模板性的，如果用手工copy、修改的方式来实现，就太烦人也没效率，而这时就是代码生成器小展身手的时候，使用代码生成器生成模板性的代码，减少手工操作的繁琐，集中精力在业务开发上，提升开发效率，代码生成器是一个很简单的东西，一点都不高深。 一、代码生成器能干什么？一个小型的业务项目（100张表以内），通常不需要很复杂的架构，一般就是通过单个或两个项目来实现。我们先来看下最基础的开发流程： 了解需求（项目负责人） 设计表结构（项目负责人） 创建基础框架（项目负责人） 制定开发计划，按模块分配任务（项目负责人） 进行模块开发（程序员A、B、C） 测试、上线 程序员进行模块开发的方式有以下几种： 根据表结构设计，手工创建model，然后copy UserDao改名为CompanyDao，copy UserServiceImpl改名为CompanyServiceImpl，并修改引用的UserDao为CompanyDao等； 根据表结构设计，使用工具生成model，后续步骤同1 如果不细心，总是要修改个两三遍才能让一个模块有一个架子，然后再开始进行真正关心的业务开发，而这时候时间可能已经过去了一个小时，或许更久。 程序员在开发时应该“懒”一点，如果类似的代码多次出现，不要在copy了，提取为公共的方法；如果类似的copy、修改的操作重复的出现的一个项目、不同的项目里，那就写个代码生成器吧，一键完成你手工几十步的操作。 代码生成器是用来生成有规律的代码的，就如controller、service、serviceImpl、dao、daoImpl、model、jsp的结构，用户、角色、权限等等模块都有类似的结构，代码生成器可以代替我们的copy操作，自动生成这些不同业务对象的模板代码。 二、代码生成器怎么实现？代码生成器的实现由很多种，我们以从mysql数据库表结构生成对应代码为例来说明如何实现一个代码生成器。有以下几个重点： 提前搭建好项目基础框架，因为生成的就是基础框架的模板代码 获取某个数据库内的表及表结构信息，用于生成model及其他代码 使用freemarker进行模板生成 1、提取基础框架如公司项目都是前后端分离的，那我就提取了一个rest-base项目作为基础框架，该框架满足绝大部分公司项目开发所需的基础功能 2、获取数据库表结构123456789101112 //获取所有库 select DISTINCT(TABLE_SCHEMA) from information_schema.`TABLES`; //获取所有表 SELECT TABLE_NAME as tableName,TABLE_COMMENT as tableComment from information_schema.`TABLES` where TABLE_SCHEMA='test'; //获取某个表的结构 select COLUMN_NAME as columnName,COLUMN_TYPE as columnType,COLUMN_DEFAULT as columnDefault,COLUMN_COMMENT as columnComment,CHARACTER_MAXIMUM_LENGTH as columnCharacterMaximumLength from information_schema.columns where table_schema = 'test' and table_name = 'rule'; 通过查询information_schema库内的TABLES、columns表，可以获取数据内的表、表字段属性等。然后就可以以此来确定model的内容，如表user_role对应的实体就是UserRole，表字段和实体属性可以根据类型和规则进行映射。 3、freemarker生成模板代码先大致讲下思路： 根据表明，按规则获取实体名称，从而也确认了dao、service等的类名； 将表字段转为map结构，作为参数传入model对于的模板内，从而生成对应的model类； 依次传入参数，通过模板生成dao、service等代码 需要会一点freemarker的语法，基本上看个一小时就达到了写简单模板的程度了。 接口：123456789101112131415161718192021222324252627282930313233 public interface GeneratorHelperService &#123; /** * 设置公共参数，如 * projectPath 要生成代码的项目的路径： D:/workspace/code-generator * packagePath 要生成代码的项目的包的根路径：/src/main/java/com/hexun/bdc/generator * templetePath 本项目内代码模板路径： /src/main/resources/code-templete */ boolean setProperty(Map&lt;String, String&gt; map); /** * 生成某个库内所有表对应的代码 * @author yangwenkui * @time 2017年10月29日 下午8:22:35 * @param dbname 数据库名称 * @return */ boolean allTables(String dbname); /** * 生成某个库内某个表对应的代码 * @author yangwenkui * @time 2017年10月29日 下午8:22:35 * @param dbname 数据库名称 * @param tableName 表名称 * @return */ boolean oneTable(String dbname, String tableName);&#125;实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148@Service(\"generatorHelperService\")public class GeneratorHelperServiceImpl implements GeneratorHelperService &#123; private static Logger logger = LoggerFactory .getLogger(GeneratorHelperServiceImpl.class); private static Map&lt;String, String&gt; propertyMap = Maps.newConcurrentMap(); @Autowired GeneratorHelperDao generatorHelperDao; @Value(\"$&#123;generator.project.path&#125;\") private String localProjectPath; @Override public boolean setProperty(Map&lt;String, String&gt; map) &#123; propertyMap.putAll(map); return true; &#125; @Override public boolean allTables(String dbname) &#123; List&lt;Object&gt; tables = generatorHelperDao.listAllTable(dbname); for (Object item : tables) &#123; Object[] arr = (Object[]) item; TableInfo tableInfo = new TableInfo(arr); boolean success = generateCode(dbname, tableInfo); if (!success) &#123; logger.error(\"generator code table=[&#123;&#125;] fail\", item.toString()); &#125; &#125; return true; &#125; @Override public boolean oneTable(String dbname, String tableName) &#123; Object entity = generatorHelperDao.findTableInfo(dbname, tableName); Object[] arr = (Object[]) entity; TableInfo tableInfo = new TableInfo(arr); return generateCode(dbname, tableInfo); &#125; private boolean generateCode(String dbname, TableInfo item) &#123; List&lt;Object&gt; list = generatorHelperDao.listColumInfos(dbname, item.getTabelName()); List&lt;ColumnInfo&gt; columnInfos = new ArrayList&lt;ColumnInfo&gt;(list.size()); String idType = \"String\"; for (Object obj : list) &#123; Object[] arr = (Object[]) obj; ColumnInfo columnInfo = new ColumnInfo(arr); columnInfos.add(columnInfo); if(\"id\".equals(arr[0]))&#123; if(\"int\".equals(columnInfo.getModelType()))&#123; idType = \"Integer\"; &#125; else if(\"long\".equals(columnInfo.getModelType()))&#123; idType = \"Long\"; &#125; &#125; &#125; item.setIdType(idType); createModel(item, columnInfos); createOther(item,\"dao\"); createOther(item,\"service\"); createOther(item,\"serviceImpl\"); createOther(item,\"controller\"); return true; &#125; private void createModel(TableInfo item, List&lt;ColumnInfo&gt; columnInfos) &#123; String path = getUpPath(); String dir = String.format(\"%s/domain\",path); File file = new File(dir); if(!file.exists())&#123; file.mkdirs(); &#125; String templetePath = String.format(\"%s%s\", localProjectPath,propertyMap.get(\"templetePath\")); String filePath = String.format(\"%s/%s.java\", dir,item.getModleName()); Map&lt;String, Object&gt; data = Maps.newHashMap(); data.put(\"proList\", columnInfos); data.put(\"modelParam\", String.format(\"%s%s\",item.getModleName().substring(0, 1).toLowerCase(),item.getModleName().substring(1))); data.put(\"modellower\", item.getModleName().toLowerCase()); data.put(\"tableInfo\", item); data.put(\"packagePath\", Joiner.on(\".\").join(propertyMap.get(\"packagePath\").split(\"/\")).substring(15)); createTempleteFile(filePath,templetePath,\"domain.flt\",data); &#125; private void createTempleteFile(String filename, String templetePath,String templeteName, Map&lt;String, Object&gt; data) &#123; try &#123; Configuration cfg = new Configuration(); cfg.setDirectoryForTemplateLoading(new File(templetePath)); cfg.setObjectWrapper(new DefaultObjectWrapper()); //设置字符集 cfg.setDefaultEncoding(\"UTF-8\"); //设置尖括号语法和方括号语法,默认是自动检测语法 // 自动 AUTO_DETECT_TAG_SYNTAX // 尖括号 ANGLE_BRACKET_TAG_SYNTAX // 方括号 SQUARE_BRACKET_TAG_SYNTAX cfg.setTagSyntax(Configuration.AUTO_DETECT_TAG_SYNTAX); Writer out = new OutputStreamWriter(new FileOutputStream(filename),\"UTF-8\"); Template temp = cfg.getTemplate(templeteName); temp.process(data, out); out.flush(); out.close(); &#125;catch (Exception e) &#123; logger.error(\"process due to erro\",e); &#125; &#125; private String getUpPath() &#123; return String.format(\"%s/%s\", propertyMap.get(\"projectPath\"), propertyMap.get(\"packagePath\")); &#125; private void createOther(TableInfo item,String type) &#123; String path = getUpPath(); String lastDir = type; if(\"serviceImpl\".equals(type))&#123; lastDir = \"service/impl\"; &#125; String dir = String.format(\"%s/%s\",path,lastDir); File file = new File(dir); if(!file.exists())&#123; file.mkdirs(); &#125; String templetePath = String.format(\"%s%s\", localProjectPath,propertyMap.get(\"templetePath\")); String filePath = String.format(\"%s/%s.java\", dir,item.getModleName()+type.substring(0,1).toUpperCase()+type.substring(1)); Map&lt;String, Object&gt; data = Maps.newHashMap(); data.put(\"modelParam\", String.format(\"%s%s\",item.getModleName().substring(0, 1).toLowerCase(),item.getModleName().substring(1))); data.put(\"modellower\", item.getModleName().toLowerCase()); data.put(\"item\", item); data.put(\"packagePath\", Joiner.on(\".\").join(propertyMap.get(\"packagePath\").split(\"/\")).substring(15)); createTempleteFile(filePath,templetePath,String.format(\"%s.flt\", type),data); &#125;&#125;model模板（domain.flt）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package $&#123;packagePath&#125;.domain;import io.swagger.annotations.ApiModelProperty;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;import java.sql.Timestamp;/** * $&#123;tableInfo.tableComment&#125; */@Entity@Table(name = \"$&#123;tableInfo.tabelName&#125;\")public class $&#123;tableInfo.modleName&#125; &#123; &lt;#list proList as item&gt;&lt;#if item.modelName == \"id\"&gt; @ApiModelProperty(value=\"主键\") @Id &lt;#if item.modelType == \"int\"&gt; @GeneratedValue(strategy=GenerationType.AUTO) private Integer id; &lt;/#if&gt; &lt;#if item.modelType == \"long\"&gt; @GeneratedValue(strategy=GenerationType.AUTO) private Long id; &lt;/#if&gt; &lt;#if item.modelType == \"String\"&gt; @GeneratedValue(generator=\"system-uuid\") @GenericGenerator(name=\"system-uuid\",strategy=\"uuid\") @Column(length=$&#123;item.modelCharacterMaximumLength&#125;) private String id;//主键 &lt;/#if&gt;&lt;#else&gt; @ApiModelProperty(value=\"$&#123;item.modelComment&#125;\") @Column(name=\"$&#123;item.columnName&#125;\"&lt;#if (item.modelCharacterMaximumLength?exists &amp;&amp; item.modelType == \"String\" &amp;&amp; item.modelCharacterMaximumLength?number&lt;=255)&gt;,length=$&#123;item.modelCharacterMaximumLength&#125;&lt;/#if&gt;&lt;#if item.modelDefault?exists &amp;&amp; item.modelDefault != \"\"&gt;,columnDefinition=\"$&#123;item.modelDefault&#125;\"&lt;/#if&gt;) private $&#123;item.modelType&#125; $&#123;item.modelName&#125;; &lt;/#if&gt;&lt;/#list&gt;&lt;#list proList as item&gt; public $&#123;item.modelType&#125; get$&#123;item.modelNameFirstUpper&#125;() &#123; return $&#123;item.modelName&#125;; &#125; public void set$&#123;item.modelNameFirstUpper&#125;($&#123;item.modelType&#125; $&#123;item.modelName&#125;) &#123; this.$&#123;item.modelName&#125; = $&#123;item.modelName&#125;; &#125; &lt;/#list&gt; @Override public String toString() &#123; return String.format(\"$&#123;tableInfo.modleName&#125; [&lt;#list proList as item&gt;, $&#123;item.modelName&#125;=%s&lt;/#list&gt;]\" &lt;#list proList as item&gt;, $&#123;item.modelName&#125;&lt;/#list&gt;); &#125;&#125;dao模板（dao.flt）：12345678910package $&#123;packagePath&#125;.dao;import com.hexun.bdc.base.component.common.BaseDao;import $&#123;packagePath&#125;.domain.$&#123;item.modleName&#125;;public interface $&#123;item.modleName&#125;Dao extends BaseDao&lt;$&#123;item.modleName&#125;, $&#123;item.idType&#125;&gt;&#123;&#125;代码逻辑不复杂，service提供了三个接口，setProperty用于设置要生成的代码的路径及包名等，allTables用于初次生成，一次生成一个库内所有表对应的代码；oneTable用于生成指定表对应的代码，注意代码开发一段时间后，不要在上传至svn之前给覆盖了。完整代码在code-generation，在此基础上，你可以很快修改出适合你公司的代码生成器！ 小结 提取一个基础框架吧，不要再copy项目，删除不用的类，改来改去，复制来复制去了 不要再花半个小时甚至更多时间在模板代码的copy修改上了，写个代码生成器，10s搞定 最后再插嘴一句，项目负责人要有意识的提高团队的开发效率，代码生成器是一个比较好的提示，希望能让你由此想到更多！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"代码生成器","slug":"代码生成器","permalink":"http://www.onecoderspace.com/tags/代码生成器/"}]},{"title":"spring boot项目实战之工具篇（ognl）","slug":"spring-boot-util-ognl","date":"2017-10-07T11:43:10.000Z","updated":"2017-10-07T12:54:32.000Z","comments":true,"path":"2017/10/07/spring-boot-util-ognl/","link":"","permalink":"http://www.onecoderspace.com/2017/10/07/spring-boot-util-ognl/","excerpt":"当解析复杂的json结构时，ognl是一个很方便的工具，实现基于图对属性的访问，类似于以(user.name | user.depart[0])的方式获取json内的嵌套对象字段值。","text":"当解析复杂的json结构时，ognl是一个很方便的工具，实现基于图对属性的访问，类似于以(user.name | user.depart[0])的方式获取json内的嵌套对象字段值。 请看以下示例，你将对ognl的作用有一个更清晰的理解：12345678String json = \"&#123;\\\"user\\\":&#123;\\\"name\\\":\\\"123\\\",\\\"depart\\\":[1,2]&#125;&#125;\";Map&lt;?, ?&gt; map = JacksonHelper.fromJson(json, Map.class);OgnlWrapper ognlWrapper = new OgnlWrapper(map);System.err.println(ognlWrapper.get(\"user.name\"));System.err.println(ognlWrapper.get(\"user.depart.size\"));System.err.println(ognlWrapper.get(\"user.depart[0]\")); 内部对象的普通字段可以通过user.name这样的方式获取 内部对象的集合字段可以通过user.depart.size获取其集合长度 内部对象的集合字段可以通过user.depart[0]的方式获取对应下标出的值 通常json对象解析可以通过一层一层的转换为map来实现，但如果嵌套对象层次有3层以上，内部结构较复杂，那实现起来就很繁琐，代码冗长，这种情况下使用ognl能让代码精简很多。 1、添加maven依赖1234567&lt;!-- ognl --&gt;&lt;dependency&gt; &lt;groupId&gt;ognl&lt;/groupId&gt; &lt;artifactId&gt;ognl&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; 2、OgnlWrapper1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@SuppressWarnings(\"unchecked\")public class OgnlWrapper &#123; private static Logger logger = LoggerFactory.getLogger(OgnlWrapper.class); private static ObjectMapper om = new ObjectMapper(); private Map&lt;String, Object&gt; payload; public OgnlWrapper(Map&lt;String, Object&gt; playload) &#123; Validate.notEmpty(playload, \"can not construct with none playload!\"); this.payload = playload; &#125; public OgnlWrapper(Object playload) &#123; this.payload = om.convertValue(playload, Map.class); &#125; public &lt;T&gt; T get(String expression) &#123; try &#123; return (T) Ognl.getValue(expression, this.payload); &#125; catch (OgnlException e) &#123; logger.trace(String.format(\"get value with expression:[%s] due to error, return null instead of\", expression), e); return null; &#125; &#125; public Long getLong(String expression) &#123; try &#123; Object obj = Ognl.getValue(expression, this.payload); if (null == obj) return null; try &#123; return Long.parseLong(obj.toString()); &#125; catch (NumberFormatException nfe) &#123; logger.warn(String.format(\"get value with expression:[%s] due to error, return null. value[%s] cannot be cast to java.lang.Long\", expression, obj.toString())); return null; &#125; &#125; catch (OgnlException e) &#123; logger.trace(String.format(\"get value with expression:[%s] due to error, return null instead of\", expression), e); return null; &#125; &#125; public Integer getInt(String expression) &#123; try &#123; Object obj = Ognl.getValue(expression, this.payload); if (null == obj) return null; try &#123; return Integer.parseInt(obj.toString()); &#125; catch (NumberFormatException nfe) &#123; logger.warn(String.format(\"get value with expression:[%s] due to error, return null. value[%s] cannot be cast to java.lang.Integer\", expression, obj.toString())); return null; &#125; &#125; catch (OgnlException e) &#123; logger.trace(String.format(\"get value with expression:[%s] due to error, return null instead of\", expression), e); return null; &#125; &#125; @Override public String toString() &#123; return String.format(\"OgnlWrapper[%s]\", this.payload.toString()); &#125; public static void main(String[] args) &#123; String json = \"&#123;\\\"user\\\":&#123;\\\"name\\\":\\\"123\\\",\\\"depart\\\":[1,2]&#125;&#125;\"; Map&lt;?, ?&gt; map = JacksonHelper.fromJson(json, Map.class); OgnlWrapper ognlWrapper = new OgnlWrapper(map); System.err.println(ognlWrapper.get(\"user.name\")); System.err.println(ognlWrapper.get(\"user.depart.size\")); System.err.println(ognlWrapper.get(\"user.depart[0]\")); &#125;&#125; 3、使用手册说明OgnlWrapper是基于ognl.Ognl类的一个工具类，实现基于图对属性的访问，支持ognl的所有语法。 提供三个核心方法:get();getLong(); //如果值非long型，将返回nullgetInt(); //如果值非int型，将返回null 使用注意在使用Long longvalue = ognlWrapper.get(“body.payload.page.page_size”); 时出现如下错误: java.lang.ClassCastException: java.lang.Long cannot be cast to java.lang.Integer解决方法:使用getLong方法Long longvalue = ognlWrapper.getLong(“body.payload.page.page_size”); 获取不存在的属性时返回null，日志中会打印warn警告日志。 如:ognlWrapper.getLong(“body.payload[0].childrens[0].childrens.size”); // return null 单个对象123456789101112131415161718User user = new User(); //设置用户的相关属性//...省略属性设置//使用OgnlWrapperOgnlWrapper ognlWrapper = new OgnlWrapper(user);String id = ognlWrapper.get(\"id\");//获取id//状态. 请使用基本数据类型的封装类型Integer status = ognlWrapper.getInt(\"status\"); //联系信息中的邮件地址String email = ognlWrapper.get(\"contact_info.email\");//获取一个不存在的属性//将返回nullString noexist = ognlWrapper.get(\"noexist\"); //将返回nullnoexist = ognlWrapper.get(\"contact_info.noexist\"); 对list操作123456789101112131415//将存放用户的列表数据放到map中 map.put(\"users\",list);//使用OgnlWrapper获取用户列表数据OgnlWrapper ognlWrapper = new OgnlWrapper(map);//获取list大小。如果map未存放list则返回nullInteger size = ognlWrapper.getInt(\"users.size\"); if(null == size || 0 == size.intValue()) return ;//获取list中第一用户的用户id和name 注意:下标从0开始String id = ognlWrapper.get(\"users[0].id\");String name = ognlWrapper.get(\"users[0].name\");//如果索引超出list的大小，将返回nullString nullvalue = ognlWrapper.get(\"users[9999999].id\"); 使用OgnlWrapper获取属性值时，请使用对象类型。如int 使用Integer类型。","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"ognl","slug":"ognl","permalink":"http://www.onecoderspace.com/tags/ognl/"}]},{"title":"spring boot项目实战-json","slug":"spring-boot-json-util","date":"2017-10-07T10:49:45.000Z","updated":"2017-10-07T11:23:28.000Z","comments":true,"path":"2017/10/07/spring-boot-json-util/","link":"","permalink":"http://www.onecoderspace.com/2017/10/07/spring-boot-json-util/","excerpt":"对象转json、json转对象是我们开发过程中经常遇到的，提取一套高效、易用的工具类会让开发过程舒爽不少，下面提供一个基于jackson包的常用json工具方法。","text":"对象转json、json转对象是我们开发过程中经常遇到的，提取一套高效、易用的工具类会让开发过程舒爽不少，下面提供一个基于jackson包的常用json工具方法。 1、添加maven依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt;&lt;/dependency&gt; 2、对象转为json1234567891011121314151617181920private static final ObjectMapper mapper = new ObjectMapper();/** * 将对象转化为json * @author yangwenkui * @time 2017年3月16日 下午2:55:10 * @param obj 待转化的对象 * @return 当转化发生异常时返回null */public static String toJson(Object obj)&#123; if(obj == null)&#123; return null; &#125; try &#123; return mapper.writeValueAsString(obj); &#125; catch (IOException e) &#123; logger.error(String.format(\"obj=[%s]\", obj.toString()), e); &#125; return null;&#125; 3、json转为对象1234567891011121314151617181920/** * 将json转化为对象 * @author yangwenkui * @time 2017年3月16日 下午2:56:26 * @param json json对象 * @param clazz 待转化的对象类型 * @return 当转化发生异常时返回null */public static &lt;T&gt; T fromJson(String json,Class&lt;T&gt; clazz)&#123; if(json == null)&#123; return null; &#125; try &#123; return mapper.readValue(json, clazz); &#125; catch (IOException e) &#123; logger.error(String.format(\"json=[%s]\", json), e); &#125; return null;&#125; 4、json转为集合对象123456789101112131415161718192021222324252627/** * 将json对象转化为集合类型 * @author yangwenkui * @time 2017年3月16日 下午2:57:15 * @param json json对象 * @param collectionClazz 具体的集合类的class，如：ArrayList.class * @param clazz 集合内存放的对象的class * @return */@SuppressWarnings(\"rawtypes\")public static &lt;T&gt; Collection&lt;T&gt; fromJson(String json,Class&lt;? extends Collection&gt; collectionClazz,Class&lt;T&gt; clazz)&#123; if(json == null)&#123; return null; &#125; try &#123; Collection&lt;T&gt; collection = mapper.readValue(json, getCollectionType(collectionClazz,clazz)); return collection; &#125; catch (IOException e) &#123; logger.error(String.format(\"json=[%s]\", json), e); &#125; return null;&#125;private static JavaType getCollectionType(Class&lt;?&gt; collectionClass, Class&lt;?&gt;... elementClasses) &#123; return mapper.getTypeFactory().constructParametricType(collectionClass, elementClasses); &#125; 小结 常用的JSON技术有，json-lib、Jackson、Gson、FastJson，在易用性、性能等方面Jackson都表现不错，推荐使用Jackson包； 将对象对象存入缓存、从缓存内取出字符串转为对象、REST API接口返回结果转为对象等诸多场景下都有对象和json之间的转换操作，“见到经常出现的重复代码，提取出来作为通用方法是一个好的习惯”。 完整代码请参考github内rest-base项目com.onecoderspace.base.util.JacksonHelper。https://github.com/q7322068/rest-base","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"json","slug":"json","permalink":"http://www.onecoderspace.com/tags/json/"}]},{"title":"spring boot实战之集合操作","slug":"spring-boot-collection-util","date":"2017-10-07T01:14:19.000Z","updated":"2017-10-07T08:47:03.000Z","comments":true,"path":"2017/10/07/spring-boot-collection-util/","link":"","permalink":"http://www.onecoderspace.com/2017/10/07/spring-boot-collection-util/","excerpt":"集合操作在web应用开发中也是很常见的，目前也有一些比较方便的工具如java.util.Collections、org.apache.commons.collections.CollectionUtils等，但是根据自己公司项目开发中的具体情况提取一套更何用的集合操作工具类也是很有帮助的。","text":"集合操作在web应用开发中也是很常见的，目前也有一些比较方便的工具如java.util.Collections、org.apache.commons.collections.CollectionUtils等，但是根据自己公司项目开发中的具体情况提取一套更何用的集合操作工具类也是很有帮助的。 1、获取在集合A而不在集合B内的元素（差集）12345678910111213141516171819202122/** * 获取在first集合内而不在second集合内的元素 * @param first * @param second * @return */ public static List&lt;String&gt; getDiffList(Collection&lt;String&gt; first, Collection&lt;String&gt; second) &#123; long t = System.currentTimeMillis(); Set&lt;String&gt; sameString = new HashSet&lt;String&gt;(second); List&lt;String&gt; result = new ArrayList&lt;String&gt;(first.size()); for (String s : first) &#123; if (!sameString.contains(s)) &#123; result.add(s); &#125; &#125; if(System.currentTimeMillis() - t &gt; 1)&#123; logger.debug(\"getDiffList with list first.size=&#123;&#125;,sencond.size=&#123;&#125;,use time=&#123;&#125;ms\",first.size(),second.size(),System.currentTimeMillis()-t); &#125; return result; &#125; 比较重要的点是将second集合转换为set，因为set判断是否包含一个元素时间复杂度是O(1) 2、获得在集合A内同时在集合B内的元素（交集）12345678910111213141516171819202122/** * 获得在list内同时在list2内的元素 * 注意：在结果集内并不去重，如果list内本身有重复，返回的结果内可能包含相同元素 * @param list * @param list2 * @return */ public static List&lt;String&gt; getSameElements(Collection&lt;String&gt; list, Collection&lt;String&gt; list2) &#123; long t = System.nanoTime(); Set&lt;String&gt; set = new HashSet&lt;String&gt;(list2); List&lt;String&gt; sameElements = new ArrayList&lt;String&gt;(list.size()); for(String item : list)&#123; if(set.contains(item))&#123; sameElements.add(item); &#125; &#125; if(logger.isDebugEnabled())&#123; logger.debug(\"getSameElements list.size=&#123;&#125;,list2.size=&#123;&#125;,use time=&#123;&#125;ns\",list.size(),list2.size(),System.nanoTime()-t); &#125; return sameElements;&#125; 3、将字符串转成list123456789101112131415161718192021/** * 辅助方法，将字符串分割转换为list * @author yangwenkui * @time 2017年1月10日 下午4:22:20 * @param provinceIds * @return */public static List&lt;String&gt; stringToList(String str,String split) &#123; if(StringUtils.isBlank(str))&#123; return Lists.newArrayList(); &#125; String[] arr = str.split(split); List&lt;String&gt; list = new ArrayList&lt;String&gt;(arr.length); for(String item : arr)&#123; if(StringUtils.isNotBlank(item))&#123; list.add(item); &#125; &#125; return list;&#125; 经常会有将id等用逗号连接存储或传输，然后转成集合进行操作的场景 4、获取集合内每个实体的id123456789101112131415161718/** * 获取集合内每个实体的id */public static &lt;T extends Serializable&gt; List&lt;T&gt; getEntityIds(Collection&lt;? extends BaseModel&lt;T&gt;&gt; items) &#123; List&lt;T&gt; ids = Lists.newArrayList(); if(CollectionUtils.isEmpty(items))&#123; return ids; &#125; for(BaseModel&lt;T&gt; entity : items)&#123; T id = entity.getId(); if(!ids.contains(id))&#123; ids.add(id); &#125; &#125; return ids;&#125; BaseModel是一个接口，定义了一个getId()方法 5、根据id列表找到集合内对应的实体1234567891011121314151617181920/** * 根据id列表找到集合内对应的实体 * @return */public static &lt;T extends BaseModel&lt;String&gt;&gt; List&lt;T&gt; select(Collection&lt;T&gt; list,Collection&lt;String&gt; selects)&#123; if(CollectionUtils.isEmpty(list) || CollectionUtils.isEmpty(selects))&#123; return Lists.newArrayList(); &#125; List&lt;T&gt; selectList = Lists.newArrayList(); for (String id : selects) &#123; for(T entity : list)&#123; if(id.equals(entity.getId()))&#123; selectList.add(entity); break; &#125; &#125; &#125; return selectList;&#125; 小结 求集合的交集、差集注意查找实现的时间复杂度，list查找时间复杂度是O(n)，HashSet查找时间复杂度是O(1)，建议使用HashSet。测试发现效率差了5倍以上（集合A（1500元素）、集合B（500元素））； 将集合转为字符串可以使用com.google.common.base.Joiner.on(“,”).join(list)实现，将字符串转为list可以使用上文内的方法； 类似于获取集合内每个元素的id（getEntityIds）、根据id列表找到集合内对应的实体（select）这样和业务比较紧密的方法应该也会经常出现，大家可以根据自身项目情况，将这些模板类的代码提取出来作为公共工具包。 完整内容请参考github内rest-base项目内代码。https://github.com/q7322068/rest-base","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"集合","slug":"集合","permalink":"http://www.onecoderspace.com/tags/集合/"},{"name":"工具类","slug":"工具类","permalink":"http://www.onecoderspace.com/tags/工具类/"}]},{"title":"spring boot实战之日期处理","slug":"spring-boot-utils","date":"2017-10-06T09:47:29.000Z","updated":"2017-10-06T11:56:44.000Z","comments":true,"path":"2017/10/06/spring-boot-utils/","link":"","permalink":"http://www.onecoderspace.com/2017/10/06/spring-boot-utils/","excerpt":"web开发中经常需要对日期进行操作，如字符串日期转long，long型转字符串，日期计算等，提取一个日期处理工具类，提供常见的日期操作可以让开发更轻松一些。","text":"web开发中经常需要对日期进行操作，如字符串日期转long，long型转字符串，日期计算等，提取一个日期处理工具类，提供常见的日期操作可以让开发更轻松一些。 毫秒（long）转字符串日期对long型时间进行格式化在web开发中是很经常出现的一个操作，这里主要使用joda-time包内的DateTime来实现，joda-time是时间操作很好的一个工具包。1234567891011121314151617181920212223242526272829303132333435public final static String DATE_FORMAT_DEFAULT = \"yyyy-MM-dd\";/** * 将毫秒时间转换为yyyy-MM-dd格式的时间 * @author yangwenkui * @time 2017年10月6日 下午5:56:40 * @param time 毫秒数 * @return */public static String longToString(long time) &#123; return longToString(time, DATE_FORMAT_DEFAULT);&#125;/** * 将毫秒时间转换为指定格式的时间 * @author yangwenkui * @time 2017年10月6日 下午5:56:40 * @param time 毫秒数 * @param format 日期格式 * @return */public static String longToString(long time, String format) &#123; if (StringUtils.isBlank(format)) &#123; format = DATE_FORMAT_DEFAULT; &#125; DateTime dTime = new DateTime(time); return dTime.toString(format);&#125;//添加maven依赖&lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt;&lt;/dependency&gt; 字符串日期转毫秒（long)字符串日期转为毫秒值也是web开发内经常出现的一个场景，这里主要根据字符串的长度来判断其格式，进而截取字符串获取年、月、日等，再将这些值设置入calender内对应的属性上获取最终的时间。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * 将字符串类型的日期转换为毫秒数 * @author yangwenkui * @time 2017年10月6日 下午6:00:27 * @param dateStr * @return */public static long parseStringToLong(String dateStr) &#123; dateStr = dateStr.trim(); if (dateStr.length() == 19 || dateStr.length() == 23) &#123; try &#123; java.util.Calendar cal = java.util.Calendar.getInstance(); cal.set(Integer.parseInt(dateStr.substring(0, 4)), Integer.parseInt(dateStr.substring(5, 7)) - 1, Integer.parseInt(dateStr.substring(8, 10)), Integer.parseInt(dateStr.substring(11, 13)), Integer.parseInt(dateStr.substring(14, 16)), Integer.parseInt(dateStr.substring(17, 19))); cal.set(java.util.Calendar.MILLISECOND, 0); return (cal.getTime().getTime()); &#125; catch (Exception e) &#123; return 0; &#125; &#125; else if (dateStr.length() == 16) &#123; try &#123; java.util.Calendar cal = java.util.Calendar.getInstance(); cal.set(Integer.parseInt(dateStr.substring(0, 4)), Integer.parseInt(dateStr.substring(5, 7)) - 1, Integer.parseInt(dateStr.substring(8, 10)), Integer.parseInt(dateStr.substring(11, 13)), Integer.parseInt(dateStr.substring(14, 16))); cal.set(java.util.Calendar.MILLISECOND, 0); return (cal.getTime().getTime()); &#125; catch (Exception e) &#123; return 0; &#125; &#125; else if (dateStr.length() == 14) &#123; try &#123; java.util.Calendar cal = java.util.Calendar.getInstance(); cal.set(Integer.parseInt(dateStr.substring(0, 4)), Integer.parseInt(dateStr.substring(4, 6)) - 1, Integer.parseInt(dateStr.substring(6, 8)), Integer.parseInt(dateStr.substring(8, 10)), Integer.parseInt(dateStr.substring(10, 12)), Integer.parseInt(dateStr.substring(12, 14))); cal.set(java.util.Calendar.MILLISECOND, 0); return (cal.getTime().getTime()); &#125; catch (Exception e) &#123; return 0; &#125; &#125; else if (dateStr.length() == 10 || dateStr.length() == 11) &#123; try &#123; java.util.Calendar cal = java.util.Calendar.getInstance(); cal.set(Integer.parseInt(dateStr.substring(0, 4)), Integer.parseInt(dateStr.substring(5, 7)) - 1, Integer.parseInt(dateStr.substring(8, 10)), 0, 0, 0); cal.set(java.util.Calendar.MILLISECOND, 0); return (cal.getTime().getTime()); &#125; catch (Exception e) &#123; return 0; &#125; &#125; else if (dateStr.length() == 8 ) &#123; try &#123; java.util.Calendar cal = java.util.Calendar.getInstance(); cal.set(Integer.parseInt(dateStr.substring(0, 4)), Integer.parseInt(dateStr.substring(4, 6)) - 1, Integer.parseInt(dateStr.substring(6, 8)), 0, 0, 0); cal.set(java.util.Calendar.MILLISECOND, 0); return (cal.getTime().getTime()); &#125; catch (Exception e) &#123; return 0; &#125; &#125; else &#123; try &#123; return Long.parseLong(dateStr); &#125; catch (Exception e) &#123; return 0; &#125; &#125;&#125; 获取指定日期前后N天的日期日期计算偶尔也会出现，这里主要通过java.util.Calendar类来实现，Calendar提供了良好的接口，可以方便的获取年、月、日、时、分、秒、周等，也可以对应的设置指定属性的值，是很方便的日期计算工具。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 获取指定日期前后num天的日期 * @author yangwk * @time 2017年9月14日 上午11:13:18 * @param date * @param num 正数 多少天之后的日期 负数 多少天之后的日期 * @return */public static String getDay(String date,int num)&#123; return getDay(date, num,DATE_FORMAT_DEFAULT);&#125;/** * 获取指定日期前后num天的日期 * @author yangwk * @time 2017年9月14日 上午11:13:18 * @param date * @param num 正数 多少天之后的日期 负数 多少天之后的日期 * @param format 日期格式 * @return */public static String getDay(String date,int num,String format)&#123; long t = parseStringToLong(date); return getDay(t, num, DATE_FORMAT_DEFAULT);&#125;/** * 获取指定日期前后num天的日期 * @author yangwk * @time 2017年9月14日 上午11:13:18 * @param date * @param num 正数 多少天之后的日期 负数 多少天之后的日期 * @return */public static String getDay(long date,int num)&#123; return getDay(date, num, DATE_FORMAT_DEFAULT);&#125;/** * 获取指定日期前后num天的日期 * @author yangwk * @time 2017年9月14日 上午11:13:18 * @param date * @param num 正数 多少天之后的日期 负数 多少天之后的日期 * @param format 日期格式 * @return */public static String getDay(long date,int num,String format)&#123; Calendar calendar = Calendar.getInstance(); calendar.setTimeInMillis(date); calendar.set(Calendar.DAY_OF_MONTH, calendar.get(Calendar.DAY_OF_MONTH)+num); return longToString(calendar.getTimeInMillis(),format);&#125; 小结web开发内，提取常用工具类，不断丰富开发工具包是很有意义的事，不用同样的事情自己或其他同事重复开发很多次。本文列出了比较常用的long型时间格式化、string类型时间转为long型毫秒数及日期计算的方法。可以基于joda-time包和calendar提前自己常用的攻击方法。 完整内容请参考github内rest-base项目内代码。https://github.com/q7322068/rest-base","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"日期处理","slug":"日期处理","permalink":"http://www.onecoderspace.com/tags/日期处理/"}]},{"title":"spring boot实战之CSRF（跨站请求伪造）","slug":"spring-boot-csrf","date":"2017-10-06T06:55:47.000Z","updated":"2017-10-06T08:57:32.000Z","comments":true,"path":"2017/10/06/spring-boot-csrf/","link":"","permalink":"http://www.onecoderspace.com/2017/10/06/spring-boot-csrf/","excerpt":"CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。攻击通过在授权用户访问的页面中包含链接或者脚本的方式工作。例如：一个网站用户Bob可能正在浏览聊天论坛，而同时另一个用户Alice也在此论坛中，并且后者刚刚发布了一个具有Bob银行链接的图片消息。设想一下，Alice编写了一个在Bob的银行站点上进行取款的form提交的链接，并将此链接作为图片src。如果Bob的银行在cookie中保存他的授权信息，并且此cookie没有过期，那么当Bob的浏览器尝试装载图片时将提交这个取款form和他的cookie，这样在没经Bob同意的情况下便授权了这次事务。","text":"CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。攻击通过在授权用户访问的页面中包含链接或者脚本的方式工作。例如：一个网站用户Bob可能正在浏览聊天论坛，而同时另一个用户Alice也在此论坛中，并且后者刚刚发布了一个具有Bob银行链接的图片消息。设想一下，Alice编写了一个在Bob的银行站点上进行取款的form提交的链接，并将此链接作为图片src。如果Bob的银行在cookie中保存他的授权信息，并且此cookie没有过期，那么当Bob的浏览器尝试装载图片时将提交这个取款form和他的cookie，这样在没经Bob同意的情况下便授权了这次事务。 下面是CSRF的常见特性： 依靠用户标识危害网站 利用网站对用户标识的信任 欺骗用户的浏览器发送HTTP请求给目标站点 可以通过IMG标签会触发一个GET请求，可以利用它来实现CSRF攻击 一个简单的例子： 用户小z登录了网站A，同时打开网站B 网站B隐蔽的发送一个请求至网站A 网站A通过session、cookie等身份标记判断是用户小z，执行对应操作 这样网站B内的非法代码就盗用了用户小z的身份，在小z不知情的情况下执行了攻击者需要的操作，这就是跨站请求伪造。 防御CSRF可以通过动态token验证的方式来实现，每次请求生成一个动态token给前端，前端在后续的请求中附加该token，如果token不存在或不正确说明不是正常请求，予以屏蔽，从而达到解决CSRF问题的目的，以下是具体实现。 1、登录成功设置token1234567String uuidToken = UUID.randomUUID().toString();map.put(\"token\", uuidToken);currentUser.getSession().setTimeout(NumberUtils.toLong(serverSessionTimeout, 1800)*1000);request.getSession().setAttribute(\"token\",uuidToken );return map; 前后端分离架构，登录成功后将token传递给前端，由前端进行保存。 2、创建CSRFFilter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * CSRF跨域请求伪造拦截 * 除登录以外的post方法，都需要携带token，如果token为空或token错误，则返回异常提示 * 注意在filter初始化参数内配置排除的url * @author yangwk */ public class CsrfFilter implements Filter &#123; private static Logger logger = LoggerFactory.getLogger(CsrfFilter.class); public List&lt;String&gt; excludes = new ArrayList&lt;String&gt;(); private boolean isOpen = false;//是否开启该filter public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException,ServletException &#123; if(!isOpen)&#123; filterChain.doFilter(request, response); return ; &#125; if(logger.isDebugEnabled())&#123; logger.debug(\"csrf filter is running\"); &#125; HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; HttpSession session = req.getSession(); Object token = session.getAttribute(\"token\"); if(!\"post\".equalsIgnoreCase(req.getMethod()) || handleExcludeURL(req, resp) || token == null)&#123; filterChain.doFilter(request, response); return; &#125; String requestToken = req.getParameter(\"token\"); if(StringUtils.isBlank(requestToken) || !requestToken.equals(token))&#123; AjaxResponseWriter.write(req, resp, ServiceStatusEnum.ILLEGAL_TOKEN, \"非法的token\"); return; &#125; filterChain.doFilter(request, response); &#125; private boolean handleExcludeURL(HttpServletRequest request, HttpServletResponse response) &#123; if (excludes == null || excludes.isEmpty()) &#123; return false; &#125; String url = request.getServletPath(); for (String pattern : excludes) &#123; Pattern p = Pattern.compile(\"^\" + pattern); Matcher m = p.matcher(url); if (m.find()) &#123; return true; &#125; &#125; return false; &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; if(logger.isDebugEnabled())&#123; logger.debug(\"csrf filter init~~~~~~~~~~~~\"); &#125; String temp = filterConfig.getInitParameter(\"excludes\"); if (temp != null) &#123; String[] url = temp.split(\",\"); for (int i = 0; url != null &amp;&amp; i &lt; url.length; i++) &#123; excludes.add(url[i]); &#125; &#125; temp = filterConfig.getInitParameter(\"isOpen\"); if(StringUtils.isNotBlank(temp) &amp;&amp; \"true\".equals(isOpen))&#123; isOpen = true; &#125; &#125; @Override public void destroy() &#123;&#125; &#125; 除登录之外，post方式提交的请求都需要携带token，用于验证。 3、注册CSRFFilter1234567891011121314151617/** * csrf过滤拦截器 */@Beanpublic FilterRegistrationBean csrfFilterRegistrationBean() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new CsrfFilter()); filterRegistrationBean.setOrder(2); filterRegistrationBean.setEnabled(true); filterRegistrationBean.addUrlPatterns(\"/*\"); Map&lt;String, String&gt; initParameters = Maps.newHashMap(); initParameters.put(\"excludes\", \"/login/*\"); initParameters.put(\"isOpen\", isCsrfFilterOpen); filterRegistrationBean.setInitParameters(initParameters); return filterRegistrationBean;&#125; 小结防御CSRF攻击可以通过在表单内添加随机token来实现，本例内未提供token刷新机制，可根据具体情况调整，如使用一次后刷新或用旧的token获取新的token等，不能提供一个刷新接口，让前端直接调用而不验证旧有token，那样该接口本身就是不安全的，会被伪用户调用。具体实现： 登录成功，返回token给前端（前后端分离架构）； 创建CsrfFilter，对非登录的post请求，验证其token是否正确； 注册CSRFFilter 如有需要，可在token使用后刷新或前端控制使用旧token换取新token。 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"CSRF","slug":"CSRF","permalink":"http://www.onecoderspace.com/tags/CSRF/"}]},{"title":"spring boot实战之XSS过滤","slug":"spring-boot-xss","date":"2017-10-06T03:24:25.000Z","updated":"2017-10-06T06:54:01.000Z","comments":true,"path":"2017/10/06/spring-boot-xss/","link":"","permalink":"http://www.onecoderspace.com/2017/10/06/spring-boot-xss/","excerpt":"XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。","text":"XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。 你可以自己做个简单尝试： 在任何一个表单内，你输入一段简单的js代码：&lt;script&gt;for(var i=0;i&lt;1000;i++){alert(&quot;弹死你&quot;+i);}&lt;/script&gt;，将其存入数据库； 在页面上一个div元素内直接展示第一步内存入的值，你会发现弹出框出现了； 以上XSS攻击只算一个小恶作剧，但如果这玩意被发到了网站的首页上，我估计老板一定会因为频繁的投诉而和你来场愉快的谈话… 以上两个示例仅仅算是恶作剧，恶意用户能做的更多，如获取用户信息，进行“网络钓鱼”攻击等。 应对XSS攻击的其中一个方式就是后端对输入内容进行过滤，输入内容里面的敏感信息直接过滤，如&lt;script&gt;标签等，以下来说明如何在spring boot项目内方便快捷的实现XSS过滤。 1、Jsoup组件Jsoup使用标签白名单的机制用来进行防止XSS攻击, 假设白名单中只允许p标签存在, 此时在一段HTML代码中, 只能存在p标签 , 其他标签将会被清除只保留被标签所包裹的内容，因此使用Jsoup组件来进行内容过滤。 添加maven依赖：1234567&lt;!-- xss过滤组件 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt; JsoupUtil提供基于Jsoup过滤非法标签的工具类：123456789101112131415161718192021222324252627282930313233/** * xss非法标签过滤 * &#123;@link http://www.jianshu.com/p/32abc12a175a?nomobile=yes&#125; */public class JsoupUtil &#123; /** * 使用自带的basicWithImages 白名单 * 允许的便签有a,b,blockquote,br,cite,code,dd,dl,dt,em,i,li,ol,p,pre,q,small,span, * strike,strong,sub,sup,u,ul,img * 以及a标签的href,img标签的src,align,alt,height,width,title属性 */ private static final Whitelist whitelist = Whitelist.basicWithImages(); /** 配置过滤化参数,不对代码进行格式化 */ private static final Document.OutputSettings outputSettings = new Document.OutputSettings().prettyPrint(false); static &#123; // 富文本编辑时一些样式是使用style来进行实现的 // 比如红色字体 style=\"color:red;\" // 所以需要给所有标签添加style属性 whitelist.addAttributes(\":all\", \"style\"); &#125; public static String clean(String content) &#123; return Jsoup.clean(content, \"\", whitelist, outputSettings); &#125; public static void main(String[] args) throws FileNotFoundException, IOException &#123; String text = \"&lt;a href=\\\"http://www.baidu.com/a\\\" onclick=\\\"alert(1);\\\"&gt;sss&lt;/a&gt;&lt;script&gt;alert(0);&lt;/script&gt;sss\"; System.out.println(clean(text)); &#125;&#125; 2、创建XssHttpServletRequestWrapper这是实现XSS过滤的关键，在其内重写了getParameter，getParameterValues，getHeader等方法，对http请求内的参数进行了过滤。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper &#123; HttpServletRequest orgRequest = null; private boolean isIncludeRichText = false; public XssHttpServletRequestWrapper(HttpServletRequest request, boolean isIncludeRichText) &#123; super(request); orgRequest = request; this.isIncludeRichText = isIncludeRichText; &#125; /** * 覆盖getParameter方法，将参数名和参数值都做xss过滤。&lt;br/&gt; * 如果需要获得原始的值，则通过super.getParameterValues(name)来获取&lt;br/&gt; * getParameterNames,getParameterValues和getParameterMap也可能需要覆盖 */ @Override public String getParameter(String name) &#123; if((\"content\".equals(name) || name.endsWith(\"WithHtml\")) &amp;&amp; !isIncludeRichText)&#123; return super.getParameter(name); &#125; name = JsoupUtil.clean(name); String value = super.getParameter(name); if (StringUtils.isNotBlank(value)) &#123; value = JsoupUtil.clean(value); &#125; return value; &#125; @Override public String[] getParameterValues(String name) &#123; String[] arr = super.getParameterValues(name); if(arr != null)&#123; for (int i=0;i&lt;arr.length;i++) &#123; arr[i] = JsoupUtil.clean(arr[i]); &#125; &#125; return arr; &#125; /** * 覆盖getHeader方法，将参数名和参数值都做xss过滤。&lt;br/&gt; * 如果需要获得原始的值，则通过super.getHeaders(name)来获取&lt;br/&gt; * getHeaderNames 也可能需要覆盖 */ @Override public String getHeader(String name) &#123; name = JsoupUtil.clean(name); String value = super.getHeader(name); if (StringUtils.isNotBlank(value)) &#123; value = JsoupUtil.clean(value); &#125; return value; &#125; /** * 获取最原始的request * * @return */ public HttpServletRequest getOrgRequest() &#123; return orgRequest; &#125; /** * 获取最原始的request的静态方法 * * @return */ public static HttpServletRequest getOrgRequest(HttpServletRequest req) &#123; if (req instanceof XssHttpServletRequestWrapper) &#123; return ((XssHttpServletRequestWrapper) req).getOrgRequest(); &#125; return req; &#125; &#125; 3、创建XssFilterXssFilter是过滤XSS请求的入口，在这里通过XssHttpServletRequestWrapper将HttpServletRequest进行了封装，filterChain.doFilter(xssRequest, response);保证了后续代码执行request.getParameter，request.getParameterValues，request.getHeader时调用的都是XssHttpServletRequestWrapper内重写的方法，获取到的参数是已经进行过标签过滤的内容，从而消除了敏感信息。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 拦截防止xss注入 * 通过Jsoup过滤请求参数内的特定字符 * @author yangwk */ public class XssFilter implements Filter &#123; private static Logger logger = LoggerFactory.getLogger(XssFilter.class); private static boolean IS_INCLUDE_RICH_TEXT = false;//是否过滤富文本内容 public List&lt;String&gt; excludes = new ArrayList&lt;String&gt;(); public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException,ServletException &#123; if(logger.isDebugEnabled())&#123; logger.debug(\"xss filter is open\"); &#125; HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; if(handleExcludeURL(req, resp))&#123; filterChain.doFilter(request, response); return; &#125; XssHttpServletRequestWrapper xssRequest = new XssHttpServletRequestWrapper((HttpServletRequest) request,IS_INCLUDE_RICH_TEXT); filterChain.doFilter(xssRequest, response); &#125; private boolean handleExcludeURL(HttpServletRequest request, HttpServletResponse response) &#123; if (excludes == null || excludes.isEmpty()) &#123; return false; &#125; String url = request.getServletPath(); for (String pattern : excludes) &#123; Pattern p = Pattern.compile(\"^\" + pattern); Matcher m = p.matcher(url); if (m.find()) &#123; return true; &#125; &#125; return false; &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; if(logger.isDebugEnabled())&#123; logger.debug(\"xss filter init~~~~~~~~~~~~\"); &#125; String isIncludeRichText = filterConfig.getInitParameter(\"isIncludeRichText\"); if(StringUtils.isNotBlank(isIncludeRichText))&#123; IS_INCLUDE_RICH_TEXT = BooleanUtils.toBoolean(isIncludeRichText); &#125; String temp = filterConfig.getInitParameter(\"excludes\"); if (temp != null) &#123; String[] url = temp.split(\",\"); for (int i = 0; url != null &amp;&amp; i &lt; url.length; i++) &#123; excludes.add(url[i]); &#125; &#125; &#125; @Override public void destroy() &#123;&#125; &#125; 4、注册XssFilter通过java config的方式注册XSSFilter，使其生效。1234567891011121314151617/** * xss过滤拦截器 */@Beanpublic FilterRegistrationBean xssFilterRegistrationBean() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new XssFilter()); filterRegistrationBean.setOrder(1); filterRegistrationBean.setEnabled(true); filterRegistrationBean.addUrlPatterns(\"/*\"); Map&lt;String, String&gt; initParameters = Maps.newHashMap(); initParameters.put(\"excludes\", \"/favicon.ico,/img/*,/js/*,/css/*\"); initParameters.put(\"isIncludeRichText\", \"true\"); filterRegistrationBean.setInitParameters(initParameters); return filterRegistrationBean;&#125; excludes用于配置不需要参数过滤的请求url isIncludeRichText默认为true，主要用于设置富文本（项目内约束以content为名或以WithHtml结尾）内容是否需要过滤，该选项可根据公司具体情况调整，建议约束富文本编辑框支持的标签并开启改约束，减少安全隐患 小结防御XSS攻击，可以通过后端统一进行标签过滤，去掉所有输入内容中包含的类似于&lt;script&gt;这样的非法标签来实现。 标签过滤实现可使用Jsoup，功能强大，使用方便，更多内容可参考Jsoup 防止富文本 XSS 攻击； 继承HttpServletRequestWrapper，重写从request内获取参数的方法，在其内调用JsoupUtil的方法，进行参数脱敏处理； 通过XssFilter将XssHttpServletRequestWrapper设置入处理链中，从而达到后续处理类内通过Request获取参数时调用的是重写后的获取参数的方法，进而达成业务代码无感知的实现了XSS过滤的目的。","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"XSS","slug":"XSS","permalink":"http://www.onecoderspace.com/tags/XSS/"}]},{"title":"spring boot实战之shiro session过期时间","slug":"spring-boot-shiro-session","date":"2017-10-06T00:12:01.000Z","updated":"2017-10-06T00:21:35.000Z","comments":true,"path":"2017/10/06/spring-boot-shiro-session/","link":"","permalink":"http://www.onecoderspace.com/2017/10/06/spring-boot-shiro-session/","excerpt":"在spring boot内，设置session过期时间只需在application.properties内添加server.session.timeout配置即可。在整合shiro时发现，server.session.timeout设置为7200，但未到2小时就需要重新登录，后来发现是shiro的session已经过期了，shiro的session过期时间并不和server.session.timeout一致，目前是采用filter的方式来进行设置。","text":"在spring boot内，设置session过期时间只需在application.properties内添加server.session.timeout配置即可。在整合shiro时发现，server.session.timeout设置为7200，但未到2小时就需要重新登录，后来发现是shiro的session已经过期了，shiro的session过期时间并不和server.session.timeout一致，目前是采用filter的方式来进行设置。 ShiroSessionFilter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 通过拦截器设置shiroSession过期时间 * @author yangwk */ public class ShiroSessionFilter implements Filter &#123; private static Logger logger = LoggerFactory.getLogger(ShiroSessionFilter.class); public List&lt;String&gt; excludes = new ArrayList&lt;String&gt;(); private long serverSessionTimeout = 180000L;//ms public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException,ServletException &#123; if(logger.isDebugEnabled())&#123; logger.debug(\"shiro session filter is open\"); &#125; HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; if(handleExcludeURL(req, resp))&#123; filterChain.doFilter(request, response); return; &#125; Subject currentUser = SecurityUtils.getSubject(); if(currentUser.isAuthenticated())&#123; currentUser.getSession().setTimeout(serverSessionTimeout); &#125; filterChain.doFilter(request, response); &#125; private boolean handleExcludeURL(HttpServletRequest request, HttpServletResponse response) &#123; if (excludes == null || excludes.isEmpty()) &#123; return false; &#125; String url = request.getServletPath(); for (String pattern : excludes) &#123; Pattern p = Pattern.compile(\"^\" + pattern); Matcher m = p.matcher(url); if (m.find()) &#123; return true; &#125; &#125; return false; &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; if(logger.isDebugEnabled())&#123; logger.debug(\"shiro session filter init~~~~~~~~~~~~\"); &#125; String temp = filterConfig.getInitParameter(\"excludes\"); if (temp != null) &#123; String[] url = temp.split(\",\"); for (int i = 0; url != null &amp;&amp; i &lt; url.length; i++) &#123; excludes.add(url[i]); &#125; &#125; String timeout = filterConfig.getInitParameter(\"serverSessionTimeout\"); if(StringUtils.isNotBlank(timeout))&#123; this.serverSessionTimeout = NumberUtils.toLong(timeout,1800L)*1000L; &#125; &#125; @Override public void destroy() &#123;&#125; &#125; 注册filter在被@Configuration注解标注的类内注册ShiroSessionFilter。1234567891011121314151617@Value(\"$&#123;server.session.timeout&#125;\")private String serverSessionTimeout;@Beanpublic FilterRegistrationBean shiroSessionFilterRegistrationBean() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new ShiroSessionFilter()); filterRegistrationBean.setOrder(FilterRegistrationBean.LOWEST_PRECEDENCE); filterRegistrationBean.setEnabled(true); filterRegistrationBean.addUrlPatterns(\"/*\"); Map&lt;String, String&gt; initParameters = Maps.newHashMap(); initParameters.put(\"serverSessionTimeout\", serverSessionTimeout); initParameters.put(\"excludes\", \"/favicon.ico,/img/*,/js/*,/css/*\"); filterRegistrationBean.setInitParameters(initParameters); return filterRegistrationBean;&#125; 这样当每次请求时，如果用户已登录，就重新设置shiro session有效期，从而和server session保持了一致。","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"shiro session过期时间","slug":"shiro-session过期时间","permalink":"http://www.onecoderspace.com/tags/shiro-session过期时间/"}]},{"title":"spring boot项目实战：分布式锁","slug":"spring-boot-distributed-lock","date":"2017-10-04T01:03:32.000Z","updated":"2017-10-04T11:31:41.000Z","comments":true,"path":"2017/10/04/spring-boot-distributed-lock/","link":"","permalink":"http://www.onecoderspace.com/2017/10/04/spring-boot-distributed-lock/","excerpt":"在部分情况下，要保证操作在整个集群内是同步的，以操作库存为例，多个减操作需要同步，常见的有两种方式： 采用类CAS的方式，先查询库存，然后使用update xxx set num=num-1 where num=:num;这样可保证库在本次修改之前未被修改； 使用分布式锁，保证同时只有一个地方在修改库存。","text":"在部分情况下，要保证操作在整个集群内是同步的，以操作库存为例，多个减操作需要同步，常见的有两种方式： 采用类CAS的方式，先查询库存，然后使用update xxx set num=num-1 where num=:num;这样可保证库在本次修改之前未被修改； 使用分布式锁，保证同时只有一个地方在修改库存。 这里向大家展示一个基于redis的分布式锁。主要涉及三个类： DistributedLockUtil对外提供获取分布式锁的方法； DistributedLock 分布式锁接口，定义分布式锁支持的方法，主要有acquire和release； JedisLock实现DistributedLock接口，是基于redis的分布锁实现 ； 需要使用StringRedisTemplate，如对spring boot整合redis不熟悉，请参考spring boot项目实战：redis. DistributedLock接口123456789101112131415161718192021public interface DistributedLock &#123; /** * 获取锁 * @author yangwenkui * @time 2016年5月6日 上午11:02:54 * @return * @throws InterruptedException */ public boolean acquire(); /** * 释放锁 * @author yangwenkui * @time 2016年5月6日 上午11:02:59 */ public void release(); &#125; JedisLock基于redis的分布式锁实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public class JedisLock implements DistributedLock&#123; private static Logger logger = LoggerFactory.getLogger(JedisLock.class); private static StringRedisTemplate redisTemplate; /** * 分布式锁的键值 */ String lockKey; //锁的键值 int expireMsecs = 10 * 1000; //锁超时，防止线程在入锁以后，无限的执行等待 int timeoutMsecs = 10 * 1000; //锁等待，防止线程饥饿 boolean locked = false; //是否已经获取锁 /** * 获取指定键值的锁 * @param lockKey 锁的键值 */ public JedisLock(String lockKey) &#123; this.lockKey = lockKey; &#125; /** * 获取指定键值的锁,同时设置获取锁超时时间 * @param lockKey 锁的键值 * @param timeoutMsecs 获取锁超时时间 */ public JedisLock(String lockKey, int timeoutMsecs) &#123; this.lockKey = lockKey; this.timeoutMsecs = timeoutMsecs; &#125; /** * 获取指定键值的锁,同时设置获取锁超时时间和锁过期时间 * @param lockKey 锁的键值 * @param timeoutMsecs 获取锁超时时间 * @param expireMsecs 锁失效时间 */ public JedisLock(String lockKey, int timeoutMsecs, int expireMsecs) &#123; this.lockKey = lockKey; this.timeoutMsecs = timeoutMsecs; this.expireMsecs = expireMsecs; &#125; public String getLockKey() &#123; return lockKey; &#125; /** * * @return true if lock is acquired, false acquire timeouted * @throws InterruptedException * in case of thread interruption */ public synchronized boolean acquire() &#123; int timeout = timeoutMsecs; if(redisTemplate == null)&#123; redisTemplate = SpringContextUtil.getBean(StringRedisTemplate.class); &#125; try &#123; while (timeout &gt;= 0) &#123; long expires = System.currentTimeMillis() + expireMsecs + 1; String expiresStr = String.valueOf(expires); //锁到期时间 if (redisTemplate.opsForValue().setIfAbsent(lockKey, expiresStr)) &#123; // lock acquired locked = true; return true; &#125; String currentValueStr = redisTemplate.opsForValue().get(lockKey); //redis里的时间 if (currentValueStr != null &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123; //判断是否为空，不为空的情况下，如果被其他线程设置了值，则第二个条件判断是过不去的 // lock is expired String oldValueStr = redisTemplate.opsForValue().getAndSet(lockKey, expiresStr); //获取上一个锁到期时间，并设置现在的锁到期时间， //只有一个线程才能获取上一个线上的设置时间，因为jedis.getSet是同步的 if (oldValueStr != null &amp;&amp; oldValueStr.equals(currentValueStr)) &#123; //如过这个时候，多个线程恰好都到了这里，但是只有一个线程的设置值和当前值相同，他才有权利获取锁 // lock acquired locked = true; return true; &#125; &#125; timeout -= 100; Thread.sleep(100); &#125; &#125; catch (Exception e) &#123; logger.error(\"release lock due to error\",e); &#125; return false; &#125; /** * 释放锁 */ public synchronized void release() &#123; if(redisTemplate == null)&#123; redisTemplate = SpringContextUtil.getBean(StringRedisTemplate.class); &#125; try &#123; if (locked) &#123; String currentValueStr = redisTemplate.opsForValue().get(lockKey); //redis里的时间 //校验是否超过有效期，如果不在有效期内，那说明当前锁已经失效，不能进行删除锁操作 if (currentValueStr != null &amp;&amp; Long.parseLong(currentValueStr) &gt; System.currentTimeMillis()) &#123; redisTemplate.delete(lockKey); locked = false; &#125; &#125; &#125; catch (Exception e) &#123; logger.error(\"release lock due to error\",e); &#125; &#125;&#125; DistributedLockUtil1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class DistributedLockUtil&#123; /** * 获取分布式锁 * 默认获取锁10s超时，锁过期时间60s * @author yangwenkui * @time 2016年5月6日 下午1:30:46 * @return */ public static DistributedLock getDistributedLock(String lockKey)&#123; lockKey = assembleKey(lockKey); JedisLock lock = new JedisLock(lockKey); return lock; &#125; /** * 正式环境、测试环境共用一个redis时，避免key相同造成影响 * @author yangwenkui * @param lockKey * @return */ private static String assembleKey(String lockKey) &#123; return String.format(\"lock_%s\",lockKey ); &#125; /** * 获取分布式锁 * 默认获取锁10s超时，锁过期时间60s * @author yangwenkui * @time 2016年5月6日 下午1:38:32 * @param lockKey * @param timeoutMsecs 指定获取锁超时时间 * @return */ public static DistributedLock getDistributedLock(String lockKey,int timeoutMsecs)&#123; lockKey = assembleKey(lockKey); JedisLock lock = new JedisLock(lockKey,timeoutMsecs); return lock; &#125; /** * 获取分布式锁 * 默认获取锁10s超时，锁过期时间60s * @author yangwenkui * @time 2016年5月6日 下午1:40:04 * @param lockKey 锁的key * @param timeoutMsecs 指定获取锁超时时间 * @param expireMsecs 指定锁过期时间 * @return */ public static DistributedLock getDistributedLock(String lockKey,int timeoutMsecs,int expireMsecs)&#123; lockKey = assembleKey(lockKey); JedisLock lock = new JedisLock(lockKey,expireMsecs,timeoutMsecs); return lock; &#125; &#125; 使用示例123456789101112DistributedLock lock = DistributedLockUtil.getDistributedLock(key);try &#123; if (lock.acquire()) &#123; //获取锁成功业务代码 &#125; else &#123; // 获取锁失败 //获取锁失败业务代码&#125; finally &#123; if (lock != null) &#123; lock.release(); &#125;&#125; 实现原理简析主要是依赖redis的setnx和getset命令对时间进行操作，从而实现锁的功能。以下两个文章对分布式锁进行了极其明细的分析，会让你对分布式锁的认识更加清晰。《基于Redis的分布式锁到底安全吗（上）？》《基于Redis的分布式锁到底安全吗（下）？》 注意事项 基于redis的分布式锁依赖于系统时钟，需要保证各个竞争者的时钟的一致性，否则会出现一个参与者获得锁，而另一个参与者的时钟判断其已过期，导致分布式锁失效； 需要保证redis节点的高可用，建议使用哨兵机制； 在使用分布式锁之前，考虑是否可以通过乐观锁或无锁解决并发同步问题，毕竟使用锁的代价很是比较高昂的；","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"分布式锁，redis","slug":"分布式锁，redis","permalink":"http://www.onecoderspace.com/tags/分布式锁，redis/"}]},{"title":"spring boot项目实战：JPA","slug":"spring-boot-jpa","date":"2017-10-03T05:45:38.000Z","updated":"2017-10-03T13:46:28.000Z","comments":true,"path":"2017/10/03/spring-boot-jpa/","link":"","permalink":"http://www.onecoderspace.com/2017/10/03/spring-boot-jpa/","excerpt":"公司的项目中很大一部分属于内部平台，所以对性能的要求没有那么高，开发速度反而更重要，因此在搭建基础框架时选择使用JPA，没有使用mybitis，当然其中也有一部分原因是之前一直使用hibernate，对mybitis不太熟悉^_^。","text":"公司的项目中很大一部分属于内部平台，所以对性能的要求没有那么高，开发速度反而更重要，因此在搭建基础框架时选择使用JPA，没有使用mybitis，当然其中也有一部分原因是之前一直使用hibernate，对mybitis不太熟悉^_^。 一、配置JPA1、添加maven依赖123456789101112&lt;!-- jpa --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 2、 添加数据库配置12345678910111213141516171819spring.jpa.database = MYSQL# Hibernate ddl auto (create, create-drop, update)spring.jpa.hibernate.ddl-auto = update# Naming strategyspring.jpa.hibernate.naming-strategy = org.hibernate.cfg.ImprovedNamingStrategy# stripped before adding them to the entity manager)spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect# Show or not log for each sql queryspring.jpa.show-sql = truespring.datasource.url=jdbc:mysql://localhost:3306/base?characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=rootspring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.max-active=3spring.datasource.max-idle=1spring.datasource.min-idle=1spring.datasource.initial-size=1 3、dao继承上层类12345678910public interface UserDao extends BaseDao&lt;User, Integer&gt;&#123; User findByUsernameAndDel(String username, int del);&#125;@NoRepositoryBeanpublic interface BaseDao&lt;T,ID extends Serializable&gt; extends JpaSpecificationExecutor&lt;T&gt;,JpaRepository&lt;T, ID&gt;&#123;&#125;为了便于使用，提取了一个BaseDao，需要注意的是要在上层类上添加@ NoRepositoryBean注解。BaseDao继承JpaRepository和JpaSpecificationExecutor，JpaRepository提供了基本的crud等查询方法，JpaSpecificationExecutor提供了对复杂查询的支持。 完成了以上三步，已经可以在service内注入dao，通过dao进行数据库curd等操作。 二、JPA查询1、 根据方法名实现查询1234567891011//根据用户名和标记删除字段查询对应的用户信息User findByUsernameAndDel(String username, int del);//根据code查询对应的角色Role findByCode(String code);//根据id集合查询对应的角色集合Set&lt;Role&gt; findByIdIn(Set&lt;Integer&gt; roleIds);//根据用户id，查询用户角色关系记录List&lt;UserRole&gt; findByUserId(int uid); 简单查询可以通过以上方式方便的实现，简化了很多dao层的代码，使用着还是很爽的，具体规则比较简单，基本上就是findBy开始，后续跟上实体属性，中间配以And、Or、In、like等组成方法名，也就是用方法名来描述查询规则。如果是嵌套对象，可以通过“_”来区分子对象的属性，比如findByCompany_name(String name)就是以子对象company内的name属性为查询条件。常用查询关键字如下： And — 等价于 SQL 中的 and 关键字，比如findByUsernameAndPassword(String user, Striang pwd)； Or — 等价于 SQL 中的 or 关键字，比如findByUsernameOrAddress(String user, String addr)； Between — 等价于 SQL 中的 between 关键字，比如 findBySalaryBetween(int max, int min)； LessThan — 等价于 SQL 中的 “&lt;”，比如 findBySalaryLessThan(int max)； GreaterThan — 等价于 SQL 中的”&gt;”，比如 findBySalaryGreaterThan(int min)； IsNull — 等价于 SQL 中的 “is null”，比如 findByUsernameIsNull()； IsNotNull — 等价于 SQL 中的 “is not null”，比如 findByUsernameIsNotNull()； NotNull — 与 IsNotNull 等价； Like — 等价于 SQL 中的 “like”，比如 findByUsernameLike(String user)； NotLike — 等价于 SQL 中的 “not like”，比如 findByUsernameNotLike(String user)； OrderBy — 等价于 SQL 中的 “order by”，比如 findByUsernameOrderBySalaryAsc(String user)； Not — 等价于 SQL 中的 “！ =”，比如 findByUsernameNot(String user)； In — 等价于 SQL 中的 “in”，比如findByUsernameIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数； NotIn — 等价于 SQL 中的 “not in”，比如 findByUsernameNotIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数； 2、使用@Query查询类HQL语句1234@Query(\"select u from User u where u.username = ?1\") public AccountInfo findByAccountId(String username); 在@Query内直接书写HQL语句即可，参数可通过”?1,?2”这样的方式设置，下标从1开始。 原生sql查询123456789@Query(value=\"select perm.* from role_permission rp left join permission perm on rp.permission_id=perm.id where rp.role_id in(?1);\",nativeQuery=true)List&lt;Permission&gt; listByRoleIds(Set&lt;Integer&gt; roles);//根据userId删除用户角色关系@Query(value = \"delete from user_role where user_id=?1 \", nativeQuery = true) @Modifyingvoid deleleByUserId(int uid);使用也比较简单，将@Query内的nativeQuery设置为true即可。写SQL语句时，可以现在本地mysql客户端上测试号SQL语句的正确性，当需要索引时，创建合适的索引。在此基础上看下SQL的性能，如不理想，需调整SQL，可使用explain对SQL语句进行分析，查询执行逻辑，针对性优化。 新增、修改直接调用dao的save方法，支持单个保存和批量保存。 删除直接调用dao的delete方法，支持根据id、对象、对象集合等删除方式，使用时查看下提示方法就可以了。 3、分页查询不带条件分页查询123Pageable pageable = new PageRequest(0, 10, new Sort(Direction.DESC, \"updateTime\"));Page&lt;User&gt; page = userDao.findAll(pageable); 使用PageRequest构建分页请求对象，页码下标从0开始 多条件复杂分页查询带条件分页查询有两种方式： 使用原生SQL进行分页查询，但是前提是多个查询条件必须同时存在，不能有不生效的条件，比如用户列表，用户姓名可以不作为过滤条件，这种情况原生SQL就不适用了，需要使用下面第二种方式 使用Specification进行复杂查询，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public Page&lt;User&gt; listByPage(final Map&lt;String, String&gt; params,Pageable pageable)&#123; Specification&lt;User&gt; spec = new Specification&lt;User&gt;() &#123; @Override public Predicate toPredicate(Root&lt;User&gt; root,CriteriaQuery&lt;?&gt; query,CriteriaBuilder cb) &#123; List&lt;Predicate&gt; list = new ArrayList&lt;Predicate&gt;(); String type = params.get(\"type\"); String status= params.get(\"status\"); String username = params.get(\"username\"); String name = params.get(\"name\"); if(StringUtils.isNotBlank(type))&#123; list.add(cb.equal(root.get(\"type\").as(Integer.class), NumberUtils.toInt(type))); &#125; if(StringUtils.isNotBlank(status))&#123; list.add(cb.equal(root.get(\"status\").as(Integer.class), NumberUtils.toInt(status))); &#125; if(StringUtils.isNotBlank(username))&#123; list.add(cb.like(root.get(\"username\").as(String.class), String.format(\"%%%s%%\", username))); &#125; if(StringUtils.isNotBlank(name))&#123; list.add(cb.like(root.get(\"name\").as(String.class), String.format(\"%%%s%%\", name))); &#125; list.add(cb.equal(root.get(\"del\"), Constants.DEL_NO)); Predicate[] p = new Predicate[list.size()]; return cb.and(list.toArray(p)); //in条件查询 /*List&lt;Integer&gt; ids = Lists.newArrayList(); ids.add(1); ids.add(2); In&lt;Integer&gt; in = cb.in(root.get(\"id\").as(Integer.class)); in.value(1); in.value(2); return cb.or(in);*/ &#125; &#125;; Page&lt;User&gt; page = userDao.findAll(spec, pageable); 根据以上示例，基本满足了常用的查询需求，更多情况可根据规则尝试一下即可，也可百度搜索下JPA Specification，有很多教程。 简化多条件分页查询使用Specification需要每次都写一大段模板代码，使用起来还是比较繁琐，使用入门也有些难度，基于此，在service层的公共代码出对查询进行了部分封装，简化常见多条件分页查询。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174/** * 分页多条件查询 * 注：多个条件间是and关系 &amp; 参数是属性对应的类型 * @author yangwk * @time 2017年8月1日 下午3:50:46 * @param params &#123;\"username:like\":\"test\"&#125; 键的格式为字段名:过滤方式,过滤方式见&#123;@code QueryTypeEnum&#125; * @param pageable 分页信息 new PageRequest(page, size,new Sort(Direction.DESC, \"updateTime\")) * @return */Page&lt;T&gt; list(Map&lt;String, Object&gt; params,Pageable pageable);@Overridepublic Page&lt;T&gt; list(final Map&lt;String, Object&gt; params,Pageable pageable)&#123; Specification&lt;T&gt; spec = new Specification&lt;T&gt;() &#123; @Override public Predicate toPredicate(Root&lt;T&gt; root,CriteriaQuery&lt;?&gt; query,CriteriaBuilder cb) &#123; List&lt;Predicate&gt; list = new ArrayList&lt;Predicate&gt;(); for(Entry&lt;String, Object&gt; entry : params.entrySet())&#123; Object value = entry.getValue(); if(value == null || StringUtils.isBlank(value.toString()))&#123; continue; &#125; String key = entry.getKey(); String[] arr = key.split(\":\"); Predicate predicate = getPredicate(arr,value,root,cb); list.add(predicate); &#125; Predicate[] p = new Predicate[list.size()]; return cb.and(list.toArray(p)); &#125; &#125;; Page&lt;T&gt; page = getDAO().findAll(spec, pageable); return page;&#125;private Predicate getPredicate(String[] arr, Object value, Root&lt;T&gt; root, CriteriaBuilder cb) &#123; if(arr.length == 1)&#123; return cb.equal(root.get(arr[0]).as(value.getClass()), value); &#125; if(QueryTypeEnum.like.name().equals(arr[1]))&#123; return cb.like(root.get(arr[0]).as(String.class), String.format(\"%%%s%%\", value)); &#125; if(QueryTypeEnum.ne.name().equals(arr[1]))&#123; return cb.notEqual(root.get(arr[0]).as(value.getClass()), value); &#125; if(QueryTypeEnum.lt.name().equals(arr[1]))&#123; return getLessThanPredicate(arr,value,root,cb); &#125; if(QueryTypeEnum.lte.name().equals(arr[1]))&#123; return getLessThanOrEqualToPredicate(arr,value,root,cb); &#125; if(QueryTypeEnum.gt.name().equals(arr[1]))&#123; return getGreaterThanPredicate(arr,value,root,cb); &#125; if(QueryTypeEnum.gte.name().equals(arr[1]))&#123; return getGreaterThanOrEqualToPredicate(arr,value,root,cb); &#125; throw new UnsupportedOperationException(String.format(\"不支持的查询类型[%s]\",arr[1]));&#125;private Predicate getLessThanPredicate(String[] arr, Object value, Root&lt;T&gt; root, CriteriaBuilder cb) &#123; if(Integer.class == value.getClass())&#123; return cb.lessThan(root.get(arr[0]).as(Integer.class), (int)value); &#125; if(Long.class == value.getClass())&#123; return cb.lessThan(root.get(arr[0]).as(Long.class), (long)value); &#125; if(Double.class == value.getClass())&#123; return cb.lessThan(root.get(arr[0]).as(Double.class), (double)value); &#125; if(Float.class == value.getClass())&#123; return cb.lessThan(root.get(arr[0]).as(Float.class), (float)value); &#125; if(Timestamp.class == value.getClass())&#123; return cb.lessThan(root.get(arr[0]).as(Timestamp.class), (Timestamp)value); &#125; if(Date.class == value.getClass())&#123; return cb.lessThan(root.get(arr[0]).as(Date.class), (Date)value); &#125; return cb.lessThan(root.get(arr[0]).as(String.class), String.valueOf(value));&#125;private Predicate getLessThanOrEqualToPredicate(String[] arr, Object value, Root&lt;T&gt; root, CriteriaBuilder cb) &#123; if(Integer.class == value.getClass())&#123; return cb.lessThanOrEqualTo(root.get(arr[0]).as(Integer.class), (int)value); &#125; if(Long.class == value.getClass())&#123; return cb.lessThanOrEqualTo(root.get(arr[0]).as(Long.class), (long)value); &#125; if(Double.class == value.getClass())&#123; return cb.lessThanOrEqualTo(root.get(arr[0]).as(Double.class), (double)value); &#125; if(Float.class == value.getClass())&#123; return cb.lessThanOrEqualTo(root.get(arr[0]).as(Float.class), (float)value); &#125; if(Timestamp.class == value.getClass())&#123; return cb.lessThanOrEqualTo(root.get(arr[0]).as(Timestamp.class), (Timestamp)value); &#125; if(Date.class == value.getClass())&#123; return cb.lessThanOrEqualTo(root.get(arr[0]).as(Date.class), (Date)value); &#125; return cb.lessThanOrEqualTo(root.get(arr[0]).as(String.class), String.valueOf(value));&#125;private Predicate getGreaterThanPredicate(String[] arr, Object value, Root&lt;T&gt; root, CriteriaBuilder cb) &#123; if(Integer.class == value.getClass())&#123; return cb.greaterThan(root.get(arr[0]).as(Integer.class), (int)value); &#125; if(Long.class == value.getClass())&#123; return cb.greaterThan(root.get(arr[0]).as(Long.class), (long)value); &#125; if(Double.class == value.getClass())&#123; return cb.greaterThan(root.get(arr[0]).as(Double.class), (double)value); &#125; if(Float.class == value.getClass())&#123; return cb.greaterThan(root.get(arr[0]).as(Float.class), (float)value); &#125; if(Timestamp.class == value.getClass())&#123; return cb.greaterThan(root.get(arr[0]).as(Timestamp.class), (Timestamp)value); &#125; if(Date.class == value.getClass())&#123; return cb.greaterThan(root.get(arr[0]).as(Date.class), (Date)value); &#125; return cb.greaterThan(root.get(arr[0]).as(String.class), String.valueOf(value));&#125;private Predicate getGreaterThanOrEqualToPredicate(String[] arr,Object value, Root&lt;T&gt; root, CriteriaBuilder cb) &#123; if(Integer.class == value.getClass())&#123; return cb.greaterThanOrEqualTo(root.get(arr[0]).as(Integer.class), (int)value); &#125; if(Long.class == value.getClass())&#123; return cb.greaterThanOrEqualTo(root.get(arr[0]).as(Long.class), (long)value); &#125; if(Double.class == value.getClass())&#123; return cb.greaterThanOrEqualTo(root.get(arr[0]).as(Double.class), (double)value); &#125; if(Float.class == value.getClass())&#123; return cb.greaterThanOrEqualTo(root.get(arr[0]).as(Float.class), (float)value); &#125; if(Timestamp.class == value.getClass())&#123; return cb.greaterThanOrEqualTo(root.get(arr[0]).as(Timestamp.class), (Timestamp)value); &#125; if(Date.class == value.getClass())&#123; return cb.greaterThanOrEqualTo(root.get(arr[0]).as(Date.class), (Date)value); &#125; return cb.lessThanOrEqualTo(root.get(arr[0]).as(String.class), String.valueOf(value));&#125; @ApiModel(value=\"查询条件支持的过滤方式\")public enum QueryTypeEnum &#123; like, equal, ne, lt, lte, gt, gte&#125;//使用示例Map&lt;String, Object&gt; params = Maps.newHashMap();params.put(\"type\", type);params.put(\"status\", status);params.put(\"username:like\", username);params.put(\"name:like\", name);Page&lt;User&gt; rs = this.userService.list(params, new PageRequest(page, size, new Sort(Direction.DESC, \"updateTime\"))); 提前公共list方法，查询条件在map内设置，查询条件在key内设置，这样大部分的查询请求就可以不再关注Specification的语法，不用写那一大段的复杂代码了 小结 配置JPA很简单，添加maven依赖，配置数据库连接信息，dao继承上层类即可在service内注入dao，进行crud等操作 JPA提供了简便的根据方法名称进行查询的方式，使用难度很低 JPA通过@Query注解，支持类HQL语句查询；也可以使用原生SQL查询，只需要将nativeQuery属性设置为true即可 无条件分页查询可通过自带的findAll方法即可 多条件分页查询，有两种实现方式，当每个条件都是必选时，可使用@query带分页条件来实现；当有可选条件时，需要使用Specification来实现 为了简化常见的多个可选条件分页查询的代码，在service层提供了一个上层方法，以map的方式设置查询条件，大部分情况下不需要程序员再关注Specification的语法，降低使用难度 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"JPA","slug":"JPA","permalink":"http://www.onecoderspace.com/tags/JPA/"}]},{"title":"git最简教程","slug":"git-simple","date":"2017-10-03T03:11:35.000Z","updated":"2017-10-03T13:50:24.000Z","comments":true,"path":"2017/10/03/git-simple/","link":"","permalink":"http://www.onecoderspace.com/2017/10/03/git-simple/","excerpt":"git新手，最近上传个项目，下载个项目老是忘记命令，在这写一下最常用的几个命令。","text":"git新手，最近上传个项目，下载个项目老是忘记命令，在这写一下最常用的几个命令。 本地新建文件夹，如rest-base cd rest-base git init //初始化仓库 git remote add origin git@github.com:q7322068/rest-base.git //连接远程仓库，需要在github内创建ssh公钥，配置方式参考GitHub添加公钥 如果配置远程仓库的地址错误，可以使用git remote rm origin git pull origin master //从远程库同步项目，如果远程项目和本地有冲突，可以在后面添加 –allow-unrelated-histories实现 git add . //本地有修改，用该命令添加至暂存区 git commit -m ‘msg’ //将修改提交至本地git仓库 git push origin master //将本地修改提交至远程仓库 深入学习建议看廖雪峰Git教程.","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://www.onecoderspace.com/tags/git/"}]},{"title":"spring-boot项目实战：shiro","slug":"spring-boot-shiro","date":"2017-10-02T05:31:52.000Z","updated":"2017-10-04T11:42:12.000Z","comments":true,"path":"2017/10/02/spring-boot-shiro/","link":"","permalink":"http://www.onecoderspace.com/2017/10/02/spring-boot-shiro/","excerpt":"有很长一段时间都觉得自己添加个filter，基于RBAC模型，就能很轻松的实现权限控制，没必要引入shiro，spring-security这样的框架增加系统的复杂度。事实上也的确这样，如果你的需求仅仅是控制用户能否访问某个url，使用框架和自己实现filter效果基本一致，区别在于使用shiro和spring-security能够提供更多的扩展，集成了很多实用的功能，整体结构更加规范。","text":"有很长一段时间都觉得自己添加个filter，基于RBAC模型，就能很轻松的实现权限控制，没必要引入shiro，spring-security这样的框架增加系统的复杂度。事实上也的确这样，如果你的需求仅仅是控制用户能否访问某个url，使用框架和自己实现filter效果基本一致，区别在于使用shiro和spring-security能够提供更多的扩展，集成了很多实用的功能，整体结构更加规范。shiro和spring-security有哪些更多功能，这里不再展开，感兴趣的同学可以自行百度，我们这里以shiro为例，讲述spring-boot项目如何整合shiro实现权限控制。 1、添加maven依赖12345678910111213141516171819202122232425&lt;!--shiro-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; &lt;!-- 整合ehcache，减少数据库查询次数 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 2、添加shiro配置创建ShiroConfigration.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128@Configurationpublic class ShiroConfigration &#123; private static final Logger logger = LoggerFactory.getLogger(ShiroConfigration.class); private static Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;(); @Bean public SimpleCookie rememberMeCookie() &#123; SimpleCookie simpleCookie = new SimpleCookie(\"rememberMe\"); simpleCookie.setMaxAge(7 * 24 * 60 * 60);//保存10天 return simpleCookie; &#125; /** * cookie管理对象; */ @Bean public CookieRememberMeManager rememberMeManager() &#123; logger.debug(\"ShiroConfiguration.rememberMeManager()\"); CookieRememberMeManager cookieRememberMeManager = new CookieRememberMeManager(); cookieRememberMeManager.setCookie(rememberMeCookie()); cookieRememberMeManager.setCipherKey(Base64.decode(\"kPv59vyqzj00x11LXJZTjJ2UHW48jzHN\")); return cookieRememberMeManager; &#125; @Bean(name = \"lifecycleBeanPostProcessor\") public LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() &#123; return new LifecycleBeanPostProcessor(); &#125; @Bean public FilterRegistrationBean filterRegistrationBean() &#123; FilterRegistrationBean filterRegistration = new FilterRegistrationBean(); DelegatingFilterProxy proxy = new DelegatingFilterProxy(\"shiroFilter\"); // 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理 proxy.setTargetFilterLifecycle(true); filterRegistration.setFilter(proxy); filterRegistration.setEnabled(true); //filterRegistration.addUrlPatterns(\"/*\");// 可以自己灵活的定义很多，避免一些根本不需要被Shiro处理的请求被包含进来 return filterRegistration; &#125; @Bean public MyShiroRealm myShiroRealm() &#123; MyShiroRealm myShiroRealm = new MyShiroRealm(); return myShiroRealm; &#125; @Bean(name=\"securityManager\") public DefaultWebSecurityManager securityManager() &#123; DefaultWebSecurityManager manager = new DefaultWebSecurityManager(); manager.setRealm(myShiroRealm()); manager.setRememberMeManager(rememberMeManager()); manager.setCacheManager(ehCacheManager()); return manager; &#125; /** * ShiroFilterFactoryBean 处理拦截资源文件问题。 * 注意：单独一个ShiroFilterFactoryBean配置是或报错的，以为在 * 初始化ShiroFilterFactoryBean的时候需要注入：SecurityManager * &lt;p&gt; * Filter Chain定义说明 * 1、一个URL可以配置多个Filter，使用逗号分隔 * 2、当设置多个过滤器时，全部验证通过，才视为通过 * 3、部分过滤器可指定参数，如perms，roles */ @Bean(name = \"shiroFilter\") public ShiroFilterFactoryBean getShiroFilterFactoryBean() &#123; logger.debug(\"ShiroConfigration.getShiroFilterFactoryBean()\"); ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 必须设置 SecurityManager shiroFilterFactoryBean.setSecurityManager(securityManager()); HashMap&lt;String, javax.servlet.Filter&gt; loginFilter = new HashMap&lt;&gt;(); loginFilter.put(\"loginFilter\", new LoginFilter()); shiroFilterFactoryBean.setFilters(loginFilter); filterChainDefinitionMap.put(\"/login/submit\", \"anon\"); filterChainDefinitionMap.put(\"/logout\", \"anon\"); filterChainDefinitionMap.put(\"/img/**\", \"anon\"); filterChainDefinitionMap.put(\"/js/**\", \"anon\"); filterChainDefinitionMap.put(\"/css/**\", \"anon\"); filterChainDefinitionMap.put(\"/test/**\", \"anon\"); // 如果不设置默认会自动寻找Web工程根目录下的\"/login.jsp\"页面 shiroFilterFactoryBean.setLoginUrl(\"/login\"); //配置记住我或认证通过可以访问的地址 filterChainDefinitionMap.put(\"/\", \"user\"); //未授权界面; shiroFilterFactoryBean.setUnauthorizedUrl(\"/unauth\"); filterChainDefinitionMap.put(\"/**\", \"loginFilter\"); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return shiroFilterFactoryBean; &#125; /** * shiro缓存管理器; * 需要注入对应的其它的实体类中： * 1、安全管理器：securityManager * 可见securityManager是整个shiro的核心； * * @return */ @Bean public EhCacheManager ehCacheManager() &#123; EhCacheManager cacheManager = new EhCacheManager(); cacheManager.setCacheManagerConfigFile(\"classpath:ehcache-shiro.xml\"); return cacheManager; &#125; @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(DefaultWebSecurityManager securityManager) &#123; AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; &#125;&#125; shiroFilter是配置的重点， anon表示允许匿名访问 shiroFilterFactoryBean.setFilters(loginFilter)来设置自定义的过滤器，如本处设置了LoginFilter用于添加登录拦截 filterChainDefinitionMap.put(“/**”, “loginFilter”);用于指定loginFilter的作用范围 3、添加自定义realm创建类MyShiroRealm.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class MyShiroRealm extends AuthorizingRealm &#123; private static final Logger logger = LoggerFactory.getLogger(MyShiroRealm.class); @Autowired private UserService userService; @Autowired private UserRoleService userRoleService; @Autowired private RoleService roleService; @Autowired private RolePermissionService rolePermissionService; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //获取用户的输入的账号. String idObj = (String) token.getPrincipal(); Integer id = NumberUtils.toInt(idObj); User user = userService.findById(id); if (user == null) &#123; // 返回null的话，就会导致任何用户访问被拦截的请求时，都会自动跳转到unauthorizedUrl指定的地址 return null; &#125; SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(user.getId(), user.getPwd(), getName()); return authenticationInfo; &#125; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; /* * 当没有使用缓存的时候，不断刷新页面的话，这个代码会不断执行， * 当其实没有必要每次都重新设置权限信息，所以我们需要放到缓存中进行管理； * 当放到缓存中时，这样的话，doGetAuthorizationInfo就只会执行一次了， * 缓存过期之后会再次执行。 */ logger.debug(\"权限配置--&gt;MyShiroRealm.doGetAuthorizationInfo()\"); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); authorizationInfo.addRole(\"ACTUATOR\"); Integer userId = Integer.parseInt(principals.getPrimaryPrincipal().toString()); //实际项目中，这里可以根据实际情况做缓存，如果不做，Shiro自己也是有时间间隔机制，2分钟内不会重复执行该方法 Set&lt;Integer&gt; roleIds = userRoleService.findRoleIds(userId); Set&lt;Role&gt; roles = roleService.findByIds(roleIds); for(Role role : roles)&#123; authorizationInfo.addRole(role.getCode()); &#125; //设置权限信息. List&lt;Permission&gt; permissions = rolePermissionService.getPermissions(roleIds); Set&lt;String&gt; set = new HashSet&lt;String&gt;(permissions.size()*2); for(Permission permission : permissions)&#123; if(StringUtils.isNotBlank(permission.getCode()))&#123; set.add(permission.getCode()); &#125; &#125; authorizationInfo.setStringPermissions(set); return authorizationInfo; &#125;&#125; doGetAuthenticationInfo用于验证用户账号信息，可根据具体业务来调整认证策略 doGetAuthorizationInfo用于获取用户拥有的角色和权限 4、创建登录拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class LoginFilter implements Filter &#123; @Override public void destroy() &#123;&#125; @Override public void doFilter(ServletRequest request, ServletResponse response,FilterChain chain) throws IOException, ServletException &#123; Subject currentUser = SecurityUtils.getSubject(); if (!currentUser.isAuthenticated()) &#123; HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse res = (HttpServletResponse) response; AjaxResponseWriter.write(req, res, ServiceStatusEnum.UNLOGIN, \"请登录\"); return; &#125; chain.doFilter(request, response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123;&#125;&#125;public class AjaxResponseWriter &#123; /** * 写回数据到前端 * @param request * @param response * @param status &#123;@link ServiceStatusEnum&#125; * @param message 返回的描述信息 * @throws IOException */ public static void write(HttpServletRequest request,HttpServletResponse response,ServiceStatusEnum status,String message) throws IOException&#123; String contentType = \"application/json\"; response.setContentType(contentType); response.setCharacterEncoding(\"UTF-8\"); response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); response.setHeader(\"Access-Control-Allow-Origin\",request.getHeader(\"Origin\")); Map&lt;String, String&gt; map = Maps.newLinkedHashMap(); map.put(\"code\", status.code); map.put(\"msg\", message); String result = JacksonHelper.toJson(map); PrintWriter out = response.getWriter(); try&#123; out.print(result); out.flush(); &#125; finally &#123; out.close(); &#125; &#125;&#125;/** * 全局性状态码 * @author yangwk */public enum ServiceStatusEnum &#123; UNLOGIN(\"0001\"), //未登录 ILLEGAL_TOKEN(\"0002\"),//非法的token ; public String code; private ServiceStatusEnum(String code)&#123; this.code = code; &#125;&#125; 用户登录状态拦截器，不允许匿名访问的url会经过该filter，如果未登录，则返回未登录提示（未登录处理可根据具体业务进行调整） 5、添加登录、退出功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109@Api(value=\"用户登录\",tags=&#123;\"用户登录\"&#125;)@RestControllerpublic class LoginController &#123; private static Logger logger = LoggerFactory.getLogger(LoginController.class); @Value(\"$&#123;server.session.timeout&#125;\") private String serverSessionTimeout; /** * 用户登录接口 通过用户名和密码进行登录 */ @ApiOperation(value = \"用户登录接口 通过用户名和密码进行登录\", notes = \"用户登录接口 通过用户名和密码进行登录\") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = \"query\", name = \"username\", value = \"用户名\", required = true, dataType = \"String\"), @ApiImplicitParam(paramType = \"query\", name = \"pwd\", value = \"密码\", required = true, dataType = \"String\"), @ApiImplicitParam(paramType = \"query\", name = \"autoLogin\", value = \"自动登录\", required = true, dataType = \"boolean\")&#125;) @RequestMapping(value = \"/login/submit\",method=&#123;RequestMethod.GET,RequestMethod.POST&#125;) public Map&lt;String, String&gt; subm(HttpServletRequest request,HttpServletResponse response, String username,String pwd,@RequestParam(value = \"autoLogin\", defaultValue = \"false\") boolean autoLogin) &#123; Map&lt;String, String&gt; map = Maps.newLinkedHashMap(); Subject currentUser = SecurityUtils.getSubject(); User user = userService.findByUsername(username); if (user == null) &#123; map.put(\"code\", \"-1\"); map.put(\"description\", \"账号不存在\"); return map; &#125; if (user.getEnable() == 0) &#123; //账号被禁用 map.put(\"code\", \"-1\"); map.put(\"description\", \"账号已被禁用\"); return map; &#125; String salt = user.getSalt(); UsernamePasswordToken token = null; Integer userId = user.getId(); token = new UsernamePasswordToken(userId.toString(),SaltMD5Util.encode(pwd, salt)); token.setRememberMe(autoLogin); loginValid(map, currentUser, token); // 验证是否登录成功 if (currentUser.isAuthenticated()) &#123; map.put(\"code\",\"1\"); map.put(\"description\", \"ok\"); map.put(\"id\", String.valueOf(userId)); map.put(\"username\", user.getUsername()); map.put(\"name\", user.getName()); map.put(\"compnay_id\", String.valueOf(user.getCompanyId())); String uuidToken = UUID.randomUUID().toString(); map.put(\"token\", uuidToken); currentUser.getSession().setTimeout(NumberUtils.toLong(serverSessionTimeout, 1800)*1000); request.getSession().setAttribute(\"token\",uuidToken ); &#125; else &#123; map.put(\"code\", \"-1\"); token.clear(); &#125; return map; &#125; @RequestMapping(value=\"logout\",method=RequestMethod.GET) public Map&lt;String, String&gt; logout() &#123; Map&lt;String, String&gt; map = Maps.newLinkedHashMap(); Subject currentUser = SecurityUtils.getSubject(); currentUser.logout(); map.put(\"code\", \"logout\"); return map; &#125; @RequestMapping(value=\"unauth\",method=RequestMethod.GET) public Map&lt;String, String&gt; unauth() &#123; Map&lt;String, String&gt; map = Maps.newLinkedHashMap(); map.put(\"code\", \"403\"); map.put(\"msg\", \"你没有访问权限\"); return map; &#125; private boolean loginValid(Map&lt;String, String&gt; map,Subject currentUser, UsernamePasswordToken token) &#123; String username = null; if (token != null) &#123; username = (String) token.getPrincipal(); &#125; try &#123; // 在调用了login方法后,SecurityManager会收到AuthenticationToken,并将其发送给已配置的Realm执行必须的认证检查 // 每个Realm都能在必要时对提交的AuthenticationTokens作出反应 // 所以这一步在调用login(token)方法时,它会走到MyRealm.doGetAuthenticationInfo()方法中,具体验证方式详见此方法 currentUser.login(token); return true; &#125; catch (UnknownAccountException | IncorrectCredentialsException ex) &#123; map.put(\"description\", \"账号或密码错误\"); &#125; catch (LockedAccountException lae) &#123; map.put(\"description\",\"账户已锁定\"); &#125; catch (ExcessiveAttemptsException eae) &#123; map.put(\"description\", \"错误次数过多\"); &#125; catch (AuthenticationException ae) &#123; // 通过处理Shiro的运行时AuthenticationException就可以控制用户登录失败或密码错误时的情景 map.put(\"description\", \"登录失败\"); logger.warn(String.format(\"对用户[%s]进行登录验证..验证未通过\", username),ae); &#125; return false; &#125; @Autowired private UserService userService;&#125; 以上代码是比较通用的登录、退出功能，如果没有特殊需求，可直接使用上述功能 6、在接口上添加权限限制以UserController为例：12345678910111213141516171819202122232425262728293031323334@ApiOperation(value=\"获取用户详细信息\", notes=\"根据ID查找用户\") @ApiImplicitParam(paramType=\"query\",name = \"id\", value = \"用户ID\", required = true,dataType=\"int\")@RequiresPermissions(value=&#123;\"user:get\"&#125;) @RequestMapping(value=\"/get\",method=RequestMethod.GET)public User get(int id)&#123; User entity = userService.findById(id); entity.setPwd(null); entity.setSalt(null); return entity;&#125;@ApiOperation(value=\"修改密码\", notes=\"修改密码\")@ApiImplicitParams(&#123; @ApiImplicitParam(paramType = \"query\", name = \"oldPwd\", value = \"旧密码\", required = true, dataType = \"String\"), @ApiImplicitParam(paramType = \"query\", name = \"pwd\", value = \"新密码\", required = true, dataType = \"String\"), @ApiImplicitParam(paramType = \"query\", name = \"confirmPwd\", value = \"新密码(确认)\", required = true, dataType = \"String\")&#125;)@RequiresPermissions(value=&#123;\"user:reset-pwd\"&#125;)@RequestMapping(value=\"/reset-pwd\",method=RequestMethod.POST)public Return resetPwd(String oldPwd,String pwd,String confirmPwd)&#123; if(StringUtils.isBlank(oldPwd) || StringUtils.isBlank(pwd) || StringUtils.isBlank(confirmPwd) || !pwd.equals(confirmPwd)) &#123; return Return.fail(\"非法参数\"); &#125; Subject currentUser = SecurityUtils.getSubject(); Integer userId=(Integer) currentUser.getPrincipal(); User entity = userService.findById(userId); if(!entity.getPwd().equals(SaltMD5Util.encode(oldPwd, entity.getSalt())))&#123; return Return.fail(\"原始密码错误\"); &#125; return userService.changePwd(entity,pwd);&#125; @RequiresPermissions 和 @RequiresRoles分别用于限制该方法可访问的权限和角色，两者如果同时使用，默认是“&amp;”关系；两者的value参数都可以设置为数组，数组元素间的关系可以通过logical属性来设置，有Logical.AND，Logical.OR两个值可选择 小结spring-boot整合shiro的步骤如下： 添加maven依赖 添加ShiroConfigration配置，指定shiro的核心配置 添加MyShiroRealm，指定账户认证策略和角色权限获取方式 添加LoginFilter，即登录拦截器 添加登录、退出功能 通过注解添加接口调用权限限制 权限控制基于RBAC模型，涉及的表有：用户（user)、角色（role）、用户角色关系（user_role）、权限（permission）、角色权限关系（role_permission），具体代码可参考github内的示例项目。 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"shiro","slug":"shiro","permalink":"http://www.onecoderspace.com/tags/shiro/"},{"name":"权限控制","slug":"权限控制","permalink":"http://www.onecoderspace.com/tags/权限控制/"}]},{"title":"spring boot项目实战：redis","slug":"spring-boot-redis","date":"2017-10-01T10:47:10.000Z","updated":"2017-10-01T12:38:26.000Z","comments":true,"path":"2017/10/01/spring-boot-redis/","link":"","permalink":"http://www.onecoderspace.com/2017/10/01/spring-boot-redis/","excerpt":"缓存是提升服务性能的一个重要手段，而redis是分布式缓存中的佼佼者，性能优异，官方提供哨兵机制保证高可用，也支持集群方式，保证对大数据量的支持，项目内引入redis还是很有帮助的。","text":"缓存是提升服务性能的一个重要手段，而redis是分布式缓存中的佼佼者，性能优异，官方提供哨兵机制保证高可用，也支持集群方式，保证对大数据量的支持，项目内引入redis还是很有帮助的。 1、 添加maven依赖12345&lt;!-- redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2、 添加redis配置本地（单点redis）在application-local.properties（本地配置）内添加redis配置：1234567891011###redis配置###spring.redis.host=127.0.0.1 spring.redis.port=7001 spring.redis.database=0spring.redis.password=pwd# pool settings ...池配置 spring.redis.pool.max-idle=4spring.redis.pool.min-idle=1spring.redis.pool.max-active=4spring.redis.pool.max-wait=2000如果本地redis没有密码，删除spring.redis.password这行就可以了。 测试&amp;正式环境（哨兵）在application-dev.properties（测试环境）和application-prod.properties（正式环境）内添加redis配置：123456789101112131415 ###redis配置###spring.redis.database=0spring.redis.password=pwd # pool settings ...池配置 spring.redis.pool.max-idle=4spring.redis.pool.min-idle=1spring.redis.pool.max-active=4spring.redis.pool.max-wait=2000 #哨兵监听redis server名称 spring.redis.sentinel.master=mymaster#哨兵的配置列表 spring.redis.sentinel.nodes=host:port,host2:port2 3、使用StringRedisTemplate进行操作注入StringRedisTemplate：123 @Autowiredprivate StringRedisTemplate redisTemplate;使用RedisTemplate进行操作：12345678910111213141516//设置缓存，建议每个键都设置过期时间redisTemplate.opsForValue().set(\"test\", \"test\", 10, TimeUnit.SECONDS);//获取缓存值String value = redisTemplate.opsForValue().get(\"test\");//删除某个键redisTemplate.delete(\"test\");//操作setredisTemplate.opsForSet().add(\"testSet\", \"1\");Set&lt;String&gt; members = redisTemplate.opsForSet().members(\"testSet\");//获取set内的所有值redisTemplate.opsForSet().remove(\"testSet\", \"1\",\"2\");//移除set内的多个对象//操作listredisTemplate.opsForList().rightPush(\"testList\", \"1\");List&lt;String&gt; list = redisTemplate.opsForList().range(\"testList\", 0, -1);//获取list内的所有元素StringRedisTemplate对redis操作进行了很好的封装，为键、字符串、哈希、列表、集合、有序集合、HyperLogLog的操作提供了良好的支持。基本使用形式就是redisTemplate.opsForXXX,XXX是类型，opsForValue是操作字符串；opsForSet是操作集合，opsForList是操作列表，opsForZSet是操作有序集合，opsForHyperLogLog是操作HyperLogLog，基本上其方法和redis命令是对应的，可以根据名字和方法注释快速确定方法对应的redis命令。 4、使用RedisTemplate进行操作1、 创建RedisObjectSerializer.java12345678910111213141516171819202122232425262728293031323334353637import org.springframework.core.convert.converter.Converter;import org.springframework.core.serializer.support.DeserializingConverter;import org.springframework.core.serializer.support.SerializingConverter;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;public class RedisObjectSerializer implements RedisSerializer&lt;Object&gt; &#123; private Converter&lt;Object, byte[]&gt; serializer = new SerializingConverter(); private Converter&lt;byte[], Object&gt; deserializer = new DeserializingConverter(); static final byte[] EMPTY_ARRAY = new byte[0]; public Object deserialize(byte[] bytes) &#123; if (isEmpty(bytes)) &#123; return null; &#125; try &#123; return deserializer.convert(bytes); &#125; catch (Exception ex) &#123; throw new SerializationException(\"Cannot deserialize\", ex); &#125; &#125; public byte[] serialize(Object object) &#123; if (object == null) &#123; return EMPTY_ARRAY; &#125; try &#123; return serializer.convert(object); &#125; catch (Exception ex) &#123; return EMPTY_ARRAY; &#125; &#125; private boolean isEmpty(byte[] data) &#123; return (data == null || data.length == 0); &#125;&#125;2、 配置redisTemplate创建RedisConfig.java123456789101112@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setConnectionFactory(factory); template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(new RedisObjectSerializer()); return template; &#125;&#125;3、 使用RedisTemplate12345678910//注入RedisTemplate对象@Autowiredprivate RedisTemplate&lt;String, Object&gt; objRedisTemplate;//使用RedisTemplateUser user = new User();user.setId(1);user.setName(\"test\");objRedisTemplate.opsForValue().set(\"user\", user,10,TimeUnit.SECONDS);user = (User) objRedisTemplate.opsForValue().get(\"user\"); 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"redis","slug":"redis","permalink":"http://www.onecoderspace.com/tags/redis/"}]},{"title":"spring-boot项目实战：共享session","slug":"spring-boot-spring-session","date":"2017-10-01T01:42:04.000Z","updated":"2017-10-04T11:41:59.000Z","comments":true,"path":"2017/10/01/spring-boot-spring-session/","link":"","permalink":"http://www.onecoderspace.com/2017/10/01/spring-boot-spring-session/","excerpt":"在工作中会遇到以下几个场景： 发布新功能或修复bug，服务重启，用户需要重新登录 当集群内某个节点失效时，用户明明刚登录，仍被提示需要重新登录那如何做到服务发布、集群节点失效对用户无感知呢？有以下几种方式： 使用cookie保存用户状态信息 session同步法（多个web-server之间相互同步session） 后端统一存储（如：redis）","text":"在工作中会遇到以下几个场景： 发布新功能或修复bug，服务重启，用户需要重新登录 当集群内某个节点失效时，用户明明刚登录，仍被提示需要重新登录那如何做到服务发布、集群节点失效对用户无感知呢？有以下几种方式： 使用cookie保存用户状态信息 session同步法（多个web-server之间相互同步session） 后端统一存储（如：redis） 关于这几种方法的优缺点这里不再展开，可参看阅读《session一致性架构设计实践》,讲的很透彻，调理清晰。我们重点来看下如何通过后端统一存储来实现session共享，通过查找，发现了一个比较好的方案，spring-session，整合特别简单。1、在项目内引入redis参考我之前的一篇文档《spring boot项目实战：redis》，这里不再展开。 2、添加maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 3、添加java配置123456@Configuration @EnableRedisHttpSession(maxInactiveIntervalInSeconds=7200,redisNamespace=\"base\") public class RedisSessionConfig &#123;&#125; maxInactiveIntervalInSeconds用于设置session有效时间 redisNamespace用于区分不同的项目，如果多个项目共用用户数据，可以采用相同的值，这样就简单的实现了统一登录效果 要提醒的一点是如果用户数据特别大，需要注意redis容量规范及数据库规范，尽量保证缓存键分类存储在不同的库内，如用户session数据存储在数据库1内，业务缓存存储在0内，以此类推。 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"spring-session","slug":"spring-session","permalink":"http://www.onecoderspace.com/tags/spring-session/"},{"name":"共享session","slug":"共享session","permalink":"http://www.onecoderspace.com/tags/共享session/"}]},{"title":"spring boot项目实战：swagger2在线文档","slug":"spring-boot-swagger2","date":"2017-10-01T00:06:04.000Z","updated":"2017-10-01T12:38:53.000Z","comments":true,"path":"2017/10/01/spring-boot-swagger2/","link":"","permalink":"http://www.onecoderspace.com/2017/10/01/spring-boot-swagger2/","excerpt":"对于接口服务来说接口文档极其重要，在团队配合和后续维护中占据重要角色。在工作中，使用过excel，wiki来进行接口文档的维护：","text":"对于接口服务来说接口文档极其重要，在团队配合和后续维护中占据重要角色。在工作中，使用过excel，wiki来进行接口文档的维护： wiki：缺点是维护起来工作量较大，费时较长，优点是体验较好、检索方便、支持多人协作、支持历史版本查看； excel：初始整理时还好，但在后续多人协作新增功能或调整接口时，维护接口文档就变得极不方便 然后了解到swagger2，可以以编程的方式方便的生成在线文档，这样在接口调整时，能够及时的变更接口文档，使接口文档的准确性更高，下面来看下如何在spring boot项目内整合swagger2. 配置swagger21、 添加依赖1234567891011&lt;!-- swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;2、 添加基本配置123456789101112131415161718192021@Configuration@EnableSwagger2public class Swagger2 &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors .basePackage(\"com.onecoderspace.controller\")) .paths(PathSelectors.any()).build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(\"spring boot示例接口API\") .description(\"spring boot示例接口API\") .version(\"1.0\").build(); &#125;&#125; 通过@Configuration注解和@EnableSwagger2注解来启用Swagger2 basePackage：配置Swagger2需要扫描的包 3、 使用示例1234567891011121314151617181920212223242526272829@Api(tags=\"用户管理\",description=\"UserController\")@RestController@RequestMapping(\"/user\")public class UserController &#123; @ApiOperation(value = \"用户申请审核\", notes = \"用户申请审核\") @RequestMapping(value=\"/apply/audit\",method=RequestMethod.GET) public Return applyAudit() &#123; return Return.success(); &#125; @ApiOperation(value = \"获取用户详细信息\", notes = \"根据ID查找用户\") @ApiImplicitParam(paramType = \"query\", name = \"username\", value = \"用户名\", required = true, dataType = \"String\") @RequestMapping(value = \"/get\", method = RequestMethod.GET) public User get(String username) &#123; return null; &#125; @ApiOperation(value = \"修改用户信息\", notes = \"修改用户信息\") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = \"query\", name = \"user\", value = \"用户实体\", required = true, dataType = \"user\"), @ApiImplicitParam(paramType = \"query\", name = \"cname\", value = \"公司名称\", required = true, dataType = \"String\") &#125;) @RequestMapping(value = \"/save\", method = RequestMethod.POST) public Return save(User user, String cname, String curl) &#123; return Return.success(); &#125;&#125;在线文档显示效果如下： @Api:在类上添加注释，tags属性决定1处的内容，description决定2处的内容 @ApiOperation：在方法上添加注释，用于说明某个请求url的作用，value属性决定3处的内容，notes决定5处的内容 @ApiImplicitParam： 在方法上添加注释，用于说明某个请求参数的作用 @ApiImplicitParams多个参数时使用该注解 在实体字段添加@ApiModelProperty(value=”名称”)，生成该字段的说明 4、 注意事项 如果系统加入shiro等权限框架，那么访问swagger-ui.html需要有ACTUATOR角色，这个不要忘了配置 对于实体参数的支持不太好，保存更新时如果字段不是很多，建议使用属性的方式替代使用实体 swagger2是支持自定义页面的，如果觉得默认的样式不太适合，可以自定义前端页面，通过网络监控可以发现，所有数据是通过一个/v2/api-docs的请求获得的。 当接口较多时，swagger2也支持分组等配置，参考以下文档：spring-boot-starter-swagger 1.3.0.RELEASE：新增对JSR-303的支持和host的配置 相关阅读：swagger官网Spring Boot中使用Swagger2构建强大的RESTful API文档简化Swagger使用的自制Starter：spring-boot-starter-swagger，欢迎使用和吐槽 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"swagger2","slug":"swagger2","permalink":"http://www.onecoderspace.com/tags/swagger2/"},{"name":"在线接口文档","slug":"在线接口文档","permalink":"http://www.onecoderspace.com/tags/在线接口文档/"}]},{"title":"spring boot项目实战：异常处理","slug":"spring-boot-exception","date":"2017-10-01T00:04:58.000Z","updated":"2017-10-01T12:38:07.000Z","comments":true,"path":"2017/10/01/spring-boot-exception/","link":"","permalink":"http://www.onecoderspace.com/2017/10/01/spring-boot-exception/","excerpt":"异常处理是一个比较基础而又重要的技能点，在团队内最好形成一个统一的规则，避免团队成员不断掉进前辈已经爬出来的坑中。","text":"异常处理是一个比较基础而又重要的技能点，在团队内最好形成一个统一的规则，避免团队成员不断掉进前辈已经爬出来的坑中。 1、全局异常处理spring boot支持配置全局异常处理，记录未捕获的全局异常，这样方便在问题发生时快速定位问题，配置方式如下：12345678910111213141516@ControllerAdvicepublic class GlobalDefaultExceptionHandler &#123; private static Logger logger = LoggerFactory.getLogger(GlobalDefaultExceptionHandler.class); @ExceptionHandler(value = Exception.class) @ResponseBody public Map&lt;String, Object&gt; defaultErrorHandler(HttpServletRequest req,HttpServletResponse response, Exception e) &#123; logger.error(\"defaultErrorHandler:\", e); response.setStatus(500); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"code\", \"-1000\"); map.put(\"msg\", \"系统繁忙\"); return map; &#125;&#125; 在类上添加@ControllerAdvice注释 根据异常类型创建不同的方法，在方法上添加@ExceptionHandler注解，value的值是具体的异常类型 defaultErrorHandler方法的返回值可以是String（view路径),Map(json结构，需添加@ResponseBody注解) response状态需要设置，否则前端看到的会是正常的200，根据具体的异常来设置，如无权限返回403等，两种设置方式，response.setStatus(500) 或者 @ResponseStatus(value=HttpStatus.INTERNAL_SERVER_ERROR)注解 2、for、while循环异常处理在for、while循环内是否需要进行异常捕获应该根据循环体的业务来确定，当一次循环过程中发生异常时，是否要终止循环，这是你使用循环时不能忽略的一点。 如以下场景： APP批量上传用户启动、使用事件，循环将每条数据处理后放入kafka队列：每次循环都是一个独立的处理过程，一次循环发生异常时不希望终止整个循环，类似的场景循环内部就需要进行异常捕获，从而避免一条数据的异常导致整批数据一起失败； 批量删除用户，全部成功，否则回滚：业务需求是整个批次的数据全部成功，一个失败整体失败，那么就不需要在循环体内部进行异常捕获了，可以在循环体外或依赖全局异常处理来记录异常信息； 在循环内部捕获异常，特别是while循环时，要注意循环终止条件，不要出现无限循环记录日志，导致磁盘写满的情况。 3、代码段异常处理完成一件事情，需要执行很多步处理，编程时我们通常使用一个空行来分割不同的“步”以使程序看起来更有调理，每一步的操作可以定义为一个粗粒度的“代码段”。一个代码段是否需要进行异常捕获，同样是有代码的业务来确定，当异常发生时，是否需要终止整个处理流程是判断的标准。 如以下场景： 用户调用A接口，接口A包含三个代码段，参数校验-&gt;请求信息放入kafka-&gt;返回请求结果：第二步“请求信息放入kafka”对整个接口来说属于附加操作，当它发生异常时不应该影响用户正常获取数据，故此该代码段需要添加异常捕获，避免非核心业务的异常影响核心业务的执行。 用户调用B接口，接口B包含是哪个代码段，参数校验-&gt;创建用户信息—&gt;创建用户账号信息,第二步和第三步任何一个发生异常，都会导致整个操作失败，这种场景就不能单纯的捕获异常，那样会导致数据的不一致。 4、异常日志记录异常日志要记录在日志文件内，一定不要简单的将日志打印到控制台（测试环境一个tomcat放了十几个项目，如果都打印到控制台…）,在项目后期可以全局搜索System.out和System.err，并向对应人员指出。spring boot内建议使用logback作为日志组件，日志的使用可参考sprign boot项目实战:日志; 5、总结 项目内建议配置全局异常捕获，有利于问题排查； 单次循环发生异常是否应该终止循环？不要忽略这个的问题； 注意循环终止条件，避免出现无限循环记录日志的情况 一个代码段发生异常是否要终止整个处理流程？同样不要忽略这个问题； 异常日志最好记录在日志文件内，不要简单的打印到控制台 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"异常处理","slug":"异常处理","permalink":"http://www.onecoderspace.com/tags/异常处理/"}]},{"title":"boot项目实战：事务","slug":"spring-boot-transaction","date":"2017-10-01T00:04:38.000Z","updated":"2017-10-01T12:39:04.000Z","comments":true,"path":"2017/10/01/spring-boot-transaction/","link":"","permalink":"http://www.onecoderspace.com/2017/10/01/spring-boot-transaction/","excerpt":"事务在项目里也是不可或缺的一部分，建议形成一个统一的事务管理规范，不要出现让程序员根据业务自行添加，团队成员能力有高有低，很容易就出现需要事务时没添加事务，这种问题又很难测试出来，运行时却会不定时出现数据的不一致。","text":"事务在项目里也是不可或缺的一部分，建议形成一个统一的事务管理规范，不要出现让程序员根据业务自行添加，团队成员能力有高有低，很容易就出现需要事务时没添加事务，这种问题又很难测试出来，运行时却会不定时出现数据的不一致。想实现类似原spring项目里通过aop方式配置事务的效果，各种尝试，目前还未找到十分可行的方式。测试可用的事务配置方式有两种：在service上添加@Transactional注解 和 引入xml配置文件（不推荐），建议使用@Transactional注解来进行事务配置。 1、@Transactional实现事务spring boot项目内使用事务最简单直接的方式就是在每个service类上添加@Transactional注解，即可自动开启对事务的支持，不需要进行额外操作。 1@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED) 该注解也可添加在方法上，对事物进行更精细化的管理，注意引用spring包下的，不要引用javax包下的。 2、引入xml配置实现事务1、 创建com.onecoderspace.transaction.xml文件12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd\" default-lazy-init=\"false\" default-autowire=\"no\"&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.jpa.JpaTransactionManager\" /&gt; &lt;!-- 对于service使用annotation声明事物 --&gt; &lt;tx:annotation-driven mode=\"proxy\" proxy-target-class=\"true\" transaction-manager=\"transactionManager\" order=\"100\" /&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"insert*\" isolation=\"REPEATABLE_READ\" /&gt; &lt;tx:method name=\"save*\" isolation=\"REPEATABLE_READ\" /&gt; &lt;tx:method name=\"update*\" isolation=\"REPEATABLE_READ\" /&gt; &lt;tx:method name=\"del*\" isolation=\"REPEATABLE_READ\" /&gt; &lt;tx:method name=\"do*\" isolation=\"REPEATABLE_READ\" /&gt; &lt;tx:method name=\"*\" isolation=\"REPEATABLE_READ\" read-only=\"true\" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config proxy-target-class=\"true\"&gt; &lt;aop:advisor pointcut=\"execution(* com.onecoderspace..*.service..*.*(..))\" advice-ref=\"txAdvice\" order=\"200\" /&gt; &lt;/aop:config&gt;&lt;/beans&gt;2、引入xml配置文件12345@Configuration@ImportResource(\"classpath:com.onecoderspace.transaction.xml\")public class AopTransactionConfig &#123; &#125; 3、小结 service层需要统一添加事务，避免部分人员忘记事务处理，在运行过程中导致数据不一致； 在每个service上添加注解实现事务：定好项目整体事务隔离级别和传播属性即可在项目级别形成规范，胜在简单，可执行性更高，目前本公司使用该方式； 在service方法上添加注解实现事务：事务管理更灵活，更有针对性，缺点是难以形成统一规范，依赖编程人员的经验和能力，如果团队内存在经验不很充足的成员不推荐使用该方式； 通过引入xml配置实现事务：配置简单，在xml内一处配置即可实现事务管理，耦合性更低；缺点就是使用了xml配置，因此不太推荐使用该方式； 隔离级别（isolation）通常选择REPEATABLE_READ；传播属性通常使用默认值（REQUIRED）即可。 4、扩展阅读隔离级别（isolation）隔离级别是指若干个并发的事务之间的隔离程度，与我们开发时候主要相关的场景包括：脏读取、重复读、幻读。 我们可以看 org.springframework.transaction.annotation.Isolation 枚举类中定义了五个表示隔离级别的值：1234567public enum Isolation &#123; DEFAULT(-1), READ_UNCOMMITTED(1), READ_COMMITTED(2), REPEATABLE_READ(4), SERIALIZABLE(8);&#125; DEFAULT ：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是： READ_COMMITTED，mysql5.6默认是REPEATABLE-READ，可以通过select @@tx_isolation查看。 READ_UNCOMMITTED ：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。 READ_COMMITTED ：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 REPEATABLE_READ ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。 SERIALIZABLE ：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 传播属性（propagation）所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。 我们可以看 org.springframework.transaction.annotation.Propagation 枚举类中定义了6个表示传播行为的枚举值：123456789public enum Propagation &#123; REQUIRED(0), SUPPORTS(1), MANDATORY(2), REQUIRES_NEW(3), NOT_SUPPORTED(4), NEVER(5), NESTED(6);&#125; REQUIRED ：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。 SUPPORTS ：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 MANDATORY ：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 REQUIRES_NEW ：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 NOT_SUPPORTED ：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 NEVER ：以非事务方式运行，如果当前存在事务，则抛出异常。 NESTED ：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 REQUIRED 。 如有更好实现方式，敬请指出。 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"事务","slug":"事务","permalink":"http://www.onecoderspace.com/tags/事务/"}]},{"title":"前端实战：详情页返回列表内容缓存及定位实现","slug":"前端实战：详情页返回列表内容缓存及定位实现","date":"2017-09-26T12:45:21.000Z","updated":"2017-09-26T13:07:50.000Z","comments":true,"path":"2017/09/26/前端实战：详情页返回列表内容缓存及定位实现/","link":"","permalink":"http://www.onecoderspace.com/2017/09/26/前端实战：详情页返回列表内容缓存及定位实现/","excerpt":"实现目标当前浏览到第N页，点击某一个新闻，进入新闻详情页，点击返回时，列表数据不重新加载，焦点仍定位在进入详情页之前的位置。","text":"实现目标当前浏览到第N页，点击某一个新闻，进入新闻详情页，点击返回时，列表数据不重新加载，焦点仍定位在进入详情页之前的位置。 思路 缓存列表内已展示的数据； 进入详情页时在缓存内添加该新闻的ID（键为articleId）； 返回时在js内判断缓存内是否包含articleId，如果存在，则通过缓存的列表数据进行页面渲染； 通过articleId定位元素，滚动窗口值该元素处； 缓存不能始终存在。 根据当前项目情况，考虑缓存放入sessionStorage，滚动窗口使用IScroll。 实现方案1、缓存列表数据 123456789101112131415//cacheKey 缓存key cacheValue 缓存内容json结构 position 值为before和after分别用于加载最新和加载下一页 function addToCache(cacheKey,cacheValue,position)&#123; cacheValue = JSON.stringify(cacheValue); var allCacheData = sessionStorage.getItem(cacheKey); if(allCacheData != null)&#123; if(position == \"before\")&#123; allCacheData = cacheValue + \"::::\" +allCacheData; &#125; else &#123; allCacheData = allCacheData + \"::::\" + cacheValue; &#125; &#125; else &#123; allCacheData = cacheValue; &#125; sessionStorage.setItem(cacheKey,allCacheData); &#125; sessionStorage只能存储字符串，需要将json结构的对象转为字符串进行存储 如果列表数据特别多，应该和业务确认缓存数据条数，截取仅是字符串操作，这里不再展开 2、进入详情页123$(\".article\").click(function()&#123; sessionStorage.setItem(\"articleId\",$(this).attr(\"id\")); &#125;) 在每条新闻上绑定事件，点击时设置文章ID至缓存，正常来说在详情页设置，但是因为这个项目内的详情页不是我们部门的，所以只能在列表页设置； 3、返回时列表内js判断是从详情页返回的还是一次新的访问123456789var articleId = sessionStorage.getItem(\"articleId\"); var cacheData = sessionStorage.getItem($scope.initType); if(articleId != null &amp;&amp; cacheData != null)&#123; //从详情页返回且列表缓存数据不为空 showTableDataWithCache(cacheData,articleId); removeCache(\"articleId\");//注意使用一次就清理掉 &#125;else &#123; //一次新的访问，要清理掉所有相关缓存 removeAllFuturesCache(); loadPage(1); &#125;4、定位至对应元素1234567891011121314151617//注意IScroll需要重新初始化myScroll = new IScroll('#wrapper', &#123; probeType: 3, disableMouse: true, momentum: true, mouseWheel: true, disablePointer: true, click: true, tap: true, resizePolling: 1, // x &#125;);//滚动至对应元素myScroll.scrollToElement(document.querySelector(\"[id='\"+detailArticleId+\"']\"),10,true,true);initScroll();myScroll.refresh(); 注意IScroll需要重新初始化; scrollToElement的选择器格式是[id=’articleId’]而不是正常的”#articleId”;10 是动画时间 true true这样设置会将元素显示在窗口中间； 总结 sessionStorage是单个窗口级的缓存，同一个窗口内的数据可缓存在其内； IScroll可以作为页面滚动的组件； 详情页返回列表不刷新问题可以分解为三个小问题： 缓存列表数据 添加从详情页返回的标记（文章详情ID） 用缓存数据渲染页面后滚动窗口至对应元素通过sessionStorage存储数据，这样很多功能都可以实现，比如返回时标签选中等都是一样的思路，进入详情页时设置对应值，在页面加载时判断对应的缓存数据是否存在进而展开业务，这里不再展开。 参考：sessionStorage介绍IScroll使用","categories":[{"name":"前端","slug":"前端","permalink":"http://www.onecoderspace.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.onecoderspace.com/tags/前端/"},{"name":"列表数据缓存","slug":"列表数据缓存","permalink":"http://www.onecoderspace.com/tags/列表数据缓存/"},{"name":"详情页返回列表无刷新","slug":"详情页返回列表无刷新","permalink":"http://www.onecoderspace.com/tags/详情页返回列表无刷新/"},{"name":"html生成页面无法滚动","slug":"html生成页面无法滚动","permalink":"http://www.onecoderspace.com/tags/html生成页面无法滚动/"}]},{"title":"spring boot项目实战：跨域问题解决","slug":"spring-boot-cors","date":"2017-09-26T12:44:40.000Z","updated":"2017-10-01T12:37:56.000Z","comments":true,"path":"2017/09/26/spring-boot-cors/","link":"","permalink":"http://www.onecoderspace.com/2017/09/26/spring-boot-cors/","excerpt":"背景前后端分离架构，前端anglerjs，后端spring boot,使用shiro作为权限控制，已配置通用跨域请求支持。前端调用接口时部分情况正常，部分情况出现跨域请求不支持情况，错误信息如下：","text":"背景前后端分离架构，前端anglerjs，后端spring boot,使用shiro作为权限控制，已配置通用跨域请求支持。前端调用接口时部分情况正常，部分情况出现跨域请求不支持情况，错误信息如下：1Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'xxxx' is therefore not allowed access. 配置错了？首先，想到的就是对跨域请求支持的配置是错误的，尝试着替换不同的跨域支持配置，有以下几种：1、继承WebMvcConfigurerAdapter123456789101112@Configurationpublic class AppConfig extends WebMvcConfigurerAdapter &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\") .allowedOrigins(\"*\") .allowCredentials(true).allowedHeaders(\"Origin, X-Requested-With, Content-Type, Accept\") .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\", \"OPTIONS\") .maxAge(3600); &#125;&#125;2、配置WebMvcConfigurer123456789101112@Beanpublic WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\").allowedOrigins(\"*\") .allowedMethods(\"*\").allowedHeaders(\"*\") .allowCredentials(true) .exposedHeaders(HttpHeaders.SET_COOKIE).maxAge(3600L); &#125; &#125;;&#125;… CORS support in Spring Framework内的方式都尝试了一遍，发现问题仍然未解决，看到文档内的一个点 If you are using Spring Security, make sure to enable CORS at Spring Security level as well to allow it to leverage the configuration defined at Spring MVC level. 大概意思就是使用Spring Security要进行特殊的配置来支持CORS。而当前项目内使用的是shiro，是不是权限控制导致的问题?检查shiro相关代码，果然找到了问题，在loginFilter内会判断如果未登录，就通过response写回未登录提示，代码如下：1234567891011121314151617181920Subject subject = SecurityUtils.getSubject();if (!subject.isAuthenticated()) &#123; HttpServletResponse resp = (HttpServletResponse) response; String contentType = \"application/json\"; resp.setContentType(contentType); resp.setCharacterEncoding(\"UTF-8\"); Map&lt;String, String&gt; map = Maps.newLinkedHashMap(); map.put(\"code\", \"xxx\"); map.put(\"msg\", \"xxx\"); String result = JacksonHelper.toJson(map); PrintWriter out = resp.getWriter(); try&#123; out.print(result); out.flush(); &#125; finally &#123; out.close(); &#125; return;&#125;那就添加上跨域支持12resp.setHeader(\"Access-Control-Allow-Credentials\", \"true\");resp.setHeader(\"Access-Control-Allow-Origin\",request.getHeader(\"Origin\"));本来以为ok了，但是前端是不报错了，但并不能获得对应接口期望的结果，而是一直收到1&#123;\"code\":\"xxx\",\"msg\":\"xxx\"&#125;显然是被登录拦截了，但是明明已经登录，而且有的接口可以正常通过登录拦截，为什么部分接口会出现不能登录的情况呢？ 明明登录了，为什么被loginFilter拦截？遇到了问题就要想办法解决，首先就是怀疑客户端sessionId未被正常保存，在loginFilter内添加日志打印sessionID，发现每次的sessionID都不一样，问题清晰了一些，前端并未正确的保持登录状态，对比前端两个调用接口的代码，发现正常的是get请求，post请求不正常，通过在网上搜索，发现ajax post跨域请求时，默认是不携带浏览器的cookie的，也就是每次请求都会生成一个新的session，因此post请求都被登录拦截。解决办法如下：12345678910111213$.ajax(&#123; type:\"POST\", url:\"\", data:&#123;&#125;, crossDomain:true, xhrFields: &#123; withCredentials: true &#125;, success:function(data)&#123; &#125;, error:function(data)&#123; &#125;&#125;)配置crossDomain:true 和 xhrFields: { withCredentials: true }就可以让请求正常携带cookie。 一个完整可用方案1、配置支持跨域请求（多种方式自由选择，推荐使用下面的方式）12345678910111213141516171819@Configurationpublic class WebConfig &#123; /** * 跨域请求支持 */ @Bean public WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\").allowedOrigins(\"*\") .allowedMethods(\"*\").allowedHeaders(\"*\") .allowCredentials(true) .exposedHeaders(HttpHeaders.SET_COOKIE).maxAge(3600L); &#125; &#125;; &#125;&#125;2、前端ajax post请求时添加xhrFields: { withCredentials: true }12345678910111213$.ajax(&#123; type:\"POST\", url:\"\", data:&#123;&#125;, crossDomain:true, xhrFields: &#123; withCredentials: true &#125;, success:function(data)&#123; &#125;, error:function(data)&#123; &#125;&#125;)3、检查权限控制代码，看是否有特殊处理的地方，未添加跨域支持。如上文所提，登录拦截直接通过response写回未登录提示；使用spring-security框架时也要添加特殊配置，如下：12345678@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.cors().and()... &#125;&#125; 解决跨域的本质就是在返回头内添加Access-Control-Allow-Origin，实现方式有多种，spring体系内解决跨域可参考CORS support in Spring Framework,很全面的介绍了各种场景。使用权限框架时，要注意权限框架本身的CORS支持。 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"CORS","slug":"CORS","permalink":"http://www.onecoderspace.com/tags/CORS/"},{"name":"跨域","slug":"跨域","permalink":"http://www.onecoderspace.com/tags/跨域/"},{"name":"ajax post跨域","slug":"ajax-post跨域","permalink":"http://www.onecoderspace.com/tags/ajax-post跨域/"}]},{"title":"sprign boot项目实战：日志","slug":"spring-boot-log","date":"2017-09-26T12:43:59.000Z","updated":"2017-10-01T12:38:16.000Z","comments":true,"path":"2017/09/26/spring-boot-log/","link":"","permalink":"http://www.onecoderspace.com/2017/09/26/spring-boot-log/","excerpt":"日志是运维、排错的一个重要助手，很多人应该都维护过没有日志的项目，知道排查问题是什么感觉。所以搭建基础项目框架时，自然不能少了日志。","text":"日志是运维、排错的一个重要助手，很多人应该都维护过没有日志的项目，知道排查问题是什么感觉。所以搭建基础项目框架时，自然不能少了日志。 日志组件选择从网上各种搜索对比，在log4j2和logback之间选择了log4j2,综合各处评价，log4j2在性能方法有一定优势。但是在一个项目内使用后就发现，spring boot内log4j2不支持spring profile机制，也就是在本地环境、测试环境、预发布环境、正式环境需要手动切换配置，当前公司的多个环境在相同的服务器上，所以这种方式会导致多个环境的日志生成在了同一个文件内，很不利于问题排查。因此又将日志组件换回了logback，因为对当前公司的项目来说，日志支持profile机制更重要，性能瓶颈绝不在日志这块。 logback配置spring boot内配置logback还是很简单的，只需要在src/main/resources目录下创建logback-spring.xml，在xml内添加自己的日志配置即可。支持三个环境local、dev、prod的日志配置如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration scan=\"true\" scanPeriod=\"30 seconds\"&gt; &lt;property name=\"LOG_PATH\" value=\"/mnt/diskb/logs\"/&gt; &lt;springProfile name=\"local\"&gt; &lt;logger name=\"com.onecoderspace\" level=\"debug\" additivity=\"true\"/&gt; &lt;appender name=\"logfile\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ssS&#125; %5p [%c]:%L-%m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;/springProfile&gt; &lt;springProfile name=\"dev\"&gt; &lt;logger name=\"com.onecoderspace\" level=\"info\" additivity=\"true\"/&gt; &lt;appender name=\"logfile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;$&#123;LOG_PATH&#125;/projectName/projectName_dev.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ssS&#125; %5p [%c&#123;5&#125;#%M]:%L-%m%n%caller&#123;0&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- daily rollover --&gt; &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/projectName/projectName_dev.%d&#123;yyyy-MM-dd&#125;.log.gz &lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;/springProfile&gt; &lt;springProfile name=\"prod\"&gt; &lt;logger name=\"com.onecoderspace\" level=\"info\" additivity=\"true\"/&gt; &lt;appender name=\"logfile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;$&#123;LOG_PATH&#125;/projectName/projectName.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ssS&#125; %5p [%c&#123;5&#125;#%M]:%L-%m%n%caller&#123;0&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- daily rollover --&gt; &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/projectName/projectName.%d&#123;yyyy-MM-dd&#125;.log.gz &lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;/springProfile&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"logfile\" /&gt; &lt;/root&gt;&lt;/configuration&gt;spring-boot-starter-web内已经包含了logback和slf4j的依赖，所以只要项目依赖了spring-boot-starter-web，就不需要做其他额外的配置了。 日志使用调用日志时建议使用slf4j，虽然基本不会在后续变更日志组件，但使用slf4j是一个好的习惯。123import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static Logger logger = LoggerFactory.getLogger(LoginController.class);debug日志debug日志建议添加logger.isDebugEnabled()判断，在重要的流程上都留下日志，这样当系统出现问题时，可以通过debug日志，快速定位问题，能代替很多断点调试的时间。1234 if(logger.isDebugEnabled())&#123; logger.debug(\"user=&#123;&#125; login success\",username);&#125;info日志比较重要的信息，对于系统运行有比较重要的参考意义，同时不会对性能造成影响，可以在正式环境展示的信息，使用info基本打印，如定时任务运行时间等。1logger.info(\"end fetcher proxy use time=&#123;&#125;\", System.currentTimeMillis()- t);error日志error日志相对来说是最重要的，但使用时需要注意使用方式，不正确的方式会导致很多信息被隐藏。可以参考如下方式：12 logger.error(String.format(\"error msg ,arg1=%s,arg2=%s\",arg1,arg2), e); 尽可能的带上异常发生时的参数，这个对排查问题很有意义 打印异常的完整堆栈信息，仅打印e.getMessage()会导致很多信息被隐藏 只在异常发生时或明确的业务错误时使用error，不要用error来打印调试、普通信息 总结 spring boot项目内日志组件选择logback比较好，内嵌的日志组件，支持profile机制； logback配置方式为在src/main/resources目录下创建logback-spring.xml，配置内容参考上文； 调用日志时使用slf4j，注意合理使用日志级别 注意以下几点tips tips1、 应用日志尽量放在数据盘上，不要放在系统盘上，遇到了不止一次日志写满系统盘导致服务暂停的情况2、 技术负责人定好日志规范，在代码review时指出几次日志使用的问题，能够很快让良好使用日志成为团队的习惯3、 正式环境的日志基本最低为info，通常可以调整为warn或error4、 在while循环内有异常捕获时，注意当异常发生时，不能无限打印日志，如下代码：123456789101112131415 while (flag) &#123; try &#123; byte[] bb = _queue.poll(1, TimeUnit.SECONDS); if (bb != null) &#123; @SuppressWarnings(\"unchecked\") Map&lt;String, Object&gt; m = JacksonSupport.decode1(new ByteArrayInputStream(bb), Map.class); E event = _consumer.getEventType().newInstance(); event.fromMap(m); _consumer.onEvent(event); &#125; &#125; catch (Exception e) &#123; logger.error(\"redis queue poll due to error\", e); &#125;&#125;从基于redis开发的一个blockingQueue内获取元素进行消费，代码运行了一年多十分正常，但是有一次几乎把磁盘写满了，因为当时运维调整，redis停掉了， _queue.poll这里就开始抛异常，然后下面就狂写日志，一直把磁盘写满。类似这样的地方，可以进行一个计数，连续错误达到多少次，就终止循环并以某些方式提醒运维人员。5、不要使用System.out.println()，建议隔段时间全局搜索一次，发现了就在小组会议上提一下，很快这种现象就会杜绝 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"日志","slug":"日志","permalink":"http://www.onecoderspace.com/tags/日志/"},{"name":"spring profile","slug":"spring-profile","permalink":"http://www.onecoderspace.com/tags/spring-profile/"}]},{"title":"spring boot实战","slug":"spring-boot项目实战：目录","date":"2017-09-25T13:43:52.000Z","updated":"2017-10-04T11:41:30.000Z","comments":true,"path":"2017/09/25/spring-boot项目实战：目录/","link":"","permalink":"http://www.onecoderspace.com/2017/09/25/spring-boot项目实战：目录/","excerpt":"最近基于spring boot搭建了一套公司后端接口项目基础框架，方便公司后续项目的快速开发。本系列博客从实际开发项目所需功能的角度，逐功能点的讲述实现方式，最终完成一个可以直接用于公司项目开发的基础框架。让大家对于使用spring boot开发项目有一个更直观、全面的认识，也让小伙伴们少踩几个我掉过的坑，更愉快的加入spring boot的阵营。","text":"最近基于spring boot搭建了一套公司后端接口项目基础框架，方便公司后续项目的快速开发。本系列博客从实际开发项目所需功能的角度，逐功能点的讲述实现方式，最终完成一个可以直接用于公司项目开发的基础框架。让大家对于使用spring boot开发项目有一个更直观、全面的认识，也让小伙伴们少踩几个我掉过的坑，更愉快的加入spring boot的阵营。项目包含的基础功能有： spring boot项目基础结构 spring boot项目实战：JPA 公共方法提取：service、dao、model spring-boot项目实战：shiro spring boot项目实战：跨域支持：CORS spring boot项目实战：redis spring boot项目实战：日志 spring boot项目实战：事务 安全：xss、CSRF、SQL注入 spring boot项目实战：分布式锁 常用工具类（日期、http、集合操作、文件操作、json、加密、ognl等） spring-boot实战：共享session spring boot项目实战：swagger2在线文档 代码生成器：code-generator 应用监控：Spring Boot Actuator JSP支持 额外推荐一个很不错的博客，我入门都是在上面看的。程序员DD|博客 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"http://www.onecoderspace.com/tags/CSRF/"},{"name":"CORS","slug":"CORS","permalink":"http://www.onecoderspace.com/tags/CORS/"},{"name":"日志","slug":"日志","permalink":"http://www.onecoderspace.com/tags/日志/"},{"name":"JPA","slug":"JPA","permalink":"http://www.onecoderspace.com/tags/JPA/"},{"name":"redis","slug":"redis","permalink":"http://www.onecoderspace.com/tags/redis/"},{"name":"shiro","slug":"shiro","permalink":"http://www.onecoderspace.com/tags/shiro/"},{"name":"权限控制","slug":"权限控制","permalink":"http://www.onecoderspace.com/tags/权限控制/"},{"name":"spring-session","slug":"spring-session","permalink":"http://www.onecoderspace.com/tags/spring-session/"},{"name":"事务","slug":"事务","permalink":"http://www.onecoderspace.com/tags/事务/"},{"name":"spring-boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/tags/spring-boot实战/"},{"name":"web基础框架","slug":"web基础框架","permalink":"http://www.onecoderspace.com/tags/web基础框架/"},{"name":"异常","slug":"异常","permalink":"http://www.onecoderspace.com/tags/异常/"},{"name":"接口文档","slug":"接口文档","permalink":"http://www.onecoderspace.com/tags/接口文档/"},{"name":"跨域支持","slug":"跨域支持","permalink":"http://www.onecoderspace.com/tags/跨域支持/"},{"name":"安全","slug":"安全","permalink":"http://www.onecoderspace.com/tags/安全/"},{"name":"xss","slug":"xss","permalink":"http://www.onecoderspace.com/tags/xss/"},{"name":"缓存","slug":"缓存","permalink":"http://www.onecoderspace.com/tags/缓存/"},{"name":"分布式锁","slug":"分布式锁","permalink":"http://www.onecoderspace.com/tags/分布式锁/"}]},{"title":"web项目高效开发","slug":"高效开发","date":"2017-09-24T06:26:20.000Z","updated":"2017-09-24T13:23:10.000Z","comments":true,"path":"2017/09/24/高效开发/","link":"","permalink":"http://www.onecoderspace.com/2017/09/24/高效开发/","excerpt":"从事开发工作五年多，参与、带的项目几十个，中间也思考过怎么提高项目的开发速度和质量，也陆续尝试了一些方法，最近稍有空闲，就系统梳理、自我总结一把，主要有以下几点： 理清需求再动手，不要后期需求变更、代码补丁打的自己酸爽无比 减少模板代码的copy开发，能自动生成的自动生成 提取自己公司的模板项目，配合代码生成器生成40%以上的模板代码 生成规范可用的文档，减少文档维护工作 自动构建部署项目 规范日志，提升运维效率思路就是“通用的东西进行提取，能自动生成的东西自动生成，让程序员专心写业务代码”。","text":"从事开发工作五年多，参与、带的项目几十个，中间也思考过怎么提高项目的开发速度和质量，也陆续尝试了一些方法，最近稍有空闲，就系统梳理、自我总结一把，主要有以下几点： 理清需求再动手，不要后期需求变更、代码补丁打的自己酸爽无比 减少模板代码的copy开发，能自动生成的自动生成 提取自己公司的模板项目，配合代码生成器生成40%以上的模板代码 生成规范可用的文档，减少文档维护工作 自动构建部署项目 规范日志，提升运维效率思路就是“通用的东西进行提取，能自动生成的东西自动生成，让程序员专心写业务代码”。 1、理清需求功能点多，技术难度大对程序员来说正常，加班干活也没啥怨言，完成了心中还有点成就感，但几个功能点翻来覆去的调整个三五次，那90%的人估计都已经在心里问候项目经理了。有些需求变更是难免的，但更多的是可以通过合适的管理、设计来避免的，特别是小公司的技术负责人（如我）更应该注意”想清楚要做什么比立马思考怎么做更重要“，你在开始设计时跑偏一些，忘记一些，就意味着之后的某个时间团队集体狼狈的加班，这里有几点小经验分享给大军： 认真阅读需求文档，在心里构画出整个网站的全景图，任何一个分支小道都不忽视 提出问题，让需求人员想的更多一点 自己将对需求的认识向需求+团队成员讲一遍 负责某一模块的团队成员复述一下对需求的认识 2、项目模板项目内有很多底层通用的东西，特别是一个公司内容的项目，不同项目间共性的东西更多，很多时候开发也是copy一个项目，把原来的业务功能删减，有类似功能的再从不同项目里copy过来。这种情况将共性代码提出为一个base项目，后续项目都直接在base项目的基础上开发，明显会更舒爽很多。目前使用spring-boot搭建了一个后端web接口开发的模板项目，后续也会在《spring boot项目实战》系列文章进行分享。 3、代码生成代码生成器的原理就是读取表结构，生成对应的模板代码，所以开发一个项目先进行数据库设计。一、数据库设计有段时间设计数据库使用excel，后面发现修改、维护、查看都不怎么方便，现在在使用免费的workbench进行数据库设计，软件操作还算顺手，能够简单的体现模块、表之间的关系。在这方面根据个人感觉，用着顺手就行，建议使用专业的软件，excel之类的从效果上来说的确有一定的差距。建议每个字段都设置好注释，字段命名多个单词用下划线分割。 二、代码生成器本人开发了一个代码生成器，功能有： 生成指定数据库内所有表对应的模板代码（实体、dao、service、controller） 生成指定数据库内指定表对应的模板代码（实体、dao、service、controller）原理是通过sql查询数据内有哪些数据库，数据库内有哪些表，表里面的字段信息，然后通过freemarker来生成模板代码，如有需要可根据该项目调整对应的模板生成自己公司的代码。GitHub: https://github.com/q7322068/code-generation 4、在线文档生成公司项目是前后端分离的架构，刚开始都是通过excel来提供接口文档给前端，后来维护起来实在是太麻烦，调整了就要改excel，多个人维护起来，很快就乱套了，后来决定使用swagger2来构建在线api文档，以代码的形式来维护，代码调整时添加上指定格式的注释就能自动生成接口文档，前端通过在线文档来查看，配合起来更舒服。使用请参考：Spring Boot中使用Swagger2构建强大的RESTful API文档简化Swagger使用的自制Starter：spring-boot-starter-swagger，欢迎使用和吐槽spring-boot-starter-swagger 1.3.0.RELEASE：新增对JSR-303的支持和host的配置 5、自动构建代码开发好了，总是要在服务器上部署运行的，我现在的公司采用Jenkins来完成自动打包部署，提交svn代码，Jenkins自动打包（支持war包、jar包）部署至测试环境，预发布环境和正式环境基于测试环境的代码进行发布（通过脚本进行发布，实际上就是遍历某个文件夹下的文件，选择后进行copy）。 6、日志很重要刚到现在公司的时候，接手的项目日志千奇百怪，有打印到控制台的，有日志未生效的，有自己写到某个文件的（你没看错），加上项目文档严重缺失，有过类似体验的兄弟知道是啥感觉。所以抽取基础项目时直接定好日志规范，在规定目录下生成日志，日志完备了，日常运维也就简单了。 总结 提取一套基础框架，把该有的组件、工具类都放进去 设计数据库、代码生成，这样model、dao、service、controller都有了，注意啊比较完备的在线注释已经存在了^_^ 使用Jenkins自动构建发布，部署项目再也不需要自己上去svn up，ps,kill等一系列操作了； 日志很重要很重要，没日志的日子很难过滴希望这篇文章能诱发点你的“懒病”，每天只写“爽”的代码，想要懒就只能先勤快，为你的开发打造点顺手的武器吧。","categories":[{"name":"java实战","slug":"java实战","permalink":"http://www.onecoderspace.com/categories/java实战/"}],"tags":[{"name":"java实战 spirng-boot 项目高效开发 自动构建 代码生成","slug":"java实战-spirng-boot-项目高效开发-自动构建-代码生成","permalink":"http://www.onecoderspace.com/tags/java实战-spirng-boot-项目高效开发-自动构建-代码生成/"}]}]}