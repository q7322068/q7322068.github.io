{"meta":{"title":"足迹|成长之路","subtitle":"实战经验梳理，分享与你，分享与自己！","description":"spring boot，spring cloud，微服务，java web编程实战","author":"杨文魁","url":"http://www.onecoderspace.com"},"pages":[{"title":"","date":"2017-09-16T03:13:44.000Z","updated":"2017-09-16T03:13:13.000Z","comments":true,"path":"5435542637.html","permalink":"http://www.onecoderspace.com/5435542637.html","excerpt":"","text":""},{"title":"","date":"2017-09-15T15:27:58.000Z","updated":"2017-09-15T15:27:58.000Z","comments":true,"path":"404.html","permalink":"http://www.onecoderspace.com/404.html","excerpt":"","text":""},{"title":"关于我","date":"2017-09-10T12:49:14.000Z","updated":"2017-09-10T13:18:59.000Z","comments":true,"path":"about/index.html","permalink":"http://www.onecoderspace.com/about/index.html","excerpt":"","text":"有志之人立长志，无志之人常立志 杨文魁一个程序猿技术上，主要从事java web开发，一直在中小公司工作，对于系统设计、数据库设计、代码开发、前端、部署都有较多的经验。但怎么说呢，各个地方都会，但很少有大并发、大数据量的实践场景，对于技术的掌握也感觉没有达到很精深的程度，希望能在后续的时间内梳理自己过往实践中用过的技术、解决的问题，总结过往，找到深入研究的方向，在技术上继续提升自己的能力。 近期博客里会写一系列最近在开发中用到的spring boot,spring cloud等技术，从项目实战的角度来来阐述这些技术的使用及中间遇到的各种大大小小的问题。"}],"posts":[{"title":"spring boot项目实战：redis","slug":"spring-boot-redis","date":"2017-10-01T10:47:10.000Z","updated":"2017-10-01T11:01:45.000Z","comments":true,"path":"2017/10/01/spring-boot-redis/","link":"","permalink":"http://www.onecoderspace.com/2017/10/01/spring-boot-redis/","excerpt":"缓存是提升服务性能的一个重要手段，而redis是分布式缓存中的佼佼者，性能优异，官方提供哨兵机制保证高可用，也支持集群方式，保证对大数据量的支持，项目内引入redis还是很有帮助的。","text":"缓存是提升服务性能的一个重要手段，而redis是分布式缓存中的佼佼者，性能优异，官方提供哨兵机制保证高可用，也支持集群方式，保证对大数据量的支持，项目内引入redis还是很有帮助的。 1、 添加maven依赖12345&lt;!-- redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2、 添加redis配置本地（单点redis）在application-local.properties（本地配置）内添加redis配置：1234567891011###redis配置###spring.redis.host=127.0.0.1 spring.redis.port=7001 spring.redis.database=0spring.redis.password=pwd# pool settings ...池配置 spring.redis.pool.max-idle=4spring.redis.pool.min-idle=1spring.redis.pool.max-active=4spring.redis.pool.max-wait=2000如果本地redis没有密码，删除spring.redis.password这行就可以了。 测试&amp;正式环境（哨兵）在application-dev.properties（测试环境）和application-prod.properties（正式环境）内添加redis配置：123456789101112131415 ###redis配置###spring.redis.database=0spring.redis.password=pwd # pool settings ...池配置 spring.redis.pool.max-idle=4spring.redis.pool.min-idle=1spring.redis.pool.max-active=4spring.redis.pool.max-wait=2000 #哨兵监听redis server名称 spring.redis.sentinel.master=mymaster#哨兵的配置列表 spring.redis.sentinel.nodes=host:port,host2:port2 3、使用StringRedisTemplate进行操作注入StringRedisTemplate：123 @Autowiredprivate StringRedisTemplate redisTemplate;使用RedisTemplate进行操作：12345678910111213141516//设置缓存，建议每个键都设置过期时间redisTemplate.opsForValue().set(\"test\", \"test\", 10, TimeUnit.SECONDS);//获取缓存值String value = redisTemplate.opsForValue().get(\"test\");//删除某个键redisTemplate.delete(\"test\");//操作setredisTemplate.opsForSet().add(\"testSet\", \"1\");Set&lt;String&gt; members = redisTemplate.opsForSet().members(\"testSet\");//获取set内的所有值redisTemplate.opsForSet().remove(\"testSet\", \"1\",\"2\");//移除set内的多个对象//操作listredisTemplate.opsForList().rightPush(\"testList\", \"1\");List&lt;String&gt; list = redisTemplate.opsForList().range(\"testList\", 0, -1);//获取list内的所有元素StringRedisTemplate对redis操作进行了很好的封装，为键、字符串、哈希、列表、集合、有序集合、HyperLogLog的操作提供了良好的支持。基本使用形式就是redisTemplate.opsForXXX,XXX是类型，opsForValue是操作字符串；opsForSet是操作集合，opsForList是操作列表，opsForZSet是操作有序集合，opsForHyperLogLog是操作HyperLogLog，基本上其方法和redis命令是对应的，可以根据名字和方法注释快速确定方法对应的redis命令。 4、使用RedisTemplate进行操作1、 创建RedisObjectSerializer.java12345678910111213141516171819202122232425262728293031323334353637import org.springframework.core.convert.converter.Converter;import org.springframework.core.serializer.support.DeserializingConverter;import org.springframework.core.serializer.support.SerializingConverter;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;public class RedisObjectSerializer implements RedisSerializer&lt;Object&gt; &#123; private Converter&lt;Object, byte[]&gt; serializer = new SerializingConverter(); private Converter&lt;byte[], Object&gt; deserializer = new DeserializingConverter(); static final byte[] EMPTY_ARRAY = new byte[0]; public Object deserialize(byte[] bytes) &#123; if (isEmpty(bytes)) &#123; return null; &#125; try &#123; return deserializer.convert(bytes); &#125; catch (Exception ex) &#123; throw new SerializationException(\"Cannot deserialize\", ex); &#125; &#125; public byte[] serialize(Object object) &#123; if (object == null) &#123; return EMPTY_ARRAY; &#125; try &#123; return serializer.convert(object); &#125; catch (Exception ex) &#123; return EMPTY_ARRAY; &#125; &#125; private boolean isEmpty(byte[] data) &#123; return (data == null || data.length == 0); &#125;&#125;2、 配置redisTemplate创建RedisConfig.java123456789101112@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setConnectionFactory(factory); template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(new RedisObjectSerializer()); return template; &#125;&#125;3、 使用RedisTemplate12345678910//注入RedisTemplate对象@Autowiredprivate RedisTemplate&lt;String, Object&gt; objRedisTemplate;//使用RedisTemplateUser user = new User();user.setId(1);user.setName(\"test\");objRedisTemplate.opsForValue().set(\"user\", user,10,TimeUnit.SECONDS);user = (User) objRedisTemplate.opsForValue().get(\"user\"); 《spring boot项目实战》之redis使用，本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"redis","slug":"redis","permalink":"http://www.onecoderspace.com/tags/redis/"}]},{"title":"spring-boot实战：共享session","slug":"spring-boot-spring-session","date":"2017-10-01T01:42:04.000Z","updated":"2017-10-01T11:03:04.000Z","comments":true,"path":"2017/10/01/spring-boot-spring-session/","link":"","permalink":"http://www.onecoderspace.com/2017/10/01/spring-boot-spring-session/","excerpt":"在工作中会遇到以下几个场景： 发布新功能或修复bug，服务重启，用户需要重新登录 当集群内某个节点失效时，用户明明刚登录，仍被提示需要重新登录那如何做到服务发布、集群节点失效对用户无感知呢？有以下几种方式： 使用cookie保存用户状态信息 session同步法（多个web-server之间相互同步session） 后端统一存储（如：redis）","text":"在工作中会遇到以下几个场景： 发布新功能或修复bug，服务重启，用户需要重新登录 当集群内某个节点失效时，用户明明刚登录，仍被提示需要重新登录那如何做到服务发布、集群节点失效对用户无感知呢？有以下几种方式： 使用cookie保存用户状态信息 session同步法（多个web-server之间相互同步session） 后端统一存储（如：redis） 关于这几种方法的优缺点这里不再展开，可参看阅读《session一致性架构设计实践》,讲的很透彻，调理清晰。我们重点来看下如何通过后端统一存储来实现session共享，通过查找，发现了一个比较好的方案，spring-session，整合特别简单。1、在项目内引入redis参考我之前的一篇文档《spring boot项目实战：redis》，这里不再展开。 2、添加maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 3、添加java配置123456@Configuration @EnableRedisHttpSession(maxInactiveIntervalInSeconds=7200,redisNamespace=\"base\") public class RedisSessionConfig &#123;&#125; maxInactiveIntervalInSeconds用于设置session有效时间 redisNamespace用于区分不同的项目，如果多个项目共用用户数据，可以采用相同的值，这样就简单的实现了统一登录效果 要提醒的一点是如果用户数据特别大，需要注意redis容量规范及数据库规范，尽量保证缓存键分类存储在不同的库内，如用户session数据存储在数据库1内，业务缓存存储在0内，以此类推。 本文为《spring boot项目实战》系列之共享内存实现方式，系列文章持续更新，另外，本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"spring-session","slug":"spring-session","permalink":"http://www.onecoderspace.com/tags/spring-session/"},{"name":"共享session","slug":"共享session","permalink":"http://www.onecoderspace.com/tags/共享session/"}]},{"title":"spring boot项目实战：swagger2在线文档","slug":"spring-boot-swagger2","date":"2017-10-01T00:06:04.000Z","updated":"2017-10-01T11:03:48.000Z","comments":true,"path":"2017/10/01/spring-boot-swagger2/","link":"","permalink":"http://www.onecoderspace.com/2017/10/01/spring-boot-swagger2/","excerpt":"对于接口服务来说接口文档极其重要，在团队配合和后续维护中占据重要角色。在工作中，使用过excel，wiki来进行接口文档的维护：","text":"对于接口服务来说接口文档极其重要，在团队配合和后续维护中占据重要角色。在工作中，使用过excel，wiki来进行接口文档的维护： wiki：缺点是维护起来工作量较大，费时较长，优点是体验较好、检索方便、支持多人协作、支持历史版本查看； excel：初始整理时还好，但在后续多人协作新增功能或调整接口时，维护接口文档就变得极不方便 然后了解到swagger2，可以以编程的方式方便的生成在线文档，这样在接口调整时，能够及时的变更接口文档，使接口文档的准确性更高，下面来看下如何在spring boot项目内整合swagger2. 配置swagger21、 添加依赖1234567891011&lt;!-- swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;2、 添加基本配置123456789101112131415161718192021@Configuration@EnableSwagger2public class Swagger2 &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors .basePackage(\"com.onecoderspace.controller\")) .paths(PathSelectors.any()).build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(\"spring boot示例接口API\") .description(\"spring boot示例接口API\") .version(\"1.0\").build(); &#125;&#125; 通过@Configuration注解和@EnableSwagger2注解来启用Swagger2 basePackage：配置Swagger2需要扫描的包 3、 使用示例1234567891011121314151617181920212223242526272829@Api(tags=\"用户管理\",description=\"UserController\")@RestController@RequestMapping(\"/user\")public class UserController &#123; @ApiOperation(value = \"用户申请审核\", notes = \"用户申请审核\") @RequestMapping(value=\"/apply/audit\",method=RequestMethod.GET) public Return applyAudit() &#123; return Return.success(); &#125; @ApiOperation(value = \"获取用户详细信息\", notes = \"根据ID查找用户\") @ApiImplicitParam(paramType = \"query\", name = \"username\", value = \"用户名\", required = true, dataType = \"String\") @RequestMapping(value = \"/get\", method = RequestMethod.GET) public User get(String username) &#123; return null; &#125; @ApiOperation(value = \"修改用户信息\", notes = \"修改用户信息\") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = \"query\", name = \"user\", value = \"用户实体\", required = true, dataType = \"user\"), @ApiImplicitParam(paramType = \"query\", name = \"cname\", value = \"公司名称\", required = true, dataType = \"String\") &#125;) @RequestMapping(value = \"/save\", method = RequestMethod.POST) public Return save(User user, String cname, String curl) &#123; return Return.success(); &#125;&#125;在线文档显示效果如下： @Api:在类上添加注释，tags属性决定1处的内容，description决定2处的内容 @ApiOperation：在方法上添加注释，用于说明某个请求url的作用，value属性决定3处的内容，notes决定5处的内容 @ApiImplicitParam： 在方法上添加注释，用于说明某个请求参数的作用 @ApiImplicitParams多个参数时使用该注解 在实体字段添加@ApiModelProperty(value=”名称”)，生成该字段的说明 4、 注意事项 如果系统加入shiro等权限框架，那么访问swagger-ui.html需要有ACTUATOR角色，这个不要忘了配置 对于实体参数的支持不太好，保存更新时如果字段不是很多，建议使用属性的方式替代使用实体 swagger2是支持自定义页面的，如果觉得默认的样式不太适合，可以自定义前端页面，通过网络监控可以发现，所有数据是通过一个/v2/api-docs的请求获得的。 当接口较多时，swagger2也支持分组等配置，参考以下文档：spring-boot-starter-swagger 1.3.0.RELEASE：新增对JSR-303的支持和host的配置 相关阅读：swagger官网Spring Boot中使用Swagger2构建强大的RESTful API文档简化Swagger使用的自制Starter：spring-boot-starter-swagger，欢迎使用和吐槽 本文为《spring boot项目实战》系列之在线接口文档生成方式，系列文章持续更新，另外，本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"swagger2","slug":"swagger2","permalink":"http://www.onecoderspace.com/tags/swagger2/"},{"name":"在线接口文档","slug":"在线接口文档","permalink":"http://www.onecoderspace.com/tags/在线接口文档/"}]},{"title":"spring boot项目实战：异常处理","slug":"spring-boot-exception","date":"2017-10-01T00:04:58.000Z","updated":"2017-10-01T10:58:10.000Z","comments":true,"path":"2017/10/01/spring-boot-exception/","link":"","permalink":"http://www.onecoderspace.com/2017/10/01/spring-boot-exception/","excerpt":"异常处理是一个比较基础而又重要的技能点，在团队内最好形成一个统一的规则，避免团队成员不断掉进前辈已经爬出来的坑中。","text":"异常处理是一个比较基础而又重要的技能点，在团队内最好形成一个统一的规则，避免团队成员不断掉进前辈已经爬出来的坑中。 1、全局异常处理spring boot支持配置全局异常处理，记录未捕获的全局异常，这样方便在问题发生时快速定位问题，配置方式如下：12345678910111213141516@ControllerAdvicepublic class GlobalDefaultExceptionHandler &#123; private static Logger logger = LoggerFactory.getLogger(GlobalDefaultExceptionHandler.class); @ExceptionHandler(value = Exception.class) @ResponseBody public Map&lt;String, Object&gt; defaultErrorHandler(HttpServletRequest req,HttpServletResponse response, Exception e) &#123; logger.error(\"defaultErrorHandler:\", e); response.setStatus(500); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"code\", \"-1000\"); map.put(\"msg\", \"系统繁忙\"); return map; &#125;&#125; 在类上添加@ControllerAdvice注释 根据异常类型创建不同的方法，在方法上添加@ExceptionHandler注解，value的值是具体的异常类型 defaultErrorHandler方法的返回值可以是String（view路径),Map(json结构，需添加@ResponseBody注解) response状态需要设置，否则前端看到的会是正常的200，根据具体的异常来设置，如无权限返回403等，两种设置方式，response.setStatus(500) 或者 @ResponseStatus(value=HttpStatus.INTERNAL_SERVER_ERROR)注解 2、for、while循环异常处理在for、while循环内是否需要进行异常捕获应该根据循环体的业务来确定，当一次循环过程中发生异常时，是否要终止循环，这是你使用循环时不能忽略的一点。 如以下场景： APP批量上传用户启动、使用事件，循环将每条数据处理后放入kafka队列：每次循环都是一个独立的处理过程，一次循环发生异常时不希望终止整个循环，类似的场景循环内部就需要进行异常捕获，从而避免一条数据的异常导致整批数据一起失败； 批量删除用户，全部成功，否则回滚：业务需求是整个批次的数据全部成功，一个失败整体失败，那么就不需要在循环体内部进行异常捕获了，可以在循环体外或依赖全局异常处理来记录异常信息； 在循环内部捕获异常，特别是while循环时，要注意循环终止条件，不要出现无限循环记录日志，导致磁盘写满的情况。 3、代码段异常处理完成一件事情，需要执行很多步处理，编程时我们通常使用一个空行来分割不同的“步”以使程序看起来更有调理，每一步的操作可以定义为一个粗粒度的“代码段”。一个代码段是否需要进行异常捕获，同样是有代码的业务来确定，当异常发生时，是否需要终止整个处理流程是判断的标准。 如以下场景： 用户调用A接口，接口A包含三个代码段，参数校验-&gt;请求信息放入kafka-&gt;返回请求结果：第二步“请求信息放入kafka”对整个接口来说属于附加操作，当它发生异常时不应该影响用户正常获取数据，故此该代码段需要添加异常捕获，避免非核心业务的异常影响核心业务的执行。 用户调用B接口，接口B包含是哪个代码段，参数校验-&gt;创建用户信息—&gt;创建用户账号信息,第二步和第三步任何一个发生异常，都会导致整个操作失败，这种场景就不能单纯的捕获异常，那样会导致数据的不一致。 4、异常日志记录异常日志要记录在日志文件内，一定不要简单的将日志打印到控制台（测试环境一个tomcat放了十几个项目，如果都打印到控制台…）,在项目后期可以全局搜索System.out和System.err，并向对应人员指出。spring boot内建议使用logback作为日志组件，日志的使用可参考sprign boot项目实战:日志; 5、总结 项目内建议配置全局异常捕获，有利于问题排查； 单次循环发生异常是否应该终止循环？不要忽略这个的问题； 注意循环终止条件，避免出现无限循环记录日志的情况 一个代码段发生异常是否要终止整个处理流程？同样不要忽略这个问题； 异常日志最好记录在日志文件内，不要简单的打印到控制台 《spring boot项目实战》之异常处理，本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"异常处理","slug":"异常处理","permalink":"http://www.onecoderspace.com/tags/异常处理/"}]},{"title":"boot项目实战：事务","slug":"spring-boot-transaction","date":"2017-10-01T00:04:38.000Z","updated":"2017-10-01T11:04:20.000Z","comments":true,"path":"2017/10/01/spring-boot-transaction/","link":"","permalink":"http://www.onecoderspace.com/2017/10/01/spring-boot-transaction/","excerpt":"事务在项目里也是不可或缺的一部分，建议形成一个统一的事务管理规范，不要出现让程序员根据业务自行添加，团队成员能力有高有低，很容易就出现需要事务时没添加事务，这种问题又很难测试出来，运行时却会不定时出现数据的不一致。","text":"事务在项目里也是不可或缺的一部分，建议形成一个统一的事务管理规范，不要出现让程序员根据业务自行添加，团队成员能力有高有低，很容易就出现需要事务时没添加事务，这种问题又很难测试出来，运行时却会不定时出现数据的不一致。想实现类似原spring项目里通过aop方式配置事务的效果，各种尝试，目前还未找到十分可行的方式。测试可用的事务配置方式有两种：在service上添加@Transactional注解 和 引入xml配置文件（不推荐），建议使用@Transactional注解来进行事务配置。 1、@Transactional实现事务spring boot项目内使用事务最简单直接的方式就是在每个service类上添加@Transactional注解，即可自动开启对事务的支持，不需要进行额外操作。 1@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED) 该注解也可添加在方法上，对事物进行更精细化的管理，注意引用spring包下的，不要引用javax包下的。 2、引入xml配置实现事务1、 创建com.onecoderspace.transaction.xml文件12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd\" default-lazy-init=\"false\" default-autowire=\"no\"&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.jpa.JpaTransactionManager\" /&gt; &lt;!-- 对于service使用annotation声明事物 --&gt; &lt;tx:annotation-driven mode=\"proxy\" proxy-target-class=\"true\" transaction-manager=\"transactionManager\" order=\"100\" /&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"insert*\" isolation=\"REPEATABLE_READ\" /&gt; &lt;tx:method name=\"save*\" isolation=\"REPEATABLE_READ\" /&gt; &lt;tx:method name=\"update*\" isolation=\"REPEATABLE_READ\" /&gt; &lt;tx:method name=\"del*\" isolation=\"REPEATABLE_READ\" /&gt; &lt;tx:method name=\"do*\" isolation=\"REPEATABLE_READ\" /&gt; &lt;tx:method name=\"*\" isolation=\"REPEATABLE_READ\" read-only=\"true\" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config proxy-target-class=\"true\"&gt; &lt;aop:advisor pointcut=\"execution(* com.onecoderspace..*.service..*.*(..))\" advice-ref=\"txAdvice\" order=\"200\" /&gt; &lt;/aop:config&gt;&lt;/beans&gt;2、引入xml配置文件12345@Configuration@ImportResource(\"classpath:com.onecoderspace.transaction.xml\")public class AopTransactionConfig &#123; &#125; 3、小结 service层需要统一添加事务，避免部分人员忘记事务处理，在运行过程中导致数据不一致； 在每个service上添加注解实现事务：定好项目整体事务隔离级别和传播属性即可在项目级别形成规范，胜在简单，可执行性更高，目前本公司使用该方式； 在service方法上添加注解实现事务：事务管理更灵活，更有针对性，缺点是难以形成统一规范，依赖编程人员的经验和能力，如果团队内存在经验不很充足的成员不推荐使用该方式； 通过引入xml配置实现事务：配置简单，在xml内一处配置即可实现事务管理，耦合性更低；缺点就是使用了xml配置，因此不太推荐使用该方式； 隔离级别（isolation）通常选择REPEATABLE_READ；传播属性通常使用默认值（REQUIRED）即可。 4、扩展阅读隔离级别（isolation）隔离级别是指若干个并发的事务之间的隔离程度，与我们开发时候主要相关的场景包括：脏读取、重复读、幻读。 我们可以看 org.springframework.transaction.annotation.Isolation 枚举类中定义了五个表示隔离级别的值：1234567public enum Isolation &#123; DEFAULT(-1), READ_UNCOMMITTED(1), READ_COMMITTED(2), REPEATABLE_READ(4), SERIALIZABLE(8);&#125; DEFAULT ：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是： READ_COMMITTED，mysql5.6默认是REPEATABLE-READ，可以通过select @@tx_isolation查看。 READ_UNCOMMITTED ：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。 READ_COMMITTED ：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 REPEATABLE_READ ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。 SERIALIZABLE ：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 传播属性（propagation）所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。 我们可以看 org.springframework.transaction.annotation.Propagation 枚举类中定义了6个表示传播行为的枚举值：123456789public enum Propagation &#123; REQUIRED(0), SUPPORTS(1), MANDATORY(2), REQUIRES_NEW(3), NOT_SUPPORTED(4), NEVER(5), NESTED(6);&#125; REQUIRED ：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。 SUPPORTS ：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 MANDATORY ：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 REQUIRES_NEW ：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 NOT_SUPPORTED ：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 NEVER ：以非事务方式运行，如果当前存在事务，则抛出异常。 NESTED ：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 REQUIRED 。 如有更好实现方式，敬请指出。 本文为《spring boot项目实战》系列之事务使用，系列文章持续更新，另外，本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"事务","slug":"事务","permalink":"http://www.onecoderspace.com/tags/事务/"}]},{"title":"前端实战：详情页返回列表内容缓存及定位实现","slug":"前端实战：详情页返回列表内容缓存及定位实现","date":"2017-09-26T12:45:21.000Z","updated":"2017-09-26T13:07:50.000Z","comments":true,"path":"2017/09/26/前端实战：详情页返回列表内容缓存及定位实现/","link":"","permalink":"http://www.onecoderspace.com/2017/09/26/前端实战：详情页返回列表内容缓存及定位实现/","excerpt":"实现目标当前浏览到第N页，点击某一个新闻，进入新闻详情页，点击返回时，列表数据不重新加载，焦点仍定位在进入详情页之前的位置。","text":"实现目标当前浏览到第N页，点击某一个新闻，进入新闻详情页，点击返回时，列表数据不重新加载，焦点仍定位在进入详情页之前的位置。 思路 缓存列表内已展示的数据； 进入详情页时在缓存内添加该新闻的ID（键为articleId）； 返回时在js内判断缓存内是否包含articleId，如果存在，则通过缓存的列表数据进行页面渲染； 通过articleId定位元素，滚动窗口值该元素处； 缓存不能始终存在。 根据当前项目情况，考虑缓存放入sessionStorage，滚动窗口使用IScroll。 实现方案1、缓存列表数据 123456789101112131415//cacheKey 缓存key cacheValue 缓存内容json结构 position 值为before和after分别用于加载最新和加载下一页 function addToCache(cacheKey,cacheValue,position)&#123; cacheValue = JSON.stringify(cacheValue); var allCacheData = sessionStorage.getItem(cacheKey); if(allCacheData != null)&#123; if(position == \"before\")&#123; allCacheData = cacheValue + \"::::\" +allCacheData; &#125; else &#123; allCacheData = allCacheData + \"::::\" + cacheValue; &#125; &#125; else &#123; allCacheData = cacheValue; &#125; sessionStorage.setItem(cacheKey,allCacheData); &#125; sessionStorage只能存储字符串，需要将json结构的对象转为字符串进行存储 如果列表数据特别多，应该和业务确认缓存数据条数，截取仅是字符串操作，这里不再展开 2、进入详情页123$(\".article\").click(function()&#123; sessionStorage.setItem(\"articleId\",$(this).attr(\"id\")); &#125;) 在每条新闻上绑定事件，点击时设置文章ID至缓存，正常来说在详情页设置，但是因为这个项目内的详情页不是我们部门的，所以只能在列表页设置； 3、返回时列表内js判断是从详情页返回的还是一次新的访问123456789var articleId = sessionStorage.getItem(\"articleId\"); var cacheData = sessionStorage.getItem($scope.initType); if(articleId != null &amp;&amp; cacheData != null)&#123; //从详情页返回且列表缓存数据不为空 showTableDataWithCache(cacheData,articleId); removeCache(\"articleId\");//注意使用一次就清理掉 &#125;else &#123; //一次新的访问，要清理掉所有相关缓存 removeAllFuturesCache(); loadPage(1); &#125;4、定位至对应元素1234567891011121314151617//注意IScroll需要重新初始化myScroll = new IScroll('#wrapper', &#123; probeType: 3, disableMouse: true, momentum: true, mouseWheel: true, disablePointer: true, click: true, tap: true, resizePolling: 1, // x &#125;);//滚动至对应元素myScroll.scrollToElement(document.querySelector(\"[id='\"+detailArticleId+\"']\"),10,true,true);initScroll();myScroll.refresh(); 注意IScroll需要重新初始化; scrollToElement的选择器格式是[id=’articleId’]而不是正常的”#articleId”;10 是动画时间 true true这样设置会将元素显示在窗口中间； 总结 sessionStorage是单个窗口级的缓存，同一个窗口内的数据可缓存在其内； IScroll可以作为页面滚动的组件； 详情页返回列表不刷新问题可以分解为三个小问题： 缓存列表数据 添加从详情页返回的标记（文章详情ID） 用缓存数据渲染页面后滚动窗口至对应元素通过sessionStorage存储数据，这样很多功能都可以实现，比如返回时标签选中等都是一样的思路，进入详情页时设置对应值，在页面加载时判断对应的缓存数据是否存在进而展开业务，这里不再展开。 参考：sessionStorage介绍IScroll使用","categories":[{"name":"前端","slug":"前端","permalink":"http://www.onecoderspace.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.onecoderspace.com/tags/前端/"},{"name":"列表数据缓存","slug":"列表数据缓存","permalink":"http://www.onecoderspace.com/tags/列表数据缓存/"},{"name":"详情页返回列表无刷新","slug":"详情页返回列表无刷新","permalink":"http://www.onecoderspace.com/tags/详情页返回列表无刷新/"},{"name":"html生成页面无法滚动","slug":"html生成页面无法滚动","permalink":"http://www.onecoderspace.com/tags/html生成页面无法滚动/"}]},{"title":"spring boot项目实战：跨域问题解决","slug":"spring-boot-cors","date":"2017-09-26T12:44:40.000Z","updated":"2017-10-01T10:58:43.000Z","comments":true,"path":"2017/09/26/spring-boot-cors/","link":"","permalink":"http://www.onecoderspace.com/2017/09/26/spring-boot-cors/","excerpt":"背景前后端分离架构，前端anglerjs，后端spring boot,使用shiro作为权限控制，已配置通用跨域请求支持。前端调用接口时部分情况正常，部分情况出现跨域请求不支持情况，错误信息如下：","text":"背景前后端分离架构，前端anglerjs，后端spring boot,使用shiro作为权限控制，已配置通用跨域请求支持。前端调用接口时部分情况正常，部分情况出现跨域请求不支持情况，错误信息如下：1Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'xxxx' is therefore not allowed access. 配置错了？首先，想到的就是对跨域请求支持的配置是错误的，尝试着替换不同的跨域支持配置，有以下几种：1、继承WebMvcConfigurerAdapter123456789101112@Configurationpublic class AppConfig extends WebMvcConfigurerAdapter &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\") .allowedOrigins(\"*\") .allowCredentials(true).allowedHeaders(\"Origin, X-Requested-With, Content-Type, Accept\") .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\", \"OPTIONS\") .maxAge(3600); &#125;&#125;2、配置WebMvcConfigurer123456789101112@Beanpublic WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\").allowedOrigins(\"*\") .allowedMethods(\"*\").allowedHeaders(\"*\") .allowCredentials(true) .exposedHeaders(HttpHeaders.SET_COOKIE).maxAge(3600L); &#125; &#125;;&#125;… CORS support in Spring Framework内的方式都尝试了一遍，发现问题仍然未解决，看到文档内的一个点 If you are using Spring Security, make sure to enable CORS at Spring Security level as well to allow it to leverage the configuration defined at Spring MVC level. 大概意思就是使用Spring Security要进行特殊的配置来支持CORS。而当前项目内使用的是shiro，是不是权限控制导致的问题?检查shiro相关代码，果然找到了问题，在loginFilter内会判断如果未登录，就通过response写回未登录提示，代码如下：1234567891011121314151617181920Subject subject = SecurityUtils.getSubject();if (!subject.isAuthenticated()) &#123; HttpServletResponse resp = (HttpServletResponse) response; String contentType = \"application/json\"; resp.setContentType(contentType); resp.setCharacterEncoding(\"UTF-8\"); Map&lt;String, String&gt; map = Maps.newLinkedHashMap(); map.put(\"code\", \"xxx\"); map.put(\"msg\", \"xxx\"); String result = JacksonHelper.toJson(map); PrintWriter out = resp.getWriter(); try&#123; out.print(result); out.flush(); &#125; finally &#123; out.close(); &#125; return;&#125;那就添加上跨域支持12resp.setHeader(\"Access-Control-Allow-Credentials\", \"true\");resp.setHeader(\"Access-Control-Allow-Origin\",request.getHeader(\"Origin\"));本来以为ok了，但是前端是不报错了，但并不能获得对应接口期望的结果，而是一直收到1&#123;\"code\":\"xxx\",\"msg\":\"xxx\"&#125;显然是被登录拦截了，但是明明已经登录，而且有的接口可以正常通过登录拦截，为什么部分接口会出现不能登录的情况呢？ 明明登录了，为什么被loginFilter拦截？遇到了问题就要想办法解决，首先就是怀疑客户端sessionId未被正常保存，在loginFilter内添加日志打印sessionID，发现每次的sessionID都不一样，问题清晰了一些，前端并未正确的保持登录状态，对比前端两个调用接口的代码，发现正常的是get请求，post请求不正常，通过在网上搜索，发现ajax post跨域请求时，默认是不携带浏览器的cookie的，也就是每次请求都会生成一个新的session，因此post请求都被登录拦截。解决办法如下：12345678910111213$.ajax(&#123; type:\"POST\", url:\"\", data:&#123;&#125;, crossDomain:true, xhrFields: &#123; withCredentials: true &#125;, success:function(data)&#123; &#125;, error:function(data)&#123; &#125;&#125;)配置crossDomain:true 和 xhrFields: { withCredentials: true }就可以让请求正常携带cookie。 一个完整可用方案1、配置支持跨域请求（多种方式自由选择，推荐使用下面的方式）12345678910111213141516171819@Configurationpublic class WebConfig &#123; /** * 跨域请求支持 */ @Bean public WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\").allowedOrigins(\"*\") .allowedMethods(\"*\").allowedHeaders(\"*\") .allowCredentials(true) .exposedHeaders(HttpHeaders.SET_COOKIE).maxAge(3600L); &#125; &#125;; &#125;&#125;2、前端ajax post请求时添加xhrFields: { withCredentials: true }12345678910111213$.ajax(&#123; type:\"POST\", url:\"\", data:&#123;&#125;, crossDomain:true, xhrFields: &#123; withCredentials: true &#125;, success:function(data)&#123; &#125;, error:function(data)&#123; &#125;&#125;)3、检查权限控制代码，看是否有特殊处理的地方，未添加跨域支持。如上文所提，登录拦截直接通过response写回未登录提示；使用spring-security框架时也要添加特殊配置，如下：12345678@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.cors().and()... &#125;&#125; 解决跨域的本质就是在返回头内添加Access-Control-Allow-Origin，实现方式有多种，spring体系内解决跨域可参考CORS support in Spring Framework,很全面的介绍了各种场景。使用权限框架时，要注意权限框架本身的CORS支持。 《spring boot项目实战》之跨域处理，本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"CORS","slug":"CORS","permalink":"http://www.onecoderspace.com/tags/CORS/"},{"name":"跨域","slug":"跨域","permalink":"http://www.onecoderspace.com/tags/跨域/"},{"name":"ajax post跨域","slug":"ajax-post跨域","permalink":"http://www.onecoderspace.com/tags/ajax-post跨域/"}]},{"title":"sprign boot项目实战：日志","slug":"spring-boot-log","date":"2017-09-26T12:43:59.000Z","updated":"2017-10-01T10:59:03.000Z","comments":true,"path":"2017/09/26/spring-boot-log/","link":"","permalink":"http://www.onecoderspace.com/2017/09/26/spring-boot-log/","excerpt":"日志是运维、排错的一个重要助手，很多人应该都维护过没有日志的项目，知道排查问题是什么感觉。所以搭建基础项目框架时，自然不能少了日志。","text":"日志是运维、排错的一个重要助手，很多人应该都维护过没有日志的项目，知道排查问题是什么感觉。所以搭建基础项目框架时，自然不能少了日志。 日志组件选择从网上各种搜索对比，在log4j2和logback之间选择了log4j2,综合各处评价，log4j2在性能方法有一定优势。但是在一个项目内使用后就发现，spring boot内log4j2不支持spring profile机制，也就是在本地环境、测试环境、预发布环境、正式环境需要手动切换配置，当前公司的多个环境在相同的服务器上，所以这种方式会导致多个环境的日志生成在了同一个文件内，很不利于问题排查。因此又将日志组件换回了logback，因为对当前公司的项目来说，日志支持profile机制更重要，性能瓶颈绝不在日志这块。 logback配置spring boot内配置logback还是很简单的，只需要在src/main/resources目录下创建logback-spring.xml，在xml内添加自己的日志配置即可。支持三个环境local、dev、prod的日志配置如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration scan=\"true\" scanPeriod=\"30 seconds\"&gt; &lt;property name=\"LOG_PATH\" value=\"/mnt/diskb/logs\"/&gt; &lt;springProfile name=\"local\"&gt; &lt;logger name=\"com.onecoderspace\" level=\"debug\" additivity=\"true\"/&gt; &lt;appender name=\"logfile\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ssS&#125; %5p [%c]:%L-%m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;/springProfile&gt; &lt;springProfile name=\"dev\"&gt; &lt;logger name=\"com.onecoderspace\" level=\"info\" additivity=\"true\"/&gt; &lt;appender name=\"logfile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;$&#123;LOG_PATH&#125;/projectName/projectName_dev.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ssS&#125; %5p [%c&#123;5&#125;#%M]:%L-%m%n%caller&#123;0&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- daily rollover --&gt; &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/projectName/projectName_dev.%d&#123;yyyy-MM-dd&#125;.log.gz &lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;/springProfile&gt; &lt;springProfile name=\"prod\"&gt; &lt;logger name=\"com.onecoderspace\" level=\"info\" additivity=\"true\"/&gt; &lt;appender name=\"logfile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;$&#123;LOG_PATH&#125;/projectName/projectName.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ssS&#125; %5p [%c&#123;5&#125;#%M]:%L-%m%n%caller&#123;0&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- daily rollover --&gt; &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/projectName/projectName.%d&#123;yyyy-MM-dd&#125;.log.gz &lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;/springProfile&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"logfile\" /&gt; &lt;/root&gt;&lt;/configuration&gt;spring-boot-starter-web内已经包含了logback和slf4j的依赖，所以只要项目依赖了spring-boot-starter-web，就不需要做其他额外的配置了。 日志使用调用日志时建议使用slf4j，虽然基本不会在后续变更日志组件，但使用slf4j是一个好的习惯。123import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static Logger logger = LoggerFactory.getLogger(LoginController.class);debug日志debug日志建议添加logger.isDebugEnabled()判断，在重要的流程上都留下日志，这样当系统出现问题时，可以通过debug日志，快速定位问题，能代替很多断点调试的时间。1234 if(logger.isDebugEnabled())&#123; logger.debug(\"user=&#123;&#125; login success\",username);&#125;info日志比较重要的信息，对于系统运行有比较重要的参考意义，同时不会对性能造成影响，可以在正式环境展示的信息，使用info基本打印，如定时任务运行时间等。1logger.info(\"end fetcher proxy use time=&#123;&#125;\", System.currentTimeMillis()- t);error日志error日志相对来说是最重要的，但使用时需要注意使用方式，不正确的方式会导致很多信息被隐藏。可以参考如下方式：12 logger.error(String.format(\"error msg ,arg1=%s,arg2=%s\",arg1,arg2), e); 尽可能的带上异常发生时的参数，这个对排查问题很有意义 打印异常的完整堆栈信息，仅打印e.getMessage()会导致很多信息被隐藏 只在异常发生时或明确的业务错误时使用error，不要用error来打印调试、普通信息 总结 spring boot项目内日志组件选择logback比较好，内嵌的日志组件，支持profile机制； logback配置方式为在src/main/resources目录下创建logback-spring.xml，配置内容参考上文； 调用日志时使用slf4j，注意合理使用日志级别 注意以下几点tips tips1、 应用日志尽量放在数据盘上，不要放在系统盘上，遇到了不止一次日志写满系统盘导致服务暂停的情况2、 技术负责人定好日志规范，在代码review时指出几次日志使用的问题，能够很快让良好使用日志成为团队的习惯3、 正式环境的日志基本最低为info，通常可以调整为warn或error4、 在while循环内有异常捕获时，注意当异常发生时，不能无限打印日志，如下代码：123456789101112131415 while (flag) &#123; try &#123; byte[] bb = _queue.poll(1, TimeUnit.SECONDS); if (bb != null) &#123; @SuppressWarnings(\"unchecked\") Map&lt;String, Object&gt; m = JacksonSupport.decode1(new ByteArrayInputStream(bb), Map.class); E event = _consumer.getEventType().newInstance(); event.fromMap(m); _consumer.onEvent(event); &#125; &#125; catch (Exception e) &#123; logger.error(\"redis queue poll due to error\", e); &#125;&#125;从基于redis开发的一个blockingQueue内获取元素进行消费，代码运行了一年多十分正常，但是有一次几乎把磁盘写满了，因为当时运维调整，redis停掉了， _queue.poll这里就开始抛异常，然后下面就狂写日志，一直把磁盘写满。类似这样的地方，可以进行一个计数，连续错误达到多少次，就终止循环并以某些方式提醒运维人员。5、不要使用System.out.println()，建议隔段时间全局搜索一次，发现了就在小组会议上提一下，很快这种现象就会杜绝 《spring boot项目实战》之日志使用，本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"日志","slug":"日志","permalink":"http://www.onecoderspace.com/tags/日志/"},{"name":"spring profile","slug":"spring-profile","permalink":"http://www.onecoderspace.com/tags/spring-profile/"}]},{"title":"spring boot实战","slug":"spring-boot项目实战：目录","date":"2017-09-25T13:43:52.000Z","updated":"2017-10-01T11:10:21.000Z","comments":true,"path":"2017/09/25/spring-boot项目实战：目录/","link":"","permalink":"http://www.onecoderspace.com/2017/09/25/spring-boot项目实战：目录/","excerpt":"最近基于spring boot搭建了一套公司后端接口项目基础框架，方便公司后续项目的快速开发。本系列博客从实际开发项目所需功能的角度，逐功能点的讲述实现方式，最终完成一个可以直接用于公司项目开发的基础框架。让大家对于使用spring boot开发项目有一个更直观、全面的认识，也让小伙伴们少踩几个我掉过的坑，更愉快的加入spring boot的阵营。","text":"最近基于spring boot搭建了一套公司后端接口项目基础框架，方便公司后续项目的快速开发。本系列博客从实际开发项目所需功能的角度，逐功能点的讲述实现方式，最终完成一个可以直接用于公司项目开发的基础框架。让大家对于使用spring boot开发项目有一个更直观、全面的认识，也让小伙伴们少踩几个我掉过的坑，更愉快的加入spring boot的阵营。项目包含的基础功能有： spring boot项目基础结构 持久层框架：JPA 公共方法提取：service、dao、model 权限控制：shiro spring boot实战：跨域支持：CORS spring boot项目实战：redis spring boot实战：日志 spring boot实战：事务 安全：xss、CSRF、SQL注入 基于redis的分布式锁 常用工具类（日期、http、集合操作、文件操作、json、加密、ognl等） spring-boot实战：共享session spring boot项目实战：swagger2在线文档 代码生成器：code-generator 应用监控：Spring Boot Actuator JSP支持 额外推荐一个很不错的博客，我入门都是在上面看的。程序员DD|博客 本文为《spring boot项目实战》系列之目录篇，系列文章持续更新，另外，本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"CORS","slug":"CORS","permalink":"http://www.onecoderspace.com/tags/CORS/"},{"name":"日志","slug":"日志","permalink":"http://www.onecoderspace.com/tags/日志/"},{"name":"redis","slug":"redis","permalink":"http://www.onecoderspace.com/tags/redis/"},{"name":"spring-session","slug":"spring-session","permalink":"http://www.onecoderspace.com/tags/spring-session/"},{"name":"事务","slug":"事务","permalink":"http://www.onecoderspace.com/tags/事务/"},{"name":"spring-boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/tags/spring-boot实战/"},{"name":"web基础框架","slug":"web基础框架","permalink":"http://www.onecoderspace.com/tags/web基础框架/"},{"name":"异常","slug":"异常","permalink":"http://www.onecoderspace.com/tags/异常/"},{"name":"接口文档","slug":"接口文档","permalink":"http://www.onecoderspace.com/tags/接口文档/"},{"name":"权限控制","slug":"权限控制","permalink":"http://www.onecoderspace.com/tags/权限控制/"},{"name":"跨域支持","slug":"跨域支持","permalink":"http://www.onecoderspace.com/tags/跨域支持/"},{"name":"安全","slug":"安全","permalink":"http://www.onecoderspace.com/tags/安全/"},{"name":"xss","slug":"xss","permalink":"http://www.onecoderspace.com/tags/xss/"},{"name":"CSRF","slug":"CSRF","permalink":"http://www.onecoderspace.com/tags/CSRF/"},{"name":"缓存","slug":"缓存","permalink":"http://www.onecoderspace.com/tags/缓存/"},{"name":"JPA","slug":"JPA","permalink":"http://www.onecoderspace.com/tags/JPA/"},{"name":"分布式锁","slug":"分布式锁","permalink":"http://www.onecoderspace.com/tags/分布式锁/"},{"name":"shiro","slug":"shiro","permalink":"http://www.onecoderspace.com/tags/shiro/"}]},{"title":"web项目高效开发","slug":"高效开发","date":"2017-09-24T06:26:20.000Z","updated":"2017-09-24T13:23:10.000Z","comments":true,"path":"2017/09/24/高效开发/","link":"","permalink":"http://www.onecoderspace.com/2017/09/24/高效开发/","excerpt":"从事开发工作五年多，参与、带的项目几十个，中间也思考过怎么提高项目的开发速度和质量，也陆续尝试了一些方法，最近稍有空闲，就系统梳理、自我总结一把，主要有以下几点： 理清需求再动手，不要后期需求变更、代码补丁打的自己酸爽无比 减少模板代码的copy开发，能自动生成的自动生成 提取自己公司的模板项目，配合代码生成器生成40%以上的模板代码 生成规范可用的文档，减少文档维护工作 自动构建部署项目 规范日志，提升运维效率思路就是“通用的东西进行提取，能自动生成的东西自动生成，让程序员专心写业务代码”。","text":"从事开发工作五年多，参与、带的项目几十个，中间也思考过怎么提高项目的开发速度和质量，也陆续尝试了一些方法，最近稍有空闲，就系统梳理、自我总结一把，主要有以下几点： 理清需求再动手，不要后期需求变更、代码补丁打的自己酸爽无比 减少模板代码的copy开发，能自动生成的自动生成 提取自己公司的模板项目，配合代码生成器生成40%以上的模板代码 生成规范可用的文档，减少文档维护工作 自动构建部署项目 规范日志，提升运维效率思路就是“通用的东西进行提取，能自动生成的东西自动生成，让程序员专心写业务代码”。 1、理清需求功能点多，技术难度大对程序员来说正常，加班干活也没啥怨言，完成了心中还有点成就感，但几个功能点翻来覆去的调整个三五次，那90%的人估计都已经在心里问候项目经理了。有些需求变更是难免的，但更多的是可以通过合适的管理、设计来避免的，特别是小公司的技术负责人（如我）更应该注意”想清楚要做什么比立马思考怎么做更重要“，你在开始设计时跑偏一些，忘记一些，就意味着之后的某个时间团队集体狼狈的加班，这里有几点小经验分享给大军： 认真阅读需求文档，在心里构画出整个网站的全景图，任何一个分支小道都不忽视 提出问题，让需求人员想的更多一点 自己将对需求的认识向需求+团队成员讲一遍 负责某一模块的团队成员复述一下对需求的认识 2、项目模板项目内有很多底层通用的东西，特别是一个公司内容的项目，不同项目间共性的东西更多，很多时候开发也是copy一个项目，把原来的业务功能删减，有类似功能的再从不同项目里copy过来。这种情况将共性代码提出为一个base项目，后续项目都直接在base项目的基础上开发，明显会更舒爽很多。目前使用spring-boot搭建了一个后端web接口开发的模板项目，后续也会在《spring boot项目实战》系列文章进行分享。 3、代码生成代码生成器的原理就是读取表结构，生成对应的模板代码，所以开发一个项目先进行数据库设计。一、数据库设计有段时间设计数据库使用excel，后面发现修改、维护、查看都不怎么方便，现在在使用免费的workbench进行数据库设计，软件操作还算顺手，能够简单的体现模块、表之间的关系。在这方面根据个人感觉，用着顺手就行，建议使用专业的软件，excel之类的从效果上来说的确有一定的差距。建议每个字段都设置好注释，字段命名多个单词用下划线分割。 二、代码生成器本人开发了一个代码生成器，功能有： 生成指定数据库内所有表对应的模板代码（实体、dao、service、controller） 生成指定数据库内指定表对应的模板代码（实体、dao、service、controller）原理是通过sql查询数据内有哪些数据库，数据库内有哪些表，表里面的字段信息，然后通过freemarker来生成模板代码，如有需要可根据该项目调整对应的模板生成自己公司的代码。GitHub: https://github.com/q7322068/code-generation 4、在线文档生成公司项目是前后端分离的架构，刚开始都是通过excel来提供接口文档给前端，后来维护起来实在是太麻烦，调整了就要改excel，多个人维护起来，很快就乱套了，后来决定使用swagger2来构建在线api文档，以代码的形式来维护，代码调整时添加上指定格式的注释就能自动生成接口文档，前端通过在线文档来查看，配合起来更舒服。使用请参考：Spring Boot中使用Swagger2构建强大的RESTful API文档简化Swagger使用的自制Starter：spring-boot-starter-swagger，欢迎使用和吐槽spring-boot-starter-swagger 1.3.0.RELEASE：新增对JSR-303的支持和host的配置 5、自动构建代码开发好了，总是要在服务器上部署运行的，我现在的公司采用Jenkins来完成自动打包部署，提交svn代码，Jenkins自动打包（支持war包、jar包）部署至测试环境，预发布环境和正式环境基于测试环境的代码进行发布（通过脚本进行发布，实际上就是遍历某个文件夹下的文件，选择后进行copy）。 6、日志很重要刚到现在公司的时候，接手的项目日志千奇百怪，有打印到控制台的，有日志未生效的，有自己写到某个文件的（你没看错），加上项目文档严重缺失，有过类似体验的兄弟知道是啥感觉。所以抽取基础项目时直接定好日志规范，在规定目录下生成日志，日志完备了，日常运维也就简单了。 总结 提取一套基础框架，把该有的组件、工具类都放进去 设计数据库、代码生成，这样model、dao、service、controller都有了，注意啊比较完备的在线注释已经存在了^_^ 使用Jenkins自动构建发布，部署项目再也不需要自己上去svn up，ps,kill等一系列操作了； 日志很重要很重要，没日志的日子很难过滴希望这篇文章能诱发点你的“懒病”，每天只写“爽”的代码，想要懒就只能先勤快，为你的开发打造点顺手的武器吧。","categories":[{"name":"java实战","slug":"java实战","permalink":"http://www.onecoderspace.com/categories/java实战/"}],"tags":[{"name":"java实战 spirng-boot 项目高效开发 自动构建 代码生成","slug":"java实战-spirng-boot-项目高效开发-自动构建-代码生成","permalink":"http://www.onecoderspace.com/tags/java实战-spirng-boot-项目高效开发-自动构建-代码生成/"}]}]}