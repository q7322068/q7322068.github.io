{"meta":{"title":"足迹|成长之路","subtitle":"实战经验梳理，分享与你，分享与自己！","description":"spring boot，spring cloud，微服务，java web编程实战","author":"杨文魁","url":"http://www.onecoderspace.com"},"pages":[{"title":"","date":"2017-09-16T03:13:44.000Z","updated":"2017-09-16T03:13:13.000Z","comments":true,"path":"5435542637.html","permalink":"http://www.onecoderspace.com/5435542637.html","excerpt":"","text":""},{"title":"","date":"2017-09-15T15:27:58.000Z","updated":"2017-09-15T15:27:58.000Z","comments":true,"path":"404.html","permalink":"http://www.onecoderspace.com/404.html","excerpt":"","text":""},{"title":"关于我","date":"2017-09-10T12:49:14.000Z","updated":"2017-09-10T13:18:59.000Z","comments":true,"path":"about/index.html","permalink":"http://www.onecoderspace.com/about/index.html","excerpt":"","text":"有志之人立长志，无志之人常立志 杨文魁一个程序猿技术上，主要从事java web开发，一直在中小公司工作，对于系统设计、数据库设计、代码开发、前端、部署都有较多的经验。但怎么说呢，各个地方都会，但很少有大并发、大数据量的实践场景，对于技术的掌握也感觉没有达到很精深的程度，希望能在后续的时间内梳理自己过往实践中用过的技术、解决的问题，总结过往，找到深入研究的方向，在技术上继续提升自己的能力。 近期博客里会写一系列最近在开发中用到的spring boot,spring cloud等技术，从项目实战的角度来来阐述这些技术的使用及中间遇到的各种大大小小的问题。"}],"posts":[{"title":"spring boot项目实战：分布式锁","slug":"spring-boot-distributed-lock","date":"2017-10-04T01:03:32.000Z","updated":"2017-10-04T11:31:41.000Z","comments":true,"path":"2017/10/04/spring-boot-distributed-lock/","link":"","permalink":"http://www.onecoderspace.com/2017/10/04/spring-boot-distributed-lock/","excerpt":"在部分情况下，要保证操作在整个集群内是同步的，以操作库存为例，多个减操作需要同步，常见的有两种方式： 采用类CAS的方式，先查询库存，然后使用update xxx set num=num-1 where num=:num;这样可保证库在本次修改之前未被修改； 使用分布式锁，保证同时只有一个地方在修改库存。","text":"在部分情况下，要保证操作在整个集群内是同步的，以操作库存为例，多个减操作需要同步，常见的有两种方式： 采用类CAS的方式，先查询库存，然后使用update xxx set num=num-1 where num=:num;这样可保证库在本次修改之前未被修改； 使用分布式锁，保证同时只有一个地方在修改库存。 这里向大家展示一个基于redis的分布式锁。主要涉及三个类： DistributedLockUtil对外提供获取分布式锁的方法； DistributedLock 分布式锁接口，定义分布式锁支持的方法，主要有acquire和release； JedisLock实现DistributedLock接口，是基于redis的分布锁实现 ； 需要使用StringRedisTemplate，如对spring boot整合redis不熟悉，请参考spring boot项目实战：redis. DistributedLock接口123456789101112131415161718192021public interface DistributedLock &#123; /** * 获取锁 * @author yangwenkui * @time 2016年5月6日 上午11:02:54 * @return * @throws InterruptedException */ public boolean acquire(); /** * 释放锁 * @author yangwenkui * @time 2016年5月6日 上午11:02:59 */ public void release(); &#125; JedisLock基于redis的分布式锁实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public class JedisLock implements DistributedLock&#123; private static Logger logger = LoggerFactory.getLogger(JedisLock.class); private static StringRedisTemplate redisTemplate; /** * 分布式锁的键值 */ String lockKey; //锁的键值 int expireMsecs = 10 * 1000; //锁超时，防止线程在入锁以后，无限的执行等待 int timeoutMsecs = 10 * 1000; //锁等待，防止线程饥饿 boolean locked = false; //是否已经获取锁 /** * 获取指定键值的锁 * @param lockKey 锁的键值 */ public JedisLock(String lockKey) &#123; this.lockKey = lockKey; &#125; /** * 获取指定键值的锁,同时设置获取锁超时时间 * @param lockKey 锁的键值 * @param timeoutMsecs 获取锁超时时间 */ public JedisLock(String lockKey, int timeoutMsecs) &#123; this.lockKey = lockKey; this.timeoutMsecs = timeoutMsecs; &#125; /** * 获取指定键值的锁,同时设置获取锁超时时间和锁过期时间 * @param lockKey 锁的键值 * @param timeoutMsecs 获取锁超时时间 * @param expireMsecs 锁失效时间 */ public JedisLock(String lockKey, int timeoutMsecs, int expireMsecs) &#123; this.lockKey = lockKey; this.timeoutMsecs = timeoutMsecs; this.expireMsecs = expireMsecs; &#125; public String getLockKey() &#123; return lockKey; &#125; /** * * @return true if lock is acquired, false acquire timeouted * @throws InterruptedException * in case of thread interruption */ public synchronized boolean acquire() &#123; int timeout = timeoutMsecs; if(redisTemplate == null)&#123; redisTemplate = SpringContextUtil.getBean(StringRedisTemplate.class); &#125; try &#123; while (timeout &gt;= 0) &#123; long expires = System.currentTimeMillis() + expireMsecs + 1; String expiresStr = String.valueOf(expires); //锁到期时间 if (redisTemplate.opsForValue().setIfAbsent(lockKey, expiresStr)) &#123; // lock acquired locked = true; return true; &#125; String currentValueStr = redisTemplate.opsForValue().get(lockKey); //redis里的时间 if (currentValueStr != null &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123; //判断是否为空，不为空的情况下，如果被其他线程设置了值，则第二个条件判断是过不去的 // lock is expired String oldValueStr = redisTemplate.opsForValue().getAndSet(lockKey, expiresStr); //获取上一个锁到期时间，并设置现在的锁到期时间， //只有一个线程才能获取上一个线上的设置时间，因为jedis.getSet是同步的 if (oldValueStr != null &amp;&amp; oldValueStr.equals(currentValueStr)) &#123; //如过这个时候，多个线程恰好都到了这里，但是只有一个线程的设置值和当前值相同，他才有权利获取锁 // lock acquired locked = true; return true; &#125; &#125; timeout -= 100; Thread.sleep(100); &#125; &#125; catch (Exception e) &#123; logger.error(\"release lock due to error\",e); &#125; return false; &#125; /** * 释放锁 */ public synchronized void release() &#123; if(redisTemplate == null)&#123; redisTemplate = SpringContextUtil.getBean(StringRedisTemplate.class); &#125; try &#123; if (locked) &#123; String currentValueStr = redisTemplate.opsForValue().get(lockKey); //redis里的时间 //校验是否超过有效期，如果不在有效期内，那说明当前锁已经失效，不能进行删除锁操作 if (currentValueStr != null &amp;&amp; Long.parseLong(currentValueStr) &gt; System.currentTimeMillis()) &#123; redisTemplate.delete(lockKey); locked = false; &#125; &#125; &#125; catch (Exception e) &#123; logger.error(\"release lock due to error\",e); &#125; &#125;&#125; DistributedLockUtil1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class DistributedLockUtil&#123; /** * 获取分布式锁 * 默认获取锁10s超时，锁过期时间60s * @author yangwenkui * @time 2016年5月6日 下午1:30:46 * @return */ public static DistributedLock getDistributedLock(String lockKey)&#123; lockKey = assembleKey(lockKey); JedisLock lock = new JedisLock(lockKey); return lock; &#125; /** * 正式环境、测试环境共用一个redis时，避免key相同造成影响 * @author yangwenkui * @param lockKey * @return */ private static String assembleKey(String lockKey) &#123; return String.format(\"lock_%s\",lockKey ); &#125; /** * 获取分布式锁 * 默认获取锁10s超时，锁过期时间60s * @author yangwenkui * @time 2016年5月6日 下午1:38:32 * @param lockKey * @param timeoutMsecs 指定获取锁超时时间 * @return */ public static DistributedLock getDistributedLock(String lockKey,int timeoutMsecs)&#123; lockKey = assembleKey(lockKey); JedisLock lock = new JedisLock(lockKey,timeoutMsecs); return lock; &#125; /** * 获取分布式锁 * 默认获取锁10s超时，锁过期时间60s * @author yangwenkui * @time 2016年5月6日 下午1:40:04 * @param lockKey 锁的key * @param timeoutMsecs 指定获取锁超时时间 * @param expireMsecs 指定锁过期时间 * @return */ public static DistributedLock getDistributedLock(String lockKey,int timeoutMsecs,int expireMsecs)&#123; lockKey = assembleKey(lockKey); JedisLock lock = new JedisLock(lockKey,expireMsecs,timeoutMsecs); return lock; &#125; &#125; 使用示例123456789101112DistributedLock lock = DistributedLockUtil.getDistributedLock(key);try &#123; if (lock.acquire()) &#123; //获取锁成功业务代码 &#125; else &#123; // 获取锁失败 //获取锁失败业务代码&#125; finally &#123; if (lock != null) &#123; lock.release(); &#125;&#125; 实现原理简析主要是依赖redis的setnx和getset命令对时间进行操作，从而实现锁的功能。以下两个文章对分布式锁进行了极其明细的分析，会让你对分布式锁的认识更加清晰。《基于Redis的分布式锁到底安全吗（上）？》《基于Redis的分布式锁到底安全吗（下）？》 注意事项 基于redis的分布式锁依赖于系统时钟，需要保证各个竞争者的时钟的一致性，否则会出现一个参与者获得锁，而另一个参与者的时钟判断其已过期，导致分布式锁失效； 需要保证redis节点的高可用，建议使用哨兵机制； 在使用分布式锁之前，考虑是否可以通过乐观锁或无锁解决并发同步问题，毕竟使用锁的代价很是比较高昂的；","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"分布式锁，redis","slug":"分布式锁，redis","permalink":"http://www.onecoderspace.com/tags/分布式锁，redis/"}]},{"title":"spring boot项目实战：JPA","slug":"spring-boot-jpa","date":"2017-10-03T05:45:38.000Z","updated":"2017-10-03T13:46:28.000Z","comments":true,"path":"2017/10/03/spring-boot-jpa/","link":"","permalink":"http://www.onecoderspace.com/2017/10/03/spring-boot-jpa/","excerpt":"公司的项目中很大一部分属于内部平台，所以对性能的要求没有那么高，开发速度反而更重要，因此在搭建基础框架时选择使用JPA，没有使用mybitis，当然其中也有一部分原因是之前一直使用hibernate，对mybitis不太熟悉^_^。","text":"公司的项目中很大一部分属于内部平台，所以对性能的要求没有那么高，开发速度反而更重要，因此在搭建基础框架时选择使用JPA，没有使用mybitis，当然其中也有一部分原因是之前一直使用hibernate，对mybitis不太熟悉^_^。 一、配置JPA1、添加maven依赖123456789101112&lt;!-- jpa --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 2、 添加数据库配置12345678910111213141516171819spring.jpa.database = MYSQL# Hibernate ddl auto (create, create-drop, update)spring.jpa.hibernate.ddl-auto = update# Naming strategyspring.jpa.hibernate.naming-strategy = org.hibernate.cfg.ImprovedNamingStrategy# stripped before adding them to the entity manager)spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect# Show or not log for each sql queryspring.jpa.show-sql = truespring.datasource.url=jdbc:mysql://localhost:3306/base?characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=rootspring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.max-active=3spring.datasource.max-idle=1spring.datasource.min-idle=1spring.datasource.initial-size=1 3、dao继承上层类12345678910public interface UserDao extends BaseDao&lt;User, Integer&gt;&#123; User findByUsernameAndDel(String username, int del);&#125;@NoRepositoryBeanpublic interface BaseDao&lt;T,ID extends Serializable&gt; extends JpaSpecificationExecutor&lt;T&gt;,JpaRepository&lt;T, ID&gt;&#123;&#125;为了便于使用，提取了一个BaseDao，需要注意的是要在上层类上添加@ NoRepositoryBean注解。BaseDao继承JpaRepository和JpaSpecificationExecutor，JpaRepository提供了基本的crud等查询方法，JpaSpecificationExecutor提供了对复杂查询的支持。 完成了以上三步，已经可以在service内注入dao，通过dao进行数据库curd等操作。 二、JPA查询1、 根据方法名实现查询1234567891011//根据用户名和标记删除字段查询对应的用户信息User findByUsernameAndDel(String username, int del);//根据code查询对应的角色Role findByCode(String code);//根据id集合查询对应的角色集合Set&lt;Role&gt; findByIdIn(Set&lt;Integer&gt; roleIds);//根据用户id，查询用户角色关系记录List&lt;UserRole&gt; findByUserId(int uid); 简单查询可以通过以上方式方便的实现，简化了很多dao层的代码，使用着还是很爽的，具体规则比较简单，基本上就是findBy开始，后续跟上实体属性，中间配以And、Or、In、like等组成方法名，也就是用方法名来描述查询规则。如果是嵌套对象，可以通过“_”来区分子对象的属性，比如findByCompany_name(String name)就是以子对象company内的name属性为查询条件。常用查询关键字如下： And — 等价于 SQL 中的 and 关键字，比如findByUsernameAndPassword(String user, Striang pwd)； Or — 等价于 SQL 中的 or 关键字，比如findByUsernameOrAddress(String user, String addr)； Between — 等价于 SQL 中的 between 关键字，比如 findBySalaryBetween(int max, int min)； LessThan — 等价于 SQL 中的 “&lt;”，比如 findBySalaryLessThan(int max)； GreaterThan — 等价于 SQL 中的”&gt;”，比如 findBySalaryGreaterThan(int min)； IsNull — 等价于 SQL 中的 “is null”，比如 findByUsernameIsNull()； IsNotNull — 等价于 SQL 中的 “is not null”，比如 findByUsernameIsNotNull()； NotNull — 与 IsNotNull 等价； Like — 等价于 SQL 中的 “like”，比如 findByUsernameLike(String user)； NotLike — 等价于 SQL 中的 “not like”，比如 findByUsernameNotLike(String user)； OrderBy — 等价于 SQL 中的 “order by”，比如 findByUsernameOrderBySalaryAsc(String user)； Not — 等价于 SQL 中的 “！ =”，比如 findByUsernameNot(String user)； In — 等价于 SQL 中的 “in”，比如findByUsernameIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数； NotIn — 等价于 SQL 中的 “not in”，比如 findByUsernameNotIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数； 2、使用@Query查询类HQL语句1234@Query(\"select u from User u where u.username = ?1\") public AccountInfo findByAccountId(String username); 在@Query内直接书写HQL语句即可，参数可通过”?1,?2”这样的方式设置，下标从1开始。 原生sql查询123456789@Query(value=\"select perm.* from role_permission rp left join permission perm on rp.permission_id=perm.id where rp.role_id in(?1);\",nativeQuery=true)List&lt;Permission&gt; listByRoleIds(Set&lt;Integer&gt; roles);//根据userId删除用户角色关系@Query(value = \"delete from user_role where user_id=?1 \", nativeQuery = true) @Modifyingvoid deleleByUserId(int uid);使用也比较简单，将@Query内的nativeQuery设置为true即可。写SQL语句时，可以现在本地mysql客户端上测试号SQL语句的正确性，当需要索引时，创建合适的索引。在此基础上看下SQL的性能，如不理想，需调整SQL，可使用explain对SQL语句进行分析，查询执行逻辑，针对性优化。 新增、修改直接调用dao的save方法，支持单个保存和批量保存。 删除直接调用dao的delete方法，支持根据id、对象、对象集合等删除方式，使用时查看下提示方法就可以了。 3、分页查询不带条件分页查询123Pageable pageable = new PageRequest(0, 10, new Sort(Direction.DESC, \"updateTime\"));Page&lt;User&gt; page = userDao.findAll(pageable); 使用PageRequest构建分页请求对象，页码下标从0开始 多条件复杂分页查询带条件分页查询有两种方式： 使用原生SQL进行分页查询，但是前提是多个查询条件必须同时存在，不能有不生效的条件，比如用户列表，用户姓名可以不作为过滤条件，这种情况原生SQL就不适用了，需要使用下面第二种方式 使用Specification进行复杂查询，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public Page&lt;User&gt; listByPage(final Map&lt;String, String&gt; params,Pageable pageable)&#123; Specification&lt;User&gt; spec = new Specification&lt;User&gt;() &#123; @Override public Predicate toPredicate(Root&lt;User&gt; root,CriteriaQuery&lt;?&gt; query,CriteriaBuilder cb) &#123; List&lt;Predicate&gt; list = new ArrayList&lt;Predicate&gt;(); String type = params.get(\"type\"); String status= params.get(\"status\"); String username = params.get(\"username\"); String name = params.get(\"name\"); if(StringUtils.isNotBlank(type))&#123; list.add(cb.equal(root.get(\"type\").as(Integer.class), NumberUtils.toInt(type))); &#125; if(StringUtils.isNotBlank(status))&#123; list.add(cb.equal(root.get(\"status\").as(Integer.class), NumberUtils.toInt(status))); &#125; if(StringUtils.isNotBlank(username))&#123; list.add(cb.like(root.get(\"username\").as(String.class), String.format(\"%%%s%%\", username))); &#125; if(StringUtils.isNotBlank(name))&#123; list.add(cb.like(root.get(\"name\").as(String.class), String.format(\"%%%s%%\", name))); &#125; list.add(cb.equal(root.get(\"del\"), Constants.DEL_NO)); Predicate[] p = new Predicate[list.size()]; return cb.and(list.toArray(p)); //in条件查询 /*List&lt;Integer&gt; ids = Lists.newArrayList(); ids.add(1); ids.add(2); In&lt;Integer&gt; in = cb.in(root.get(\"id\").as(Integer.class)); in.value(1); in.value(2); return cb.or(in);*/ &#125; &#125;; Page&lt;User&gt; page = userDao.findAll(spec, pageable); 根据以上示例，基本满足了常用的查询需求，更多情况可根据规则尝试一下即可，也可百度搜索下JPA Specification，有很多教程。 简化多条件分页查询使用Specification需要每次都写一大段模板代码，使用起来还是比较繁琐，使用入门也有些难度，基于此，在service层的公共代码出对查询进行了部分封装，简化常见多条件分页查询。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174/** * 分页多条件查询 * 注：多个条件间是and关系 &amp; 参数是属性对应的类型 * @author yangwk * @time 2017年8月1日 下午3:50:46 * @param params &#123;\"username:like\":\"test\"&#125; 键的格式为字段名:过滤方式,过滤方式见&#123;@code QueryTypeEnum&#125; * @param pageable 分页信息 new PageRequest(page, size,new Sort(Direction.DESC, \"updateTime\")) * @return */Page&lt;T&gt; list(Map&lt;String, Object&gt; params,Pageable pageable);@Overridepublic Page&lt;T&gt; list(final Map&lt;String, Object&gt; params,Pageable pageable)&#123; Specification&lt;T&gt; spec = new Specification&lt;T&gt;() &#123; @Override public Predicate toPredicate(Root&lt;T&gt; root,CriteriaQuery&lt;?&gt; query,CriteriaBuilder cb) &#123; List&lt;Predicate&gt; list = new ArrayList&lt;Predicate&gt;(); for(Entry&lt;String, Object&gt; entry : params.entrySet())&#123; Object value = entry.getValue(); if(value == null || StringUtils.isBlank(value.toString()))&#123; continue; &#125; String key = entry.getKey(); String[] arr = key.split(\":\"); Predicate predicate = getPredicate(arr,value,root,cb); list.add(predicate); &#125; Predicate[] p = new Predicate[list.size()]; return cb.and(list.toArray(p)); &#125; &#125;; Page&lt;T&gt; page = getDAO().findAll(spec, pageable); return page;&#125;private Predicate getPredicate(String[] arr, Object value, Root&lt;T&gt; root, CriteriaBuilder cb) &#123; if(arr.length == 1)&#123; return cb.equal(root.get(arr[0]).as(value.getClass()), value); &#125; if(QueryTypeEnum.like.name().equals(arr[1]))&#123; return cb.like(root.get(arr[0]).as(String.class), String.format(\"%%%s%%\", value)); &#125; if(QueryTypeEnum.ne.name().equals(arr[1]))&#123; return cb.notEqual(root.get(arr[0]).as(value.getClass()), value); &#125; if(QueryTypeEnum.lt.name().equals(arr[1]))&#123; return getLessThanPredicate(arr,value,root,cb); &#125; if(QueryTypeEnum.lte.name().equals(arr[1]))&#123; return getLessThanOrEqualToPredicate(arr,value,root,cb); &#125; if(QueryTypeEnum.gt.name().equals(arr[1]))&#123; return getGreaterThanPredicate(arr,value,root,cb); &#125; if(QueryTypeEnum.gte.name().equals(arr[1]))&#123; return getGreaterThanOrEqualToPredicate(arr,value,root,cb); &#125; throw new UnsupportedOperationException(String.format(\"不支持的查询类型[%s]\",arr[1]));&#125;private Predicate getLessThanPredicate(String[] arr, Object value, Root&lt;T&gt; root, CriteriaBuilder cb) &#123; if(Integer.class == value.getClass())&#123; return cb.lessThan(root.get(arr[0]).as(Integer.class), (int)value); &#125; if(Long.class == value.getClass())&#123; return cb.lessThan(root.get(arr[0]).as(Long.class), (long)value); &#125; if(Double.class == value.getClass())&#123; return cb.lessThan(root.get(arr[0]).as(Double.class), (double)value); &#125; if(Float.class == value.getClass())&#123; return cb.lessThan(root.get(arr[0]).as(Float.class), (float)value); &#125; if(Timestamp.class == value.getClass())&#123; return cb.lessThan(root.get(arr[0]).as(Timestamp.class), (Timestamp)value); &#125; if(Date.class == value.getClass())&#123; return cb.lessThan(root.get(arr[0]).as(Date.class), (Date)value); &#125; return cb.lessThan(root.get(arr[0]).as(String.class), String.valueOf(value));&#125;private Predicate getLessThanOrEqualToPredicate(String[] arr, Object value, Root&lt;T&gt; root, CriteriaBuilder cb) &#123; if(Integer.class == value.getClass())&#123; return cb.lessThanOrEqualTo(root.get(arr[0]).as(Integer.class), (int)value); &#125; if(Long.class == value.getClass())&#123; return cb.lessThanOrEqualTo(root.get(arr[0]).as(Long.class), (long)value); &#125; if(Double.class == value.getClass())&#123; return cb.lessThanOrEqualTo(root.get(arr[0]).as(Double.class), (double)value); &#125; if(Float.class == value.getClass())&#123; return cb.lessThanOrEqualTo(root.get(arr[0]).as(Float.class), (float)value); &#125; if(Timestamp.class == value.getClass())&#123; return cb.lessThanOrEqualTo(root.get(arr[0]).as(Timestamp.class), (Timestamp)value); &#125; if(Date.class == value.getClass())&#123; return cb.lessThanOrEqualTo(root.get(arr[0]).as(Date.class), (Date)value); &#125; return cb.lessThanOrEqualTo(root.get(arr[0]).as(String.class), String.valueOf(value));&#125;private Predicate getGreaterThanPredicate(String[] arr, Object value, Root&lt;T&gt; root, CriteriaBuilder cb) &#123; if(Integer.class == value.getClass())&#123; return cb.greaterThan(root.get(arr[0]).as(Integer.class), (int)value); &#125; if(Long.class == value.getClass())&#123; return cb.greaterThan(root.get(arr[0]).as(Long.class), (long)value); &#125; if(Double.class == value.getClass())&#123; return cb.greaterThan(root.get(arr[0]).as(Double.class), (double)value); &#125; if(Float.class == value.getClass())&#123; return cb.greaterThan(root.get(arr[0]).as(Float.class), (float)value); &#125; if(Timestamp.class == value.getClass())&#123; return cb.greaterThan(root.get(arr[0]).as(Timestamp.class), (Timestamp)value); &#125; if(Date.class == value.getClass())&#123; return cb.greaterThan(root.get(arr[0]).as(Date.class), (Date)value); &#125; return cb.greaterThan(root.get(arr[0]).as(String.class), String.valueOf(value));&#125;private Predicate getGreaterThanOrEqualToPredicate(String[] arr,Object value, Root&lt;T&gt; root, CriteriaBuilder cb) &#123; if(Integer.class == value.getClass())&#123; return cb.greaterThanOrEqualTo(root.get(arr[0]).as(Integer.class), (int)value); &#125; if(Long.class == value.getClass())&#123; return cb.greaterThanOrEqualTo(root.get(arr[0]).as(Long.class), (long)value); &#125; if(Double.class == value.getClass())&#123; return cb.greaterThanOrEqualTo(root.get(arr[0]).as(Double.class), (double)value); &#125; if(Float.class == value.getClass())&#123; return cb.greaterThanOrEqualTo(root.get(arr[0]).as(Float.class), (float)value); &#125; if(Timestamp.class == value.getClass())&#123; return cb.greaterThanOrEqualTo(root.get(arr[0]).as(Timestamp.class), (Timestamp)value); &#125; if(Date.class == value.getClass())&#123; return cb.greaterThanOrEqualTo(root.get(arr[0]).as(Date.class), (Date)value); &#125; return cb.lessThanOrEqualTo(root.get(arr[0]).as(String.class), String.valueOf(value));&#125; @ApiModel(value=\"查询条件支持的过滤方式\")public enum QueryTypeEnum &#123; like, equal, ne, lt, lte, gt, gte&#125;//使用示例Map&lt;String, Object&gt; params = Maps.newHashMap();params.put(\"type\", type);params.put(\"status\", status);params.put(\"username:like\", username);params.put(\"name:like\", name);Page&lt;User&gt; rs = this.userService.list(params, new PageRequest(page, size, new Sort(Direction.DESC, \"updateTime\"))); 提前公共list方法，查询条件在map内设置，查询条件在key内设置，这样大部分的查询请求就可以不再关注Specification的语法，不用写那一大段的复杂代码了 小结 配置JPA很简单，添加maven依赖，配置数据库连接信息，dao继承上层类即可在service内注入dao，进行crud等操作 JPA提供了简便的根据方法名称进行查询的方式，使用难度很低 JPA通过@Query注解，支持类HQL语句查询；也可以使用原生SQL查询，只需要将nativeQuery属性设置为true即可 无条件分页查询可通过自带的findAll方法即可 多条件分页查询，有两种实现方式，当每个条件都是必选时，可使用@query带分页条件来实现；当有可选条件时，需要使用Specification来实现 为了简化常见的多个可选条件分页查询的代码，在service层提供了一个上层方法，以map的方式设置查询条件，大部分情况下不需要程序员再关注Specification的语法，降低使用难度 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"JPA","slug":"JPA","permalink":"http://www.onecoderspace.com/tags/JPA/"}]},{"title":"git最简教程","slug":"git-simple","date":"2017-10-03T03:11:35.000Z","updated":"2017-10-03T13:50:24.000Z","comments":true,"path":"2017/10/03/git-simple/","link":"","permalink":"http://www.onecoderspace.com/2017/10/03/git-simple/","excerpt":"git新手，最近上传个项目，下载个项目老是忘记命令，在这写一下最常用的几个命令。","text":"git新手，最近上传个项目，下载个项目老是忘记命令，在这写一下最常用的几个命令。 本地新建文件夹，如rest-base cd rest-base git init //初始化仓库 git remote add origin git@github.com:q7322068/rest-base.git //连接远程仓库，需要在github内创建ssh公钥，配置方式参考GitHub添加公钥 如果配置远程仓库的地址错误，可以使用git remote rm origin git pull origin master //从远程库同步项目，如果远程项目和本地有冲突，可以在后面添加 –allow-unrelated-histories实现 git add . //本地有修改，用该命令添加至暂存区 git commit -m ‘msg’ //将修改提交至本地git仓库 git push origin master //将本地修改提交至远程仓库 深入学习建议看廖雪峰Git教程.","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://www.onecoderspace.com/tags/git/"}]},{"title":"spring-boot项目实战：shiro","slug":"spring-boot-shiro","date":"2017-10-02T05:31:52.000Z","updated":"2017-10-04T11:42:12.000Z","comments":true,"path":"2017/10/02/spring-boot-shiro/","link":"","permalink":"http://www.onecoderspace.com/2017/10/02/spring-boot-shiro/","excerpt":"有很长一段时间都觉得自己添加个filter，基于RBAC模型，就能很轻松的实现权限控制，没必要引入shiro，spring-security这样的框架增加系统的复杂度。事实上也的确这样，如果你的需求仅仅是控制用户能否访问某个url，使用框架和自己实现filter效果基本一致，区别在于使用shiro和spring-security能够提供更多的扩展，集成了很多实用的功能，整体结构更加规范。","text":"有很长一段时间都觉得自己添加个filter，基于RBAC模型，就能很轻松的实现权限控制，没必要引入shiro，spring-security这样的框架增加系统的复杂度。事实上也的确这样，如果你的需求仅仅是控制用户能否访问某个url，使用框架和自己实现filter效果基本一致，区别在于使用shiro和spring-security能够提供更多的扩展，集成了很多实用的功能，整体结构更加规范。shiro和spring-security有哪些更多功能，这里不再展开，感兴趣的同学可以自行百度，我们这里以shiro为例，讲述spring-boot项目如何整合shiro实现权限控制。 1、添加maven依赖12345678910111213141516171819202122232425&lt;!--shiro-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; &lt;!-- 整合ehcache，减少数据库查询次数 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 2、添加shiro配置创建ShiroConfigration.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128@Configurationpublic class ShiroConfigration &#123; private static final Logger logger = LoggerFactory.getLogger(ShiroConfigration.class); private static Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;(); @Bean public SimpleCookie rememberMeCookie() &#123; SimpleCookie simpleCookie = new SimpleCookie(\"rememberMe\"); simpleCookie.setMaxAge(7 * 24 * 60 * 60);//保存10天 return simpleCookie; &#125; /** * cookie管理对象; */ @Bean public CookieRememberMeManager rememberMeManager() &#123; logger.debug(\"ShiroConfiguration.rememberMeManager()\"); CookieRememberMeManager cookieRememberMeManager = new CookieRememberMeManager(); cookieRememberMeManager.setCookie(rememberMeCookie()); cookieRememberMeManager.setCipherKey(Base64.decode(\"kPv59vyqzj00x11LXJZTjJ2UHW48jzHN\")); return cookieRememberMeManager; &#125; @Bean(name = \"lifecycleBeanPostProcessor\") public LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() &#123; return new LifecycleBeanPostProcessor(); &#125; @Bean public FilterRegistrationBean filterRegistrationBean() &#123; FilterRegistrationBean filterRegistration = new FilterRegistrationBean(); DelegatingFilterProxy proxy = new DelegatingFilterProxy(\"shiroFilter\"); // 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理 proxy.setTargetFilterLifecycle(true); filterRegistration.setFilter(proxy); filterRegistration.setEnabled(true); //filterRegistration.addUrlPatterns(\"/*\");// 可以自己灵活的定义很多，避免一些根本不需要被Shiro处理的请求被包含进来 return filterRegistration; &#125; @Bean public MyShiroRealm myShiroRealm() &#123; MyShiroRealm myShiroRealm = new MyShiroRealm(); return myShiroRealm; &#125; @Bean(name=\"securityManager\") public DefaultWebSecurityManager securityManager() &#123; DefaultWebSecurityManager manager = new DefaultWebSecurityManager(); manager.setRealm(myShiroRealm()); manager.setRememberMeManager(rememberMeManager()); manager.setCacheManager(ehCacheManager()); return manager; &#125; /** * ShiroFilterFactoryBean 处理拦截资源文件问题。 * 注意：单独一个ShiroFilterFactoryBean配置是或报错的，以为在 * 初始化ShiroFilterFactoryBean的时候需要注入：SecurityManager * &lt;p&gt; * Filter Chain定义说明 * 1、一个URL可以配置多个Filter，使用逗号分隔 * 2、当设置多个过滤器时，全部验证通过，才视为通过 * 3、部分过滤器可指定参数，如perms，roles */ @Bean(name = \"shiroFilter\") public ShiroFilterFactoryBean getShiroFilterFactoryBean() &#123; logger.debug(\"ShiroConfigration.getShiroFilterFactoryBean()\"); ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 必须设置 SecurityManager shiroFilterFactoryBean.setSecurityManager(securityManager()); HashMap&lt;String, javax.servlet.Filter&gt; loginFilter = new HashMap&lt;&gt;(); loginFilter.put(\"loginFilter\", new LoginFilter()); shiroFilterFactoryBean.setFilters(loginFilter); filterChainDefinitionMap.put(\"/login/submit\", \"anon\"); filterChainDefinitionMap.put(\"/logout\", \"anon\"); filterChainDefinitionMap.put(\"/img/**\", \"anon\"); filterChainDefinitionMap.put(\"/js/**\", \"anon\"); filterChainDefinitionMap.put(\"/css/**\", \"anon\"); filterChainDefinitionMap.put(\"/test/**\", \"anon\"); // 如果不设置默认会自动寻找Web工程根目录下的\"/login.jsp\"页面 shiroFilterFactoryBean.setLoginUrl(\"/login\"); //配置记住我或认证通过可以访问的地址 filterChainDefinitionMap.put(\"/\", \"user\"); //未授权界面; shiroFilterFactoryBean.setUnauthorizedUrl(\"/unauth\"); filterChainDefinitionMap.put(\"/**\", \"loginFilter\"); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return shiroFilterFactoryBean; &#125; /** * shiro缓存管理器; * 需要注入对应的其它的实体类中： * 1、安全管理器：securityManager * 可见securityManager是整个shiro的核心； * * @return */ @Bean public EhCacheManager ehCacheManager() &#123; EhCacheManager cacheManager = new EhCacheManager(); cacheManager.setCacheManagerConfigFile(\"classpath:ehcache-shiro.xml\"); return cacheManager; &#125; @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(DefaultWebSecurityManager securityManager) &#123; AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; &#125;&#125; shiroFilter是配置的重点， anon表示允许匿名访问 shiroFilterFactoryBean.setFilters(loginFilter)来设置自定义的过滤器，如本处设置了LoginFilter用于添加登录拦截 filterChainDefinitionMap.put(“/**”, “loginFilter”);用于指定loginFilter的作用范围 3、添加自定义realm创建类MyShiroRealm.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class MyShiroRealm extends AuthorizingRealm &#123; private static final Logger logger = LoggerFactory.getLogger(MyShiroRealm.class); @Autowired private UserService userService; @Autowired private UserRoleService userRoleService; @Autowired private RoleService roleService; @Autowired private RolePermissionService rolePermissionService; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //获取用户的输入的账号. String idObj = (String) token.getPrincipal(); Integer id = NumberUtils.toInt(idObj); User user = userService.findById(id); if (user == null) &#123; // 返回null的话，就会导致任何用户访问被拦截的请求时，都会自动跳转到unauthorizedUrl指定的地址 return null; &#125; SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(user.getId(), user.getPwd(), getName()); return authenticationInfo; &#125; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; /* * 当没有使用缓存的时候，不断刷新页面的话，这个代码会不断执行， * 当其实没有必要每次都重新设置权限信息，所以我们需要放到缓存中进行管理； * 当放到缓存中时，这样的话，doGetAuthorizationInfo就只会执行一次了， * 缓存过期之后会再次执行。 */ logger.debug(\"权限配置--&gt;MyShiroRealm.doGetAuthorizationInfo()\"); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); authorizationInfo.addRole(\"ACTUATOR\"); Integer userId = Integer.parseInt(principals.getPrimaryPrincipal().toString()); //实际项目中，这里可以根据实际情况做缓存，如果不做，Shiro自己也是有时间间隔机制，2分钟内不会重复执行该方法 Set&lt;Integer&gt; roleIds = userRoleService.findRoleIds(userId); Set&lt;Role&gt; roles = roleService.findByIds(roleIds); for(Role role : roles)&#123; authorizationInfo.addRole(role.getCode()); &#125; //设置权限信息. List&lt;Permission&gt; permissions = rolePermissionService.getPermissions(roleIds); Set&lt;String&gt; set = new HashSet&lt;String&gt;(permissions.size()*2); for(Permission permission : permissions)&#123; if(StringUtils.isNotBlank(permission.getCode()))&#123; set.add(permission.getCode()); &#125; &#125; authorizationInfo.setStringPermissions(set); return authorizationInfo; &#125;&#125; doGetAuthenticationInfo用于验证用户账号信息，可根据具体业务来调整认证策略 doGetAuthorizationInfo用于获取用户拥有的角色和权限 4、创建登录拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class LoginFilter implements Filter &#123; @Override public void destroy() &#123;&#125; @Override public void doFilter(ServletRequest request, ServletResponse response,FilterChain chain) throws IOException, ServletException &#123; Subject currentUser = SecurityUtils.getSubject(); if (!currentUser.isAuthenticated()) &#123; HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse res = (HttpServletResponse) response; AjaxResponseWriter.write(req, res, ServiceStatusEnum.UNLOGIN, \"请登录\"); return; &#125; chain.doFilter(request, response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123;&#125;&#125;public class AjaxResponseWriter &#123; /** * 写回数据到前端 * @param request * @param response * @param status &#123;@link ServiceStatusEnum&#125; * @param message 返回的描述信息 * @throws IOException */ public static void write(HttpServletRequest request,HttpServletResponse response,ServiceStatusEnum status,String message) throws IOException&#123; String contentType = \"application/json\"; response.setContentType(contentType); response.setCharacterEncoding(\"UTF-8\"); response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); response.setHeader(\"Access-Control-Allow-Origin\",request.getHeader(\"Origin\")); Map&lt;String, String&gt; map = Maps.newLinkedHashMap(); map.put(\"code\", status.code); map.put(\"msg\", message); String result = JacksonHelper.toJson(map); PrintWriter out = response.getWriter(); try&#123; out.print(result); out.flush(); &#125; finally &#123; out.close(); &#125; &#125;&#125;/** * 全局性状态码 * @author yangwk */public enum ServiceStatusEnum &#123; UNLOGIN(\"0001\"), //未登录 ILLEGAL_TOKEN(\"0002\"),//非法的token ; public String code; private ServiceStatusEnum(String code)&#123; this.code = code; &#125;&#125; 用户登录状态拦截器，不允许匿名访问的url会经过该filter，如果未登录，则返回未登录提示（未登录处理可根据具体业务进行调整） 5、添加登录、退出功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109@Api(value=\"用户登录\",tags=&#123;\"用户登录\"&#125;)@RestControllerpublic class LoginController &#123; private static Logger logger = LoggerFactory.getLogger(LoginController.class); @Value(\"$&#123;server.session.timeout&#125;\") private String serverSessionTimeout; /** * 用户登录接口 通过用户名和密码进行登录 */ @ApiOperation(value = \"用户登录接口 通过用户名和密码进行登录\", notes = \"用户登录接口 通过用户名和密码进行登录\") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = \"query\", name = \"username\", value = \"用户名\", required = true, dataType = \"String\"), @ApiImplicitParam(paramType = \"query\", name = \"pwd\", value = \"密码\", required = true, dataType = \"String\"), @ApiImplicitParam(paramType = \"query\", name = \"autoLogin\", value = \"自动登录\", required = true, dataType = \"boolean\")&#125;) @RequestMapping(value = \"/login/submit\",method=&#123;RequestMethod.GET,RequestMethod.POST&#125;) public Map&lt;String, String&gt; subm(HttpServletRequest request,HttpServletResponse response, String username,String pwd,@RequestParam(value = \"autoLogin\", defaultValue = \"false\") boolean autoLogin) &#123; Map&lt;String, String&gt; map = Maps.newLinkedHashMap(); Subject currentUser = SecurityUtils.getSubject(); User user = userService.findByUsername(username); if (user == null) &#123; map.put(\"code\", \"-1\"); map.put(\"description\", \"账号不存在\"); return map; &#125; if (user.getEnable() == 0) &#123; //账号被禁用 map.put(\"code\", \"-1\"); map.put(\"description\", \"账号已被禁用\"); return map; &#125; String salt = user.getSalt(); UsernamePasswordToken token = null; Integer userId = user.getId(); token = new UsernamePasswordToken(userId.toString(),SaltMD5Util.encode(pwd, salt)); token.setRememberMe(autoLogin); loginValid(map, currentUser, token); // 验证是否登录成功 if (currentUser.isAuthenticated()) &#123; map.put(\"code\",\"1\"); map.put(\"description\", \"ok\"); map.put(\"id\", String.valueOf(userId)); map.put(\"username\", user.getUsername()); map.put(\"name\", user.getName()); map.put(\"compnay_id\", String.valueOf(user.getCompanyId())); String uuidToken = UUID.randomUUID().toString(); map.put(\"token\", uuidToken); currentUser.getSession().setTimeout(NumberUtils.toLong(serverSessionTimeout, 1800)*1000); request.getSession().setAttribute(\"token\",uuidToken ); &#125; else &#123; map.put(\"code\", \"-1\"); token.clear(); &#125; return map; &#125; @RequestMapping(value=\"logout\",method=RequestMethod.GET) public Map&lt;String, String&gt; logout() &#123; Map&lt;String, String&gt; map = Maps.newLinkedHashMap(); Subject currentUser = SecurityUtils.getSubject(); currentUser.logout(); map.put(\"code\", \"logout\"); return map; &#125; @RequestMapping(value=\"unauth\",method=RequestMethod.GET) public Map&lt;String, String&gt; unauth() &#123; Map&lt;String, String&gt; map = Maps.newLinkedHashMap(); map.put(\"code\", \"403\"); map.put(\"msg\", \"你没有访问权限\"); return map; &#125; private boolean loginValid(Map&lt;String, String&gt; map,Subject currentUser, UsernamePasswordToken token) &#123; String username = null; if (token != null) &#123; username = (String) token.getPrincipal(); &#125; try &#123; // 在调用了login方法后,SecurityManager会收到AuthenticationToken,并将其发送给已配置的Realm执行必须的认证检查 // 每个Realm都能在必要时对提交的AuthenticationTokens作出反应 // 所以这一步在调用login(token)方法时,它会走到MyRealm.doGetAuthenticationInfo()方法中,具体验证方式详见此方法 currentUser.login(token); return true; &#125; catch (UnknownAccountException | IncorrectCredentialsException ex) &#123; map.put(\"description\", \"账号或密码错误\"); &#125; catch (LockedAccountException lae) &#123; map.put(\"description\",\"账户已锁定\"); &#125; catch (ExcessiveAttemptsException eae) &#123; map.put(\"description\", \"错误次数过多\"); &#125; catch (AuthenticationException ae) &#123; // 通过处理Shiro的运行时AuthenticationException就可以控制用户登录失败或密码错误时的情景 map.put(\"description\", \"登录失败\"); logger.warn(String.format(\"对用户[%s]进行登录验证..验证未通过\", username),ae); &#125; return false; &#125; @Autowired private UserService userService;&#125; 以上代码是比较通用的登录、退出功能，如果没有特殊需求，可直接使用上述功能 6、在接口上添加权限限制以UserController为例：12345678910111213141516171819202122232425262728293031323334@ApiOperation(value=\"获取用户详细信息\", notes=\"根据ID查找用户\") @ApiImplicitParam(paramType=\"query\",name = \"id\", value = \"用户ID\", required = true,dataType=\"int\")@RequiresPermissions(value=&#123;\"user:get\"&#125;) @RequestMapping(value=\"/get\",method=RequestMethod.GET)public User get(int id)&#123; User entity = userService.findById(id); entity.setPwd(null); entity.setSalt(null); return entity;&#125;@ApiOperation(value=\"修改密码\", notes=\"修改密码\")@ApiImplicitParams(&#123; @ApiImplicitParam(paramType = \"query\", name = \"oldPwd\", value = \"旧密码\", required = true, dataType = \"String\"), @ApiImplicitParam(paramType = \"query\", name = \"pwd\", value = \"新密码\", required = true, dataType = \"String\"), @ApiImplicitParam(paramType = \"query\", name = \"confirmPwd\", value = \"新密码(确认)\", required = true, dataType = \"String\")&#125;)@RequiresPermissions(value=&#123;\"user:reset-pwd\"&#125;)@RequestMapping(value=\"/reset-pwd\",method=RequestMethod.POST)public Return resetPwd(String oldPwd,String pwd,String confirmPwd)&#123; if(StringUtils.isBlank(oldPwd) || StringUtils.isBlank(pwd) || StringUtils.isBlank(confirmPwd) || !pwd.equals(confirmPwd)) &#123; return Return.fail(\"非法参数\"); &#125; Subject currentUser = SecurityUtils.getSubject(); Integer userId=(Integer) currentUser.getPrincipal(); User entity = userService.findById(userId); if(!entity.getPwd().equals(SaltMD5Util.encode(oldPwd, entity.getSalt())))&#123; return Return.fail(\"原始密码错误\"); &#125; return userService.changePwd(entity,pwd);&#125; @RequiresPermissions 和 @RequiresRoles分别用于限制该方法可访问的权限和角色，两者如果同时使用，默认是“&amp;”关系；两者的value参数都可以设置为数组，数组元素间的关系可以通过logical属性来设置，有Logical.AND，Logical.OR两个值可选择 小结spring-boot整合shiro的步骤如下： 添加maven依赖 添加ShiroConfigration配置，指定shiro的核心配置 添加MyShiroRealm，指定账户认证策略和角色权限获取方式 添加LoginFilter，即登录拦截器 添加登录、退出功能 通过注解添加接口调用权限限制 权限控制基于RBAC模型，涉及的表有：用户（user)、角色（role）、用户角色关系（user_role）、权限（permission）、角色权限关系（role_permission），具体代码可参考github内的示例项目。 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"权限控制","slug":"权限控制","permalink":"http://www.onecoderspace.com/tags/权限控制/"},{"name":"shiro","slug":"shiro","permalink":"http://www.onecoderspace.com/tags/shiro/"}]},{"title":"spring boot项目实战：redis","slug":"spring-boot-redis","date":"2017-10-01T10:47:10.000Z","updated":"2017-10-01T12:38:26.000Z","comments":true,"path":"2017/10/01/spring-boot-redis/","link":"","permalink":"http://www.onecoderspace.com/2017/10/01/spring-boot-redis/","excerpt":"缓存是提升服务性能的一个重要手段，而redis是分布式缓存中的佼佼者，性能优异，官方提供哨兵机制保证高可用，也支持集群方式，保证对大数据量的支持，项目内引入redis还是很有帮助的。","text":"缓存是提升服务性能的一个重要手段，而redis是分布式缓存中的佼佼者，性能优异，官方提供哨兵机制保证高可用，也支持集群方式，保证对大数据量的支持，项目内引入redis还是很有帮助的。 1、 添加maven依赖12345&lt;!-- redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2、 添加redis配置本地（单点redis）在application-local.properties（本地配置）内添加redis配置：1234567891011###redis配置###spring.redis.host=127.0.0.1 spring.redis.port=7001 spring.redis.database=0spring.redis.password=pwd# pool settings ...池配置 spring.redis.pool.max-idle=4spring.redis.pool.min-idle=1spring.redis.pool.max-active=4spring.redis.pool.max-wait=2000如果本地redis没有密码，删除spring.redis.password这行就可以了。 测试&amp;正式环境（哨兵）在application-dev.properties（测试环境）和application-prod.properties（正式环境）内添加redis配置：123456789101112131415 ###redis配置###spring.redis.database=0spring.redis.password=pwd # pool settings ...池配置 spring.redis.pool.max-idle=4spring.redis.pool.min-idle=1spring.redis.pool.max-active=4spring.redis.pool.max-wait=2000 #哨兵监听redis server名称 spring.redis.sentinel.master=mymaster#哨兵的配置列表 spring.redis.sentinel.nodes=host:port,host2:port2 3、使用StringRedisTemplate进行操作注入StringRedisTemplate：123 @Autowiredprivate StringRedisTemplate redisTemplate;使用RedisTemplate进行操作：12345678910111213141516//设置缓存，建议每个键都设置过期时间redisTemplate.opsForValue().set(\"test\", \"test\", 10, TimeUnit.SECONDS);//获取缓存值String value = redisTemplate.opsForValue().get(\"test\");//删除某个键redisTemplate.delete(\"test\");//操作setredisTemplate.opsForSet().add(\"testSet\", \"1\");Set&lt;String&gt; members = redisTemplate.opsForSet().members(\"testSet\");//获取set内的所有值redisTemplate.opsForSet().remove(\"testSet\", \"1\",\"2\");//移除set内的多个对象//操作listredisTemplate.opsForList().rightPush(\"testList\", \"1\");List&lt;String&gt; list = redisTemplate.opsForList().range(\"testList\", 0, -1);//获取list内的所有元素StringRedisTemplate对redis操作进行了很好的封装，为键、字符串、哈希、列表、集合、有序集合、HyperLogLog的操作提供了良好的支持。基本使用形式就是redisTemplate.opsForXXX,XXX是类型，opsForValue是操作字符串；opsForSet是操作集合，opsForList是操作列表，opsForZSet是操作有序集合，opsForHyperLogLog是操作HyperLogLog，基本上其方法和redis命令是对应的，可以根据名字和方法注释快速确定方法对应的redis命令。 4、使用RedisTemplate进行操作1、 创建RedisObjectSerializer.java12345678910111213141516171819202122232425262728293031323334353637import org.springframework.core.convert.converter.Converter;import org.springframework.core.serializer.support.DeserializingConverter;import org.springframework.core.serializer.support.SerializingConverter;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;public class RedisObjectSerializer implements RedisSerializer&lt;Object&gt; &#123; private Converter&lt;Object, byte[]&gt; serializer = new SerializingConverter(); private Converter&lt;byte[], Object&gt; deserializer = new DeserializingConverter(); static final byte[] EMPTY_ARRAY = new byte[0]; public Object deserialize(byte[] bytes) &#123; if (isEmpty(bytes)) &#123; return null; &#125; try &#123; return deserializer.convert(bytes); &#125; catch (Exception ex) &#123; throw new SerializationException(\"Cannot deserialize\", ex); &#125; &#125; public byte[] serialize(Object object) &#123; if (object == null) &#123; return EMPTY_ARRAY; &#125; try &#123; return serializer.convert(object); &#125; catch (Exception ex) &#123; return EMPTY_ARRAY; &#125; &#125; private boolean isEmpty(byte[] data) &#123; return (data == null || data.length == 0); &#125;&#125;2、 配置redisTemplate创建RedisConfig.java123456789101112@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setConnectionFactory(factory); template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(new RedisObjectSerializer()); return template; &#125;&#125;3、 使用RedisTemplate12345678910//注入RedisTemplate对象@Autowiredprivate RedisTemplate&lt;String, Object&gt; objRedisTemplate;//使用RedisTemplateUser user = new User();user.setId(1);user.setName(\"test\");objRedisTemplate.opsForValue().set(\"user\", user,10,TimeUnit.SECONDS);user = (User) objRedisTemplate.opsForValue().get(\"user\"); 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"redis","slug":"redis","permalink":"http://www.onecoderspace.com/tags/redis/"}]},{"title":"spring-boot项目实战：共享session","slug":"spring-boot-spring-session","date":"2017-10-01T01:42:04.000Z","updated":"2017-10-04T11:41:59.000Z","comments":true,"path":"2017/10/01/spring-boot-spring-session/","link":"","permalink":"http://www.onecoderspace.com/2017/10/01/spring-boot-spring-session/","excerpt":"在工作中会遇到以下几个场景： 发布新功能或修复bug，服务重启，用户需要重新登录 当集群内某个节点失效时，用户明明刚登录，仍被提示需要重新登录那如何做到服务发布、集群节点失效对用户无感知呢？有以下几种方式： 使用cookie保存用户状态信息 session同步法（多个web-server之间相互同步session） 后端统一存储（如：redis）","text":"在工作中会遇到以下几个场景： 发布新功能或修复bug，服务重启，用户需要重新登录 当集群内某个节点失效时，用户明明刚登录，仍被提示需要重新登录那如何做到服务发布、集群节点失效对用户无感知呢？有以下几种方式： 使用cookie保存用户状态信息 session同步法（多个web-server之间相互同步session） 后端统一存储（如：redis） 关于这几种方法的优缺点这里不再展开，可参看阅读《session一致性架构设计实践》,讲的很透彻，调理清晰。我们重点来看下如何通过后端统一存储来实现session共享，通过查找，发现了一个比较好的方案，spring-session，整合特别简单。1、在项目内引入redis参考我之前的一篇文档《spring boot项目实战：redis》，这里不再展开。 2、添加maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 3、添加java配置123456@Configuration @EnableRedisHttpSession(maxInactiveIntervalInSeconds=7200,redisNamespace=\"base\") public class RedisSessionConfig &#123;&#125; maxInactiveIntervalInSeconds用于设置session有效时间 redisNamespace用于区分不同的项目，如果多个项目共用用户数据，可以采用相同的值，这样就简单的实现了统一登录效果 要提醒的一点是如果用户数据特别大，需要注意redis容量规范及数据库规范，尽量保证缓存键分类存储在不同的库内，如用户session数据存储在数据库1内，业务缓存存储在0内，以此类推。 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"spring-session","slug":"spring-session","permalink":"http://www.onecoderspace.com/tags/spring-session/"},{"name":"共享session","slug":"共享session","permalink":"http://www.onecoderspace.com/tags/共享session/"}]},{"title":"spring boot项目实战：swagger2在线文档","slug":"spring-boot-swagger2","date":"2017-10-01T00:06:04.000Z","updated":"2017-10-01T12:38:53.000Z","comments":true,"path":"2017/10/01/spring-boot-swagger2/","link":"","permalink":"http://www.onecoderspace.com/2017/10/01/spring-boot-swagger2/","excerpt":"对于接口服务来说接口文档极其重要，在团队配合和后续维护中占据重要角色。在工作中，使用过excel，wiki来进行接口文档的维护：","text":"对于接口服务来说接口文档极其重要，在团队配合和后续维护中占据重要角色。在工作中，使用过excel，wiki来进行接口文档的维护： wiki：缺点是维护起来工作量较大，费时较长，优点是体验较好、检索方便、支持多人协作、支持历史版本查看； excel：初始整理时还好，但在后续多人协作新增功能或调整接口时，维护接口文档就变得极不方便 然后了解到swagger2，可以以编程的方式方便的生成在线文档，这样在接口调整时，能够及时的变更接口文档，使接口文档的准确性更高，下面来看下如何在spring boot项目内整合swagger2. 配置swagger21、 添加依赖1234567891011&lt;!-- swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;2、 添加基本配置123456789101112131415161718192021@Configuration@EnableSwagger2public class Swagger2 &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors .basePackage(\"com.onecoderspace.controller\")) .paths(PathSelectors.any()).build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(\"spring boot示例接口API\") .description(\"spring boot示例接口API\") .version(\"1.0\").build(); &#125;&#125; 通过@Configuration注解和@EnableSwagger2注解来启用Swagger2 basePackage：配置Swagger2需要扫描的包 3、 使用示例1234567891011121314151617181920212223242526272829@Api(tags=\"用户管理\",description=\"UserController\")@RestController@RequestMapping(\"/user\")public class UserController &#123; @ApiOperation(value = \"用户申请审核\", notes = \"用户申请审核\") @RequestMapping(value=\"/apply/audit\",method=RequestMethod.GET) public Return applyAudit() &#123; return Return.success(); &#125; @ApiOperation(value = \"获取用户详细信息\", notes = \"根据ID查找用户\") @ApiImplicitParam(paramType = \"query\", name = \"username\", value = \"用户名\", required = true, dataType = \"String\") @RequestMapping(value = \"/get\", method = RequestMethod.GET) public User get(String username) &#123; return null; &#125; @ApiOperation(value = \"修改用户信息\", notes = \"修改用户信息\") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = \"query\", name = \"user\", value = \"用户实体\", required = true, dataType = \"user\"), @ApiImplicitParam(paramType = \"query\", name = \"cname\", value = \"公司名称\", required = true, dataType = \"String\") &#125;) @RequestMapping(value = \"/save\", method = RequestMethod.POST) public Return save(User user, String cname, String curl) &#123; return Return.success(); &#125;&#125;在线文档显示效果如下： @Api:在类上添加注释，tags属性决定1处的内容，description决定2处的内容 @ApiOperation：在方法上添加注释，用于说明某个请求url的作用，value属性决定3处的内容，notes决定5处的内容 @ApiImplicitParam： 在方法上添加注释，用于说明某个请求参数的作用 @ApiImplicitParams多个参数时使用该注解 在实体字段添加@ApiModelProperty(value=”名称”)，生成该字段的说明 4、 注意事项 如果系统加入shiro等权限框架，那么访问swagger-ui.html需要有ACTUATOR角色，这个不要忘了配置 对于实体参数的支持不太好，保存更新时如果字段不是很多，建议使用属性的方式替代使用实体 swagger2是支持自定义页面的，如果觉得默认的样式不太适合，可以自定义前端页面，通过网络监控可以发现，所有数据是通过一个/v2/api-docs的请求获得的。 当接口较多时，swagger2也支持分组等配置，参考以下文档：spring-boot-starter-swagger 1.3.0.RELEASE：新增对JSR-303的支持和host的配置 相关阅读：swagger官网Spring Boot中使用Swagger2构建强大的RESTful API文档简化Swagger使用的自制Starter：spring-boot-starter-swagger，欢迎使用和吐槽 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"swagger2","slug":"swagger2","permalink":"http://www.onecoderspace.com/tags/swagger2/"},{"name":"在线接口文档","slug":"在线接口文档","permalink":"http://www.onecoderspace.com/tags/在线接口文档/"}]},{"title":"spring boot项目实战：异常处理","slug":"spring-boot-exception","date":"2017-10-01T00:04:58.000Z","updated":"2017-10-01T12:38:07.000Z","comments":true,"path":"2017/10/01/spring-boot-exception/","link":"","permalink":"http://www.onecoderspace.com/2017/10/01/spring-boot-exception/","excerpt":"异常处理是一个比较基础而又重要的技能点，在团队内最好形成一个统一的规则，避免团队成员不断掉进前辈已经爬出来的坑中。","text":"异常处理是一个比较基础而又重要的技能点，在团队内最好形成一个统一的规则，避免团队成员不断掉进前辈已经爬出来的坑中。 1、全局异常处理spring boot支持配置全局异常处理，记录未捕获的全局异常，这样方便在问题发生时快速定位问题，配置方式如下：12345678910111213141516@ControllerAdvicepublic class GlobalDefaultExceptionHandler &#123; private static Logger logger = LoggerFactory.getLogger(GlobalDefaultExceptionHandler.class); @ExceptionHandler(value = Exception.class) @ResponseBody public Map&lt;String, Object&gt; defaultErrorHandler(HttpServletRequest req,HttpServletResponse response, Exception e) &#123; logger.error(\"defaultErrorHandler:\", e); response.setStatus(500); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"code\", \"-1000\"); map.put(\"msg\", \"系统繁忙\"); return map; &#125;&#125; 在类上添加@ControllerAdvice注释 根据异常类型创建不同的方法，在方法上添加@ExceptionHandler注解，value的值是具体的异常类型 defaultErrorHandler方法的返回值可以是String（view路径),Map(json结构，需添加@ResponseBody注解) response状态需要设置，否则前端看到的会是正常的200，根据具体的异常来设置，如无权限返回403等，两种设置方式，response.setStatus(500) 或者 @ResponseStatus(value=HttpStatus.INTERNAL_SERVER_ERROR)注解 2、for、while循环异常处理在for、while循环内是否需要进行异常捕获应该根据循环体的业务来确定，当一次循环过程中发生异常时，是否要终止循环，这是你使用循环时不能忽略的一点。 如以下场景： APP批量上传用户启动、使用事件，循环将每条数据处理后放入kafka队列：每次循环都是一个独立的处理过程，一次循环发生异常时不希望终止整个循环，类似的场景循环内部就需要进行异常捕获，从而避免一条数据的异常导致整批数据一起失败； 批量删除用户，全部成功，否则回滚：业务需求是整个批次的数据全部成功，一个失败整体失败，那么就不需要在循环体内部进行异常捕获了，可以在循环体外或依赖全局异常处理来记录异常信息； 在循环内部捕获异常，特别是while循环时，要注意循环终止条件，不要出现无限循环记录日志，导致磁盘写满的情况。 3、代码段异常处理完成一件事情，需要执行很多步处理，编程时我们通常使用一个空行来分割不同的“步”以使程序看起来更有调理，每一步的操作可以定义为一个粗粒度的“代码段”。一个代码段是否需要进行异常捕获，同样是有代码的业务来确定，当异常发生时，是否需要终止整个处理流程是判断的标准。 如以下场景： 用户调用A接口，接口A包含三个代码段，参数校验-&gt;请求信息放入kafka-&gt;返回请求结果：第二步“请求信息放入kafka”对整个接口来说属于附加操作，当它发生异常时不应该影响用户正常获取数据，故此该代码段需要添加异常捕获，避免非核心业务的异常影响核心业务的执行。 用户调用B接口，接口B包含是哪个代码段，参数校验-&gt;创建用户信息—&gt;创建用户账号信息,第二步和第三步任何一个发生异常，都会导致整个操作失败，这种场景就不能单纯的捕获异常，那样会导致数据的不一致。 4、异常日志记录异常日志要记录在日志文件内，一定不要简单的将日志打印到控制台（测试环境一个tomcat放了十几个项目，如果都打印到控制台…）,在项目后期可以全局搜索System.out和System.err，并向对应人员指出。spring boot内建议使用logback作为日志组件，日志的使用可参考sprign boot项目实战:日志; 5、总结 项目内建议配置全局异常捕获，有利于问题排查； 单次循环发生异常是否应该终止循环？不要忽略这个的问题； 注意循环终止条件，避免出现无限循环记录日志的情况 一个代码段发生异常是否要终止整个处理流程？同样不要忽略这个问题； 异常日志最好记录在日志文件内，不要简单的打印到控制台 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"异常处理","slug":"异常处理","permalink":"http://www.onecoderspace.com/tags/异常处理/"}]},{"title":"boot项目实战：事务","slug":"spring-boot-transaction","date":"2017-10-01T00:04:38.000Z","updated":"2017-10-01T12:39:04.000Z","comments":true,"path":"2017/10/01/spring-boot-transaction/","link":"","permalink":"http://www.onecoderspace.com/2017/10/01/spring-boot-transaction/","excerpt":"事务在项目里也是不可或缺的一部分，建议形成一个统一的事务管理规范，不要出现让程序员根据业务自行添加，团队成员能力有高有低，很容易就出现需要事务时没添加事务，这种问题又很难测试出来，运行时却会不定时出现数据的不一致。","text":"事务在项目里也是不可或缺的一部分，建议形成一个统一的事务管理规范，不要出现让程序员根据业务自行添加，团队成员能力有高有低，很容易就出现需要事务时没添加事务，这种问题又很难测试出来，运行时却会不定时出现数据的不一致。想实现类似原spring项目里通过aop方式配置事务的效果，各种尝试，目前还未找到十分可行的方式。测试可用的事务配置方式有两种：在service上添加@Transactional注解 和 引入xml配置文件（不推荐），建议使用@Transactional注解来进行事务配置。 1、@Transactional实现事务spring boot项目内使用事务最简单直接的方式就是在每个service类上添加@Transactional注解，即可自动开启对事务的支持，不需要进行额外操作。 1@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED) 该注解也可添加在方法上，对事物进行更精细化的管理，注意引用spring包下的，不要引用javax包下的。 2、引入xml配置实现事务1、 创建com.onecoderspace.transaction.xml文件12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd\" default-lazy-init=\"false\" default-autowire=\"no\"&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.jpa.JpaTransactionManager\" /&gt; &lt;!-- 对于service使用annotation声明事物 --&gt; &lt;tx:annotation-driven mode=\"proxy\" proxy-target-class=\"true\" transaction-manager=\"transactionManager\" order=\"100\" /&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"insert*\" isolation=\"REPEATABLE_READ\" /&gt; &lt;tx:method name=\"save*\" isolation=\"REPEATABLE_READ\" /&gt; &lt;tx:method name=\"update*\" isolation=\"REPEATABLE_READ\" /&gt; &lt;tx:method name=\"del*\" isolation=\"REPEATABLE_READ\" /&gt; &lt;tx:method name=\"do*\" isolation=\"REPEATABLE_READ\" /&gt; &lt;tx:method name=\"*\" isolation=\"REPEATABLE_READ\" read-only=\"true\" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config proxy-target-class=\"true\"&gt; &lt;aop:advisor pointcut=\"execution(* com.onecoderspace..*.service..*.*(..))\" advice-ref=\"txAdvice\" order=\"200\" /&gt; &lt;/aop:config&gt;&lt;/beans&gt;2、引入xml配置文件12345@Configuration@ImportResource(\"classpath:com.onecoderspace.transaction.xml\")public class AopTransactionConfig &#123; &#125; 3、小结 service层需要统一添加事务，避免部分人员忘记事务处理，在运行过程中导致数据不一致； 在每个service上添加注解实现事务：定好项目整体事务隔离级别和传播属性即可在项目级别形成规范，胜在简单，可执行性更高，目前本公司使用该方式； 在service方法上添加注解实现事务：事务管理更灵活，更有针对性，缺点是难以形成统一规范，依赖编程人员的经验和能力，如果团队内存在经验不很充足的成员不推荐使用该方式； 通过引入xml配置实现事务：配置简单，在xml内一处配置即可实现事务管理，耦合性更低；缺点就是使用了xml配置，因此不太推荐使用该方式； 隔离级别（isolation）通常选择REPEATABLE_READ；传播属性通常使用默认值（REQUIRED）即可。 4、扩展阅读隔离级别（isolation）隔离级别是指若干个并发的事务之间的隔离程度，与我们开发时候主要相关的场景包括：脏读取、重复读、幻读。 我们可以看 org.springframework.transaction.annotation.Isolation 枚举类中定义了五个表示隔离级别的值：1234567public enum Isolation &#123; DEFAULT(-1), READ_UNCOMMITTED(1), READ_COMMITTED(2), REPEATABLE_READ(4), SERIALIZABLE(8);&#125; DEFAULT ：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是： READ_COMMITTED，mysql5.6默认是REPEATABLE-READ，可以通过select @@tx_isolation查看。 READ_UNCOMMITTED ：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。 READ_COMMITTED ：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 REPEATABLE_READ ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。 SERIALIZABLE ：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 传播属性（propagation）所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。 我们可以看 org.springframework.transaction.annotation.Propagation 枚举类中定义了6个表示传播行为的枚举值：123456789public enum Propagation &#123; REQUIRED(0), SUPPORTS(1), MANDATORY(2), REQUIRES_NEW(3), NOT_SUPPORTED(4), NEVER(5), NESTED(6);&#125; REQUIRED ：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。 SUPPORTS ：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 MANDATORY ：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 REQUIRES_NEW ：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 NOT_SUPPORTED ：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 NEVER ：以非事务方式运行，如果当前存在事务，则抛出异常。 NESTED ：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 REQUIRED 。 如有更好实现方式，敬请指出。 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"事务","slug":"事务","permalink":"http://www.onecoderspace.com/tags/事务/"}]},{"title":"前端实战：详情页返回列表内容缓存及定位实现","slug":"前端实战：详情页返回列表内容缓存及定位实现","date":"2017-09-26T12:45:21.000Z","updated":"2017-09-26T13:07:50.000Z","comments":true,"path":"2017/09/26/前端实战：详情页返回列表内容缓存及定位实现/","link":"","permalink":"http://www.onecoderspace.com/2017/09/26/前端实战：详情页返回列表内容缓存及定位实现/","excerpt":"实现目标当前浏览到第N页，点击某一个新闻，进入新闻详情页，点击返回时，列表数据不重新加载，焦点仍定位在进入详情页之前的位置。","text":"实现目标当前浏览到第N页，点击某一个新闻，进入新闻详情页，点击返回时，列表数据不重新加载，焦点仍定位在进入详情页之前的位置。 思路 缓存列表内已展示的数据； 进入详情页时在缓存内添加该新闻的ID（键为articleId）； 返回时在js内判断缓存内是否包含articleId，如果存在，则通过缓存的列表数据进行页面渲染； 通过articleId定位元素，滚动窗口值该元素处； 缓存不能始终存在。 根据当前项目情况，考虑缓存放入sessionStorage，滚动窗口使用IScroll。 实现方案1、缓存列表数据 123456789101112131415//cacheKey 缓存key cacheValue 缓存内容json结构 position 值为before和after分别用于加载最新和加载下一页 function addToCache(cacheKey,cacheValue,position)&#123; cacheValue = JSON.stringify(cacheValue); var allCacheData = sessionStorage.getItem(cacheKey); if(allCacheData != null)&#123; if(position == \"before\")&#123; allCacheData = cacheValue + \"::::\" +allCacheData; &#125; else &#123; allCacheData = allCacheData + \"::::\" + cacheValue; &#125; &#125; else &#123; allCacheData = cacheValue; &#125; sessionStorage.setItem(cacheKey,allCacheData); &#125; sessionStorage只能存储字符串，需要将json结构的对象转为字符串进行存储 如果列表数据特别多，应该和业务确认缓存数据条数，截取仅是字符串操作，这里不再展开 2、进入详情页123$(\".article\").click(function()&#123; sessionStorage.setItem(\"articleId\",$(this).attr(\"id\")); &#125;) 在每条新闻上绑定事件，点击时设置文章ID至缓存，正常来说在详情页设置，但是因为这个项目内的详情页不是我们部门的，所以只能在列表页设置； 3、返回时列表内js判断是从详情页返回的还是一次新的访问123456789var articleId = sessionStorage.getItem(\"articleId\"); var cacheData = sessionStorage.getItem($scope.initType); if(articleId != null &amp;&amp; cacheData != null)&#123; //从详情页返回且列表缓存数据不为空 showTableDataWithCache(cacheData,articleId); removeCache(\"articleId\");//注意使用一次就清理掉 &#125;else &#123; //一次新的访问，要清理掉所有相关缓存 removeAllFuturesCache(); loadPage(1); &#125;4、定位至对应元素1234567891011121314151617//注意IScroll需要重新初始化myScroll = new IScroll('#wrapper', &#123; probeType: 3, disableMouse: true, momentum: true, mouseWheel: true, disablePointer: true, click: true, tap: true, resizePolling: 1, // x &#125;);//滚动至对应元素myScroll.scrollToElement(document.querySelector(\"[id='\"+detailArticleId+\"']\"),10,true,true);initScroll();myScroll.refresh(); 注意IScroll需要重新初始化; scrollToElement的选择器格式是[id=’articleId’]而不是正常的”#articleId”;10 是动画时间 true true这样设置会将元素显示在窗口中间； 总结 sessionStorage是单个窗口级的缓存，同一个窗口内的数据可缓存在其内； IScroll可以作为页面滚动的组件； 详情页返回列表不刷新问题可以分解为三个小问题： 缓存列表数据 添加从详情页返回的标记（文章详情ID） 用缓存数据渲染页面后滚动窗口至对应元素通过sessionStorage存储数据，这样很多功能都可以实现，比如返回时标签选中等都是一样的思路，进入详情页时设置对应值，在页面加载时判断对应的缓存数据是否存在进而展开业务，这里不再展开。 参考：sessionStorage介绍IScroll使用","categories":[{"name":"前端","slug":"前端","permalink":"http://www.onecoderspace.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.onecoderspace.com/tags/前端/"},{"name":"列表数据缓存","slug":"列表数据缓存","permalink":"http://www.onecoderspace.com/tags/列表数据缓存/"},{"name":"详情页返回列表无刷新","slug":"详情页返回列表无刷新","permalink":"http://www.onecoderspace.com/tags/详情页返回列表无刷新/"},{"name":"html生成页面无法滚动","slug":"html生成页面无法滚动","permalink":"http://www.onecoderspace.com/tags/html生成页面无法滚动/"}]},{"title":"spring boot项目实战：跨域问题解决","slug":"spring-boot-cors","date":"2017-09-26T12:44:40.000Z","updated":"2017-10-01T12:37:56.000Z","comments":true,"path":"2017/09/26/spring-boot-cors/","link":"","permalink":"http://www.onecoderspace.com/2017/09/26/spring-boot-cors/","excerpt":"背景前后端分离架构，前端anglerjs，后端spring boot,使用shiro作为权限控制，已配置通用跨域请求支持。前端调用接口时部分情况正常，部分情况出现跨域请求不支持情况，错误信息如下：","text":"背景前后端分离架构，前端anglerjs，后端spring boot,使用shiro作为权限控制，已配置通用跨域请求支持。前端调用接口时部分情况正常，部分情况出现跨域请求不支持情况，错误信息如下：1Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'xxxx' is therefore not allowed access. 配置错了？首先，想到的就是对跨域请求支持的配置是错误的，尝试着替换不同的跨域支持配置，有以下几种：1、继承WebMvcConfigurerAdapter123456789101112@Configurationpublic class AppConfig extends WebMvcConfigurerAdapter &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\") .allowedOrigins(\"*\") .allowCredentials(true).allowedHeaders(\"Origin, X-Requested-With, Content-Type, Accept\") .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\", \"OPTIONS\") .maxAge(3600); &#125;&#125;2、配置WebMvcConfigurer123456789101112@Beanpublic WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\").allowedOrigins(\"*\") .allowedMethods(\"*\").allowedHeaders(\"*\") .allowCredentials(true) .exposedHeaders(HttpHeaders.SET_COOKIE).maxAge(3600L); &#125; &#125;;&#125;… CORS support in Spring Framework内的方式都尝试了一遍，发现问题仍然未解决，看到文档内的一个点 If you are using Spring Security, make sure to enable CORS at Spring Security level as well to allow it to leverage the configuration defined at Spring MVC level. 大概意思就是使用Spring Security要进行特殊的配置来支持CORS。而当前项目内使用的是shiro，是不是权限控制导致的问题?检查shiro相关代码，果然找到了问题，在loginFilter内会判断如果未登录，就通过response写回未登录提示，代码如下：1234567891011121314151617181920Subject subject = SecurityUtils.getSubject();if (!subject.isAuthenticated()) &#123; HttpServletResponse resp = (HttpServletResponse) response; String contentType = \"application/json\"; resp.setContentType(contentType); resp.setCharacterEncoding(\"UTF-8\"); Map&lt;String, String&gt; map = Maps.newLinkedHashMap(); map.put(\"code\", \"xxx\"); map.put(\"msg\", \"xxx\"); String result = JacksonHelper.toJson(map); PrintWriter out = resp.getWriter(); try&#123; out.print(result); out.flush(); &#125; finally &#123; out.close(); &#125; return;&#125;那就添加上跨域支持12resp.setHeader(\"Access-Control-Allow-Credentials\", \"true\");resp.setHeader(\"Access-Control-Allow-Origin\",request.getHeader(\"Origin\"));本来以为ok了，但是前端是不报错了，但并不能获得对应接口期望的结果，而是一直收到1&#123;\"code\":\"xxx\",\"msg\":\"xxx\"&#125;显然是被登录拦截了，但是明明已经登录，而且有的接口可以正常通过登录拦截，为什么部分接口会出现不能登录的情况呢？ 明明登录了，为什么被loginFilter拦截？遇到了问题就要想办法解决，首先就是怀疑客户端sessionId未被正常保存，在loginFilter内添加日志打印sessionID，发现每次的sessionID都不一样，问题清晰了一些，前端并未正确的保持登录状态，对比前端两个调用接口的代码，发现正常的是get请求，post请求不正常，通过在网上搜索，发现ajax post跨域请求时，默认是不携带浏览器的cookie的，也就是每次请求都会生成一个新的session，因此post请求都被登录拦截。解决办法如下：12345678910111213$.ajax(&#123; type:\"POST\", url:\"\", data:&#123;&#125;, crossDomain:true, xhrFields: &#123; withCredentials: true &#125;, success:function(data)&#123; &#125;, error:function(data)&#123; &#125;&#125;)配置crossDomain:true 和 xhrFields: { withCredentials: true }就可以让请求正常携带cookie。 一个完整可用方案1、配置支持跨域请求（多种方式自由选择，推荐使用下面的方式）12345678910111213141516171819@Configurationpublic class WebConfig &#123; /** * 跨域请求支持 */ @Bean public WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\").allowedOrigins(\"*\") .allowedMethods(\"*\").allowedHeaders(\"*\") .allowCredentials(true) .exposedHeaders(HttpHeaders.SET_COOKIE).maxAge(3600L); &#125; &#125;; &#125;&#125;2、前端ajax post请求时添加xhrFields: { withCredentials: true }12345678910111213$.ajax(&#123; type:\"POST\", url:\"\", data:&#123;&#125;, crossDomain:true, xhrFields: &#123; withCredentials: true &#125;, success:function(data)&#123; &#125;, error:function(data)&#123; &#125;&#125;)3、检查权限控制代码，看是否有特殊处理的地方，未添加跨域支持。如上文所提，登录拦截直接通过response写回未登录提示；使用spring-security框架时也要添加特殊配置，如下：12345678@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.cors().and()... &#125;&#125; 解决跨域的本质就是在返回头内添加Access-Control-Allow-Origin，实现方式有多种，spring体系内解决跨域可参考CORS support in Spring Framework,很全面的介绍了各种场景。使用权限框架时，要注意权限框架本身的CORS支持。 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"CORS","slug":"CORS","permalink":"http://www.onecoderspace.com/tags/CORS/"},{"name":"跨域","slug":"跨域","permalink":"http://www.onecoderspace.com/tags/跨域/"},{"name":"ajax post跨域","slug":"ajax-post跨域","permalink":"http://www.onecoderspace.com/tags/ajax-post跨域/"}]},{"title":"sprign boot项目实战：日志","slug":"spring-boot-log","date":"2017-09-26T12:43:59.000Z","updated":"2017-10-01T12:38:16.000Z","comments":true,"path":"2017/09/26/spring-boot-log/","link":"","permalink":"http://www.onecoderspace.com/2017/09/26/spring-boot-log/","excerpt":"日志是运维、排错的一个重要助手，很多人应该都维护过没有日志的项目，知道排查问题是什么感觉。所以搭建基础项目框架时，自然不能少了日志。","text":"日志是运维、排错的一个重要助手，很多人应该都维护过没有日志的项目，知道排查问题是什么感觉。所以搭建基础项目框架时，自然不能少了日志。 日志组件选择从网上各种搜索对比，在log4j2和logback之间选择了log4j2,综合各处评价，log4j2在性能方法有一定优势。但是在一个项目内使用后就发现，spring boot内log4j2不支持spring profile机制，也就是在本地环境、测试环境、预发布环境、正式环境需要手动切换配置，当前公司的多个环境在相同的服务器上，所以这种方式会导致多个环境的日志生成在了同一个文件内，很不利于问题排查。因此又将日志组件换回了logback，因为对当前公司的项目来说，日志支持profile机制更重要，性能瓶颈绝不在日志这块。 logback配置spring boot内配置logback还是很简单的，只需要在src/main/resources目录下创建logback-spring.xml，在xml内添加自己的日志配置即可。支持三个环境local、dev、prod的日志配置如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration scan=\"true\" scanPeriod=\"30 seconds\"&gt; &lt;property name=\"LOG_PATH\" value=\"/mnt/diskb/logs\"/&gt; &lt;springProfile name=\"local\"&gt; &lt;logger name=\"com.onecoderspace\" level=\"debug\" additivity=\"true\"/&gt; &lt;appender name=\"logfile\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ssS&#125; %5p [%c]:%L-%m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;/springProfile&gt; &lt;springProfile name=\"dev\"&gt; &lt;logger name=\"com.onecoderspace\" level=\"info\" additivity=\"true\"/&gt; &lt;appender name=\"logfile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;$&#123;LOG_PATH&#125;/projectName/projectName_dev.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ssS&#125; %5p [%c&#123;5&#125;#%M]:%L-%m%n%caller&#123;0&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- daily rollover --&gt; &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/projectName/projectName_dev.%d&#123;yyyy-MM-dd&#125;.log.gz &lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;/springProfile&gt; &lt;springProfile name=\"prod\"&gt; &lt;logger name=\"com.onecoderspace\" level=\"info\" additivity=\"true\"/&gt; &lt;appender name=\"logfile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;$&#123;LOG_PATH&#125;/projectName/projectName.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ssS&#125; %5p [%c&#123;5&#125;#%M]:%L-%m%n%caller&#123;0&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- daily rollover --&gt; &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/projectName/projectName.%d&#123;yyyy-MM-dd&#125;.log.gz &lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;/springProfile&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"logfile\" /&gt; &lt;/root&gt;&lt;/configuration&gt;spring-boot-starter-web内已经包含了logback和slf4j的依赖，所以只要项目依赖了spring-boot-starter-web，就不需要做其他额外的配置了。 日志使用调用日志时建议使用slf4j，虽然基本不会在后续变更日志组件，但使用slf4j是一个好的习惯。123import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static Logger logger = LoggerFactory.getLogger(LoginController.class);debug日志debug日志建议添加logger.isDebugEnabled()判断，在重要的流程上都留下日志，这样当系统出现问题时，可以通过debug日志，快速定位问题，能代替很多断点调试的时间。1234 if(logger.isDebugEnabled())&#123; logger.debug(\"user=&#123;&#125; login success\",username);&#125;info日志比较重要的信息，对于系统运行有比较重要的参考意义，同时不会对性能造成影响，可以在正式环境展示的信息，使用info基本打印，如定时任务运行时间等。1logger.info(\"end fetcher proxy use time=&#123;&#125;\", System.currentTimeMillis()- t);error日志error日志相对来说是最重要的，但使用时需要注意使用方式，不正确的方式会导致很多信息被隐藏。可以参考如下方式：12 logger.error(String.format(\"error msg ,arg1=%s,arg2=%s\",arg1,arg2), e); 尽可能的带上异常发生时的参数，这个对排查问题很有意义 打印异常的完整堆栈信息，仅打印e.getMessage()会导致很多信息被隐藏 只在异常发生时或明确的业务错误时使用error，不要用error来打印调试、普通信息 总结 spring boot项目内日志组件选择logback比较好，内嵌的日志组件，支持profile机制； logback配置方式为在src/main/resources目录下创建logback-spring.xml，配置内容参考上文； 调用日志时使用slf4j，注意合理使用日志级别 注意以下几点tips tips1、 应用日志尽量放在数据盘上，不要放在系统盘上，遇到了不止一次日志写满系统盘导致服务暂停的情况2、 技术负责人定好日志规范，在代码review时指出几次日志使用的问题，能够很快让良好使用日志成为团队的习惯3、 正式环境的日志基本最低为info，通常可以调整为warn或error4、 在while循环内有异常捕获时，注意当异常发生时，不能无限打印日志，如下代码：123456789101112131415 while (flag) &#123; try &#123; byte[] bb = _queue.poll(1, TimeUnit.SECONDS); if (bb != null) &#123; @SuppressWarnings(\"unchecked\") Map&lt;String, Object&gt; m = JacksonSupport.decode1(new ByteArrayInputStream(bb), Map.class); E event = _consumer.getEventType().newInstance(); event.fromMap(m); _consumer.onEvent(event); &#125; &#125; catch (Exception e) &#123; logger.error(\"redis queue poll due to error\", e); &#125;&#125;从基于redis开发的一个blockingQueue内获取元素进行消费，代码运行了一年多十分正常，但是有一次几乎把磁盘写满了，因为当时运维调整，redis停掉了， _queue.poll这里就开始抛异常，然后下面就狂写日志，一直把磁盘写满。类似这样的地方，可以进行一个计数，连续错误达到多少次，就终止循环并以某些方式提醒运维人员。5、不要使用System.out.println()，建议隔段时间全局搜索一次，发现了就在小组会议上提一下，很快这种现象就会杜绝 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"日志","slug":"日志","permalink":"http://www.onecoderspace.com/tags/日志/"},{"name":"spring profile","slug":"spring-profile","permalink":"http://www.onecoderspace.com/tags/spring-profile/"}]},{"title":"spring boot实战","slug":"spring-boot项目实战：目录","date":"2017-09-25T13:43:52.000Z","updated":"2017-10-04T11:41:30.000Z","comments":true,"path":"2017/09/25/spring-boot项目实战：目录/","link":"","permalink":"http://www.onecoderspace.com/2017/09/25/spring-boot项目实战：目录/","excerpt":"最近基于spring boot搭建了一套公司后端接口项目基础框架，方便公司后续项目的快速开发。本系列博客从实际开发项目所需功能的角度，逐功能点的讲述实现方式，最终完成一个可以直接用于公司项目开发的基础框架。让大家对于使用spring boot开发项目有一个更直观、全面的认识，也让小伙伴们少踩几个我掉过的坑，更愉快的加入spring boot的阵营。","text":"最近基于spring boot搭建了一套公司后端接口项目基础框架，方便公司后续项目的快速开发。本系列博客从实际开发项目所需功能的角度，逐功能点的讲述实现方式，最终完成一个可以直接用于公司项目开发的基础框架。让大家对于使用spring boot开发项目有一个更直观、全面的认识，也让小伙伴们少踩几个我掉过的坑，更愉快的加入spring boot的阵营。项目包含的基础功能有： spring boot项目基础结构 spring boot项目实战：JPA 公共方法提取：service、dao、model spring-boot项目实战：shiro spring boot项目实战：跨域支持：CORS spring boot项目实战：redis spring boot项目实战：日志 spring boot项目实战：事务 安全：xss、CSRF、SQL注入 spring boot项目实战：分布式锁 常用工具类（日期、http、集合操作、文件操作、json、加密、ognl等） spring-boot实战：共享session spring boot项目实战：swagger2在线文档 代码生成器：code-generator 应用监控：Spring Boot Actuator JSP支持 额外推荐一个很不错的博客，我入门都是在上面看的。程序员DD|博客 本人搭建好的spring boot web后端开发框架已上传至GitHub，欢迎吐槽！https://github.com/q7322068/rest-base,已用于多个正式项目，当前可能因为版本问题不是很完善，后续持续优化，希望你能有所收获！","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"CORS","slug":"CORS","permalink":"http://www.onecoderspace.com/tags/CORS/"},{"name":"日志","slug":"日志","permalink":"http://www.onecoderspace.com/tags/日志/"},{"name":"redis","slug":"redis","permalink":"http://www.onecoderspace.com/tags/redis/"},{"name":"JPA","slug":"JPA","permalink":"http://www.onecoderspace.com/tags/JPA/"},{"name":"spring-session","slug":"spring-session","permalink":"http://www.onecoderspace.com/tags/spring-session/"},{"name":"事务","slug":"事务","permalink":"http://www.onecoderspace.com/tags/事务/"},{"name":"spring-boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/tags/spring-boot实战/"},{"name":"web基础框架","slug":"web基础框架","permalink":"http://www.onecoderspace.com/tags/web基础框架/"},{"name":"异常","slug":"异常","permalink":"http://www.onecoderspace.com/tags/异常/"},{"name":"接口文档","slug":"接口文档","permalink":"http://www.onecoderspace.com/tags/接口文档/"},{"name":"权限控制","slug":"权限控制","permalink":"http://www.onecoderspace.com/tags/权限控制/"},{"name":"跨域支持","slug":"跨域支持","permalink":"http://www.onecoderspace.com/tags/跨域支持/"},{"name":"安全","slug":"安全","permalink":"http://www.onecoderspace.com/tags/安全/"},{"name":"xss","slug":"xss","permalink":"http://www.onecoderspace.com/tags/xss/"},{"name":"CSRF","slug":"CSRF","permalink":"http://www.onecoderspace.com/tags/CSRF/"},{"name":"缓存","slug":"缓存","permalink":"http://www.onecoderspace.com/tags/缓存/"},{"name":"分布式锁","slug":"分布式锁","permalink":"http://www.onecoderspace.com/tags/分布式锁/"},{"name":"shiro","slug":"shiro","permalink":"http://www.onecoderspace.com/tags/shiro/"}]},{"title":"web项目高效开发","slug":"高效开发","date":"2017-09-24T06:26:20.000Z","updated":"2017-09-24T13:23:10.000Z","comments":true,"path":"2017/09/24/高效开发/","link":"","permalink":"http://www.onecoderspace.com/2017/09/24/高效开发/","excerpt":"从事开发工作五年多，参与、带的项目几十个，中间也思考过怎么提高项目的开发速度和质量，也陆续尝试了一些方法，最近稍有空闲，就系统梳理、自我总结一把，主要有以下几点： 理清需求再动手，不要后期需求变更、代码补丁打的自己酸爽无比 减少模板代码的copy开发，能自动生成的自动生成 提取自己公司的模板项目，配合代码生成器生成40%以上的模板代码 生成规范可用的文档，减少文档维护工作 自动构建部署项目 规范日志，提升运维效率思路就是“通用的东西进行提取，能自动生成的东西自动生成，让程序员专心写业务代码”。","text":"从事开发工作五年多，参与、带的项目几十个，中间也思考过怎么提高项目的开发速度和质量，也陆续尝试了一些方法，最近稍有空闲，就系统梳理、自我总结一把，主要有以下几点： 理清需求再动手，不要后期需求变更、代码补丁打的自己酸爽无比 减少模板代码的copy开发，能自动生成的自动生成 提取自己公司的模板项目，配合代码生成器生成40%以上的模板代码 生成规范可用的文档，减少文档维护工作 自动构建部署项目 规范日志，提升运维效率思路就是“通用的东西进行提取，能自动生成的东西自动生成，让程序员专心写业务代码”。 1、理清需求功能点多，技术难度大对程序员来说正常，加班干活也没啥怨言，完成了心中还有点成就感，但几个功能点翻来覆去的调整个三五次，那90%的人估计都已经在心里问候项目经理了。有些需求变更是难免的，但更多的是可以通过合适的管理、设计来避免的，特别是小公司的技术负责人（如我）更应该注意”想清楚要做什么比立马思考怎么做更重要“，你在开始设计时跑偏一些，忘记一些，就意味着之后的某个时间团队集体狼狈的加班，这里有几点小经验分享给大军： 认真阅读需求文档，在心里构画出整个网站的全景图，任何一个分支小道都不忽视 提出问题，让需求人员想的更多一点 自己将对需求的认识向需求+团队成员讲一遍 负责某一模块的团队成员复述一下对需求的认识 2、项目模板项目内有很多底层通用的东西，特别是一个公司内容的项目，不同项目间共性的东西更多，很多时候开发也是copy一个项目，把原来的业务功能删减，有类似功能的再从不同项目里copy过来。这种情况将共性代码提出为一个base项目，后续项目都直接在base项目的基础上开发，明显会更舒爽很多。目前使用spring-boot搭建了一个后端web接口开发的模板项目，后续也会在《spring boot项目实战》系列文章进行分享。 3、代码生成代码生成器的原理就是读取表结构，生成对应的模板代码，所以开发一个项目先进行数据库设计。一、数据库设计有段时间设计数据库使用excel，后面发现修改、维护、查看都不怎么方便，现在在使用免费的workbench进行数据库设计，软件操作还算顺手，能够简单的体现模块、表之间的关系。在这方面根据个人感觉，用着顺手就行，建议使用专业的软件，excel之类的从效果上来说的确有一定的差距。建议每个字段都设置好注释，字段命名多个单词用下划线分割。 二、代码生成器本人开发了一个代码生成器，功能有： 生成指定数据库内所有表对应的模板代码（实体、dao、service、controller） 生成指定数据库内指定表对应的模板代码（实体、dao、service、controller）原理是通过sql查询数据内有哪些数据库，数据库内有哪些表，表里面的字段信息，然后通过freemarker来生成模板代码，如有需要可根据该项目调整对应的模板生成自己公司的代码。GitHub: https://github.com/q7322068/code-generation 4、在线文档生成公司项目是前后端分离的架构，刚开始都是通过excel来提供接口文档给前端，后来维护起来实在是太麻烦，调整了就要改excel，多个人维护起来，很快就乱套了，后来决定使用swagger2来构建在线api文档，以代码的形式来维护，代码调整时添加上指定格式的注释就能自动生成接口文档，前端通过在线文档来查看，配合起来更舒服。使用请参考：Spring Boot中使用Swagger2构建强大的RESTful API文档简化Swagger使用的自制Starter：spring-boot-starter-swagger，欢迎使用和吐槽spring-boot-starter-swagger 1.3.0.RELEASE：新增对JSR-303的支持和host的配置 5、自动构建代码开发好了，总是要在服务器上部署运行的，我现在的公司采用Jenkins来完成自动打包部署，提交svn代码，Jenkins自动打包（支持war包、jar包）部署至测试环境，预发布环境和正式环境基于测试环境的代码进行发布（通过脚本进行发布，实际上就是遍历某个文件夹下的文件，选择后进行copy）。 6、日志很重要刚到现在公司的时候，接手的项目日志千奇百怪，有打印到控制台的，有日志未生效的，有自己写到某个文件的（你没看错），加上项目文档严重缺失，有过类似体验的兄弟知道是啥感觉。所以抽取基础项目时直接定好日志规范，在规定目录下生成日志，日志完备了，日常运维也就简单了。 总结 提取一套基础框架，把该有的组件、工具类都放进去 设计数据库、代码生成，这样model、dao、service、controller都有了，注意啊比较完备的在线注释已经存在了^_^ 使用Jenkins自动构建发布，部署项目再也不需要自己上去svn up，ps,kill等一系列操作了； 日志很重要很重要，没日志的日子很难过滴希望这篇文章能诱发点你的“懒病”，每天只写“爽”的代码，想要懒就只能先勤快，为你的开发打造点顺手的武器吧。","categories":[{"name":"java实战","slug":"java实战","permalink":"http://www.onecoderspace.com/categories/java实战/"}],"tags":[{"name":"java实战 spirng-boot 项目高效开发 自动构建 代码生成","slug":"java实战-spirng-boot-项目高效开发-自动构建-代码生成","permalink":"http://www.onecoderspace.com/tags/java实战-spirng-boot-项目高效开发-自动构建-代码生成/"}]}]}