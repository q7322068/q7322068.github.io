{"meta":{"title":"足迹|成长之路","subtitle":"实战经验梳理，分享与你，分享与自己！","description":"spring boot，spring cloud，微服务，java web编程实战","author":"杨文魁","url":"http://www.onecoderspace.com"},"pages":[{"title":"","date":"2017-09-16T03:13:44.000Z","updated":"2017-09-16T03:13:13.000Z","comments":true,"path":"5435542637.html","permalink":"http://www.onecoderspace.com/5435542637.html","excerpt":"","text":""},{"title":"","date":"2017-09-15T15:27:58.000Z","updated":"2017-09-15T15:27:58.000Z","comments":true,"path":"404.html","permalink":"http://www.onecoderspace.com/404.html","excerpt":"","text":""},{"title":"关于我","date":"2017-09-10T12:49:14.000Z","updated":"2017-09-10T13:18:59.000Z","comments":true,"path":"about/index.html","permalink":"http://www.onecoderspace.com/about/index.html","excerpt":"","text":"有志之人立长志，无志之人常立志 杨文魁一个程序猿技术上，主要从事java web开发，一直在中小公司工作，对于系统设计、数据库设计、代码开发、前端、部署都有较多的经验。但怎么说呢，各个地方都会，但很少有大并发、大数据量的实践场景，对于技术的掌握也感觉没有达到很精深的程度，希望能在后续的时间内梳理自己过往实践中用过的技术、解决的问题，总结过往，找到深入研究的方向，在技术上继续提升自己的能力。 近期博客里会写一系列最近在开发中用到的spring boot,spring cloud等技术，从项目实战的角度来来阐述这些技术的使用及中间遇到的各种大大小小的问题。"}],"posts":[{"title":"前端实战：详情页返回列表内容缓存及定位实现","slug":"前端实战：详情页返回列表内容缓存及定位实现","date":"2017-09-26T12:45:21.000Z","updated":"2017-09-26T13:07:50.000Z","comments":true,"path":"2017/09/26/前端实战：详情页返回列表内容缓存及定位实现/","link":"","permalink":"http://www.onecoderspace.com/2017/09/26/前端实战：详情页返回列表内容缓存及定位实现/","excerpt":"实现目标当前浏览到第N页，点击某一个新闻，进入新闻详情页，点击返回时，列表数据不重新加载，焦点仍定位在进入详情页之前的位置。","text":"实现目标当前浏览到第N页，点击某一个新闻，进入新闻详情页，点击返回时，列表数据不重新加载，焦点仍定位在进入详情页之前的位置。 思路 缓存列表内已展示的数据； 进入详情页时在缓存内添加该新闻的ID（键为articleId）； 返回时在js内判断缓存内是否包含articleId，如果存在，则通过缓存的列表数据进行页面渲染； 通过articleId定位元素，滚动窗口值该元素处； 缓存不能始终存在。 根据当前项目情况，考虑缓存放入sessionStorage，滚动窗口使用IScroll。 实现方案1、缓存列表数据 123456789101112131415//cacheKey 缓存key cacheValue 缓存内容json结构 position 值为before和after分别用于加载最新和加载下一页 function addToCache(cacheKey,cacheValue,position)&#123; cacheValue = JSON.stringify(cacheValue); var allCacheData = sessionStorage.getItem(cacheKey); if(allCacheData != null)&#123; if(position == \"before\")&#123; allCacheData = cacheValue + \"::::\" +allCacheData; &#125; else &#123; allCacheData = allCacheData + \"::::\" + cacheValue; &#125; &#125; else &#123; allCacheData = cacheValue; &#125; sessionStorage.setItem(cacheKey,allCacheData); &#125; sessionStorage只能存储字符串，需要将json结构的对象转为字符串进行存储 如果列表数据特别多，应该和业务确认缓存数据条数，截取仅是字符串操作，这里不再展开 2、进入详情页123$(\".article\").click(function()&#123; sessionStorage.setItem(\"articleId\",$(this).attr(\"id\")); &#125;) 在每条新闻上绑定事件，点击时设置文章ID至缓存，正常来说在详情页设置，但是因为这个项目内的详情页不是我们部门的，所以只能在列表页设置； 3、返回时列表内js判断是从详情页返回的还是一次新的访问123456789var articleId = sessionStorage.getItem(\"articleId\"); var cacheData = sessionStorage.getItem($scope.initType); if(articleId != null &amp;&amp; cacheData != null)&#123; //从详情页返回且列表缓存数据不为空 showTableDataWithCache(cacheData,articleId); removeCache(\"articleId\");//注意使用一次就清理掉 &#125;else &#123; //一次新的访问，要清理掉所有相关缓存 removeAllFuturesCache(); loadPage(1); &#125;4、定位至对应元素1234567891011121314151617//注意IScroll需要重新初始化myScroll = new IScroll('#wrapper', &#123; probeType: 3, disableMouse: true, momentum: true, mouseWheel: true, disablePointer: true, click: true, tap: true, resizePolling: 1, // x &#125;);//滚动至对应元素myScroll.scrollToElement(document.querySelector(\"[id='\"+detailArticleId+\"']\"),10,true,true);initScroll();myScroll.refresh(); 注意IScroll需要重新初始化; scrollToElement的选择器格式是[id=’articleId’]而不是正常的”#articleId”;10 是动画时间 true true这样设置会将元素显示在窗口中间； 总结 sessionStorage是单个窗口级的缓存，同一个窗口内的数据可缓存在其内； IScroll可以作为页面滚动的组件； 详情页返回列表不刷新问题可以分解为三个小问题： 缓存列表数据 添加从详情页返回的标记（文章详情ID） 用缓存数据渲染页面后滚动窗口至对应元素通过sessionStorage存储数据，这样很多功能都可以实现，比如返回时标签选中等都是一样的思路，进入详情页时设置对应值，在页面加载时判断对应的缓存数据是否存在进而展开业务，这里不再展开。 参考：sessionStorage介绍IScroll使用","categories":[{"name":"前端","slug":"前端","permalink":"http://www.onecoderspace.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.onecoderspace.com/tags/前端/"},{"name":"列表数据缓存","slug":"列表数据缓存","permalink":"http://www.onecoderspace.com/tags/列表数据缓存/"},{"name":"详情页返回列表无刷新","slug":"详情页返回列表无刷新","permalink":"http://www.onecoderspace.com/tags/详情页返回列表无刷新/"},{"name":"html生成页面无法滚动","slug":"html生成页面无法滚动","permalink":"http://www.onecoderspace.com/tags/html生成页面无法滚动/"}]},{"title":"spring boot项目实战：跨域问题解决","slug":"spring-boot项目实战：跨域","date":"2017-09-26T12:44:40.000Z","updated":"2017-09-26T13:11:01.000Z","comments":true,"path":"2017/09/26/spring-boot项目实战：跨域/","link":"","permalink":"http://www.onecoderspace.com/2017/09/26/spring-boot项目实战：跨域/","excerpt":"背景前后端分离架构，前端anglerjs，后端spring boot,使用shiro作为权限控制，已配置通用跨域请求支持。前端调用接口时部分情况正常，部分情况出现跨域请求不支持情况，错误信息如下：","text":"背景前后端分离架构，前端anglerjs，后端spring boot,使用shiro作为权限控制，已配置通用跨域请求支持。前端调用接口时部分情况正常，部分情况出现跨域请求不支持情况，错误信息如下：1Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'xxxx' is therefore not allowed access. 配置错了？首先，想到的就是对跨域请求支持的配置是错误的，尝试着替换不同的跨域支持配置，有以下几种：1、继承WebMvcConfigurerAdapter123456789101112@Configurationpublic class AppConfig extends WebMvcConfigurerAdapter &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\") .allowedOrigins(\"*\") .allowCredentials(true).allowedHeaders(\"Origin, X-Requested-With, Content-Type, Accept\") .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\", \"OPTIONS\") .maxAge(3600); &#125;&#125;2、配置WebMvcConfigurer123456789101112@Beanpublic WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\").allowedOrigins(\"*\") .allowedMethods(\"*\").allowedHeaders(\"*\") .allowCredentials(true) .exposedHeaders(HttpHeaders.SET_COOKIE).maxAge(3600L); &#125; &#125;;&#125;… CORS support in Spring Framework内的方式都尝试了一遍，发现问题仍然未解决，看到文档内的一个点 If you are using Spring Security, make sure to enable CORS at Spring Security level as well to allow it to leverage the configuration defined at Spring MVC level. 大概意思就是使用Spring Security要进行特殊的配置来支持CORS。而当前项目内使用的是shiro，是不是权限控制导致的问题?检查shiro相关代码，果然找到了问题，在loginFilter内会判断如果未登录，就通过response写回未登录提示，代码如下：1234567891011121314151617181920Subject subject = SecurityUtils.getSubject();if (!subject.isAuthenticated()) &#123; HttpServletResponse resp = (HttpServletResponse) response; String contentType = \"application/json\"; resp.setContentType(contentType); resp.setCharacterEncoding(\"UTF-8\"); Map&lt;String, String&gt; map = Maps.newLinkedHashMap(); map.put(\"code\", \"xxx\"); map.put(\"msg\", \"xxx\"); String result = JacksonHelper.toJson(map); PrintWriter out = resp.getWriter(); try&#123; out.print(result); out.flush(); &#125; finally &#123; out.close(); &#125; return;&#125;那就添加上跨域支持12resp.setHeader(\"Access-Control-Allow-Credentials\", \"true\");resp.setHeader(\"Access-Control-Allow-Origin\",request.getHeader(\"Origin\"));本来以为ok了，但是前端是不报错了，但并不能获得对应接口期望的结果，而是一直收到1&#123;\"code\":\"xxx\",\"msg\":\"xxx\"&#125;显然是被登录拦截了，但是明明已经登录，而且有的接口可以正常通过登录拦截，为什么部分接口会出现不能登录的情况呢？ 明明登录了，为什么被loginFilter拦截？遇到了问题就要想办法解决，首先就是怀疑客户端sessionId未被正常保存，在loginFilter内添加日志打印sessionID，发现每次的sessionID都不一样，问题清晰了一些，前端并未正确的保持登录状态，对比前端两个调用接口的代码，发现正常的是get请求，post请求不正常，通过在网上搜索，发现ajax post跨域请求时，默认是不携带浏览器的cookie的，也就是每次请求都会生成一个新的session，因此post请求都被登录拦截。解决办法如下：12345678910111213$.ajax(&#123; type:\"POST\", url:\"\", data:&#123;&#125;, crossDomain:true, xhrFields: &#123; withCredentials: true &#125;, success:function(data)&#123; &#125;, error:function(data)&#123; &#125;&#125;)配置crossDomain:true 和 xhrFields: { withCredentials: true }就可以让请求正常携带cookie。 一个完整可用方案1、配置支持跨域请求（多种方式自由选择，推荐使用下面的方式）12345678910111213141516171819@Configurationpublic class WebConfig &#123; /** * 跨域请求支持 */ @Bean public WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\").allowedOrigins(\"*\") .allowedMethods(\"*\").allowedHeaders(\"*\") .allowCredentials(true) .exposedHeaders(HttpHeaders.SET_COOKIE).maxAge(3600L); &#125; &#125;; &#125;&#125;2、前端ajax post请求时添加xhrFields: { withCredentials: true }12345678910111213$.ajax(&#123; type:\"POST\", url:\"\", data:&#123;&#125;, crossDomain:true, xhrFields: &#123; withCredentials: true &#125;, success:function(data)&#123; &#125;, error:function(data)&#123; &#125;&#125;)3、检查权限控制代码，看是否有特殊处理的地方，未添加跨域支持。如上文所提，登录拦截直接通过response写回未登录提示；使用spring-security框架时也要添加特殊配置，如下：12345678@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.cors().and()... &#125;&#125; 解决跨域的本质就是在返回头内添加Access-Control-Allow-Origin，实现方式有多种，spring体系内解决跨域可参考CORS support in Spring Framework,很全面的介绍了各种场景。使用权限框架时，要注意权限框架本身的CORS支持。","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"CORS","slug":"CORS","permalink":"http://www.onecoderspace.com/tags/CORS/"},{"name":"跨域","slug":"跨域","permalink":"http://www.onecoderspace.com/tags/跨域/"},{"name":"ajax post跨域","slug":"ajax-post跨域","permalink":"http://www.onecoderspace.com/tags/ajax-post跨域/"}]},{"title":"sprign boot项目实战：日志","slug":"sprign-boot项目实战：日志","date":"2017-09-26T12:43:59.000Z","updated":"2017-09-26T13:09:06.000Z","comments":true,"path":"2017/09/26/sprign-boot项目实战：日志/","link":"","permalink":"http://www.onecoderspace.com/2017/09/26/sprign-boot项目实战：日志/","excerpt":"日志是运维、排错的一个重要助手，很多人应该都维护过没有日志的项目，知道排查问题是什么感觉。所以搭建基础项目框架时，自然不能少了日志。","text":"日志是运维、排错的一个重要助手，很多人应该都维护过没有日志的项目，知道排查问题是什么感觉。所以搭建基础项目框架时，自然不能少了日志。 日志组件选择从网上各种搜索对比，在log4j2和logback之间选择了log4j2,综合各处评价，log4j2在性能方法有一定优势。但是在一个项目内使用后就发现，spring boot内log4j2不支持spring profile机制，也就是在本地环境、测试环境、预发布环境、正式环境需要手动切换配置，当前公司的多个环境在相同的服务器上，所以这种方式会导致多个环境的日志生成在了同一个文件内，很不利于问题排查。因此又将日志组件换回了logback，因为对当前公司的项目来说，日志支持profile机制更重要，性能瓶颈绝不在日志这块。 logback配置spring boot内配置logback还是很简单的，只需要在src/main/resources目录下创建logback-spring.xml，在xml内添加自己的日志配置即可。支持三个环境local、dev、prod的日志配置如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration scan=\"true\" scanPeriod=\"30 seconds\"&gt; &lt;property name=\"LOG_PATH\" value=\"/mnt/diskb/logs\"/&gt; &lt;springProfile name=\"local\"&gt; &lt;logger name=\"com.onecoderspace\" level=\"debug\" additivity=\"true\"/&gt; &lt;appender name=\"logfile\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ssS&#125; %5p [%c]:%L-%m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;/springProfile&gt; &lt;springProfile name=\"dev\"&gt; &lt;logger name=\"com.onecoderspace\" level=\"info\" additivity=\"true\"/&gt; &lt;appender name=\"logfile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;$&#123;LOG_PATH&#125;/projectName/projectName_dev.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ssS&#125; %5p [%c&#123;5&#125;#%M]:%L-%m%n%caller&#123;0&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- daily rollover --&gt; &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/projectName/projectName_dev.%d&#123;yyyy-MM-dd&#125;.log.gz &lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;/springProfile&gt; &lt;springProfile name=\"prod\"&gt; &lt;logger name=\"com.onecoderspace\" level=\"info\" additivity=\"true\"/&gt; &lt;appender name=\"logfile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;$&#123;LOG_PATH&#125;/projectName/projectName.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ssS&#125; %5p [%c&#123;5&#125;#%M]:%L-%m%n%caller&#123;0&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- daily rollover --&gt; &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/projectName/projectName.%d&#123;yyyy-MM-dd&#125;.log.gz &lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;/springProfile&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"logfile\" /&gt; &lt;/root&gt;&lt;/configuration&gt;spring-boot-starter-web内已经包含了logback和slf4j的依赖，所以只要项目依赖了spring-boot-starter-web，就不需要做其他额外的配置了。 日志使用调用日志时建议使用slf4j，虽然基本不会在后续变更日志组件，但使用slf4j是一个好的习惯。123import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static Logger logger = LoggerFactory.getLogger(LoginController.class);debug日志debug日志建议添加logger.isDebugEnabled()判断，在重要的流程上都留下日志，这样当系统出现问题时，可以通过debug日志，快速定位问题，能代替很多断点调试的时间。1234 if(logger.isDebugEnabled())&#123; logger.debug(\"user=&#123;&#125; login success\",username);&#125;info日志比较重要的信息，对于系统运行有比较重要的参考意义，同时不会对性能造成影响，可以在正式环境展示的信息，使用info基本打印，如定时任务运行时间等。1logger.info(\"end fetcher proxy use time=&#123;&#125;\", System.currentTimeMillis()- t);error日志error日志相对来说是最重要的，但使用时需要注意使用方式，不正确的方式会导致很多信息被隐藏。可以参考如下方式：12 logger.error(String.format(\"error msg ,arg1=%s,arg2=%s\",arg1,arg2), e); 尽可能的带上异常发生时的参数，这个对排查问题很有意义 打印异常的完整堆栈信息，仅打印e.getMessage()会导致很多信息被隐藏 只在异常发生时或明确的业务错误时使用error，不要用error来打印调试、普通信息 总结 spring boot项目内日志组件选择logback比较好，内嵌的日志组件，支持profile机制； logback配置方式为在src/main/resources目录下创建logback-spring.xml，配置内容参考上文； 调用日志时使用slf4j，注意合理使用日志级别 注意以下几点tips tips1、 应用日志尽量放在数据盘上，不要放在系统盘上，遇到了不止一次日志写满系统盘导致服务暂停的情况2、 技术负责人定好日志规范，在代码review时指出几次日志使用的问题，能够很快让良好使用日志成为团队的习惯3、 正式环境的日志基本最低为info，通常可以调整为warn或error4、 在while循环内有异常捕获时，注意当异常发生时，不能无限打印日志，如下代码：123456789101112131415 while (flag) &#123; try &#123; byte[] bb = _queue.poll(1, TimeUnit.SECONDS); if (bb != null) &#123; @SuppressWarnings(\"unchecked\") Map&lt;String, Object&gt; m = JacksonSupport.decode1(new ByteArrayInputStream(bb), Map.class); E event = _consumer.getEventType().newInstance(); event.fromMap(m); _consumer.onEvent(event); &#125; &#125; catch (Exception e) &#123; logger.error(\"redis queue poll due to error\", e); &#125;&#125;从基于redis开发的一个blockingQueue内获取元素进行消费，代码运行了一年多十分正常，但是有一次几乎把磁盘写满了，因为当时运维调整，redis停掉了， _queue.poll这里就开始抛异常，然后下面就狂写日志，一直把磁盘写满。类似这样的地方，可以进行一个计数，连续错误达到多少次，就终止循环并以某些方式提醒运维人员。5、不要使用System.out.println()，建议隔段时间全局搜索一次，发现了就在小组会议上提一下，很快这种现象就会杜绝","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.onecoderspace.com/tags/spring-boot/"},{"name":"日志","slug":"日志","permalink":"http://www.onecoderspace.com/tags/日志/"},{"name":"spring profile","slug":"spring-profile","permalink":"http://www.onecoderspace.com/tags/spring-profile/"}]},{"title":"spring boot实战","slug":"spring-boot项目实战：目录","date":"2017-09-25T13:43:52.000Z","updated":"2017-09-26T13:13:55.000Z","comments":true,"path":"2017/09/25/spring-boot项目实战：目录/","link":"","permalink":"http://www.onecoderspace.com/2017/09/25/spring-boot项目实战：目录/","excerpt":"最近基于spring boot搭建了一套公司后端接口项目基础框架，方便公司后续项目的快速开发。本系列博客从实际开发项目所需功能的角度，逐功能点的讲述实现方式，最终完成一个可以直接用于公司项目开发的基础框架。让大家对于使用spring boot开发项目有一个更直观、全面的认识，也让小伙伴们少踩几个我掉过的坑，更愉快的加入spring boot的阵营。","text":"最近基于spring boot搭建了一套公司后端接口项目基础框架，方便公司后续项目的快速开发。本系列博客从实际开发项目所需功能的角度，逐功能点的讲述实现方式，最终完成一个可以直接用于公司项目开发的基础框架。让大家对于使用spring boot开发项目有一个更直观、全面的认识，也让小伙伴们少踩几个我掉过的坑，更愉快的加入spring boot的阵营。项目包含的基础功能有： spring boot项目基础结构 持久层框架：JPA 公共方法提取：service、dao、model 权限控制：shiro spring boot实战：跨域支持：CORS 缓存：redis、ehcache使用 spring boot实战：日志 事务 安全：xss、CSRF、SQL注入 基于redis的分布式锁 常用工具类（日期、http、集合操作、文件操作、json、加密、ognl等） session共享：spring-session 代码生成器：code-generator 应用监控：Spring Boot Actuator JSP支持 额外推荐一个很不错的博客，我入门都是在上面看的。程序员DD|博客","categories":[{"name":"spring boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/categories/spring-boot实战/"}],"tags":[{"name":"日志","slug":"日志","permalink":"http://www.onecoderspace.com/tags/日志/"},{"name":"spring-boot实战","slug":"spring-boot实战","permalink":"http://www.onecoderspace.com/tags/spring-boot实战/"},{"name":"web基础框架","slug":"web基础框架","permalink":"http://www.onecoderspace.com/tags/web基础框架/"},{"name":"异常","slug":"异常","permalink":"http://www.onecoderspace.com/tags/异常/"},{"name":"事务","slug":"事务","permalink":"http://www.onecoderspace.com/tags/事务/"},{"name":"接口文档","slug":"接口文档","permalink":"http://www.onecoderspace.com/tags/接口文档/"},{"name":"权限控制","slug":"权限控制","permalink":"http://www.onecoderspace.com/tags/权限控制/"},{"name":"跨域支持","slug":"跨域支持","permalink":"http://www.onecoderspace.com/tags/跨域支持/"},{"name":"CORS","slug":"CORS","permalink":"http://www.onecoderspace.com/tags/CORS/"},{"name":"安全","slug":"安全","permalink":"http://www.onecoderspace.com/tags/安全/"},{"name":"xss","slug":"xss","permalink":"http://www.onecoderspace.com/tags/xss/"},{"name":"CSRF","slug":"CSRF","permalink":"http://www.onecoderspace.com/tags/CSRF/"},{"name":"缓存","slug":"缓存","permalink":"http://www.onecoderspace.com/tags/缓存/"},{"name":"redis","slug":"redis","permalink":"http://www.onecoderspace.com/tags/redis/"},{"name":"JPA","slug":"JPA","permalink":"http://www.onecoderspace.com/tags/JPA/"},{"name":"分布式锁","slug":"分布式锁","permalink":"http://www.onecoderspace.com/tags/分布式锁/"},{"name":"shiro","slug":"shiro","permalink":"http://www.onecoderspace.com/tags/shiro/"},{"name":"spring-session","slug":"spring-session","permalink":"http://www.onecoderspace.com/tags/spring-session/"}]},{"title":"web项目高效开发","slug":"高效开发","date":"2017-09-24T06:26:20.000Z","updated":"2017-09-24T13:23:10.000Z","comments":true,"path":"2017/09/24/高效开发/","link":"","permalink":"http://www.onecoderspace.com/2017/09/24/高效开发/","excerpt":"从事开发工作五年多，参与、带的项目几十个，中间也思考过怎么提高项目的开发速度和质量，也陆续尝试了一些方法，最近稍有空闲，就系统梳理、自我总结一把，主要有以下几点： 理清需求再动手，不要后期需求变更、代码补丁打的自己酸爽无比 减少模板代码的copy开发，能自动生成的自动生成 提取自己公司的模板项目，配合代码生成器生成40%以上的模板代码 生成规范可用的文档，减少文档维护工作 自动构建部署项目 规范日志，提升运维效率思路就是“通用的东西进行提取，能自动生成的东西自动生成，让程序员专心写业务代码”。","text":"从事开发工作五年多，参与、带的项目几十个，中间也思考过怎么提高项目的开发速度和质量，也陆续尝试了一些方法，最近稍有空闲，就系统梳理、自我总结一把，主要有以下几点： 理清需求再动手，不要后期需求变更、代码补丁打的自己酸爽无比 减少模板代码的copy开发，能自动生成的自动生成 提取自己公司的模板项目，配合代码生成器生成40%以上的模板代码 生成规范可用的文档，减少文档维护工作 自动构建部署项目 规范日志，提升运维效率思路就是“通用的东西进行提取，能自动生成的东西自动生成，让程序员专心写业务代码”。 1、理清需求功能点多，技术难度大对程序员来说正常，加班干活也没啥怨言，完成了心中还有点成就感，但几个功能点翻来覆去的调整个三五次，那90%的人估计都已经在心里问候项目经理了。有些需求变更是难免的，但更多的是可以通过合适的管理、设计来避免的，特别是小公司的技术负责人（如我）更应该注意”想清楚要做什么比立马思考怎么做更重要“，你在开始设计时跑偏一些，忘记一些，就意味着之后的某个时间团队集体狼狈的加班，这里有几点小经验分享给大军： 认真阅读需求文档，在心里构画出整个网站的全景图，任何一个分支小道都不忽视 提出问题，让需求人员想的更多一点 自己将对需求的认识向需求+团队成员讲一遍 负责某一模块的团队成员复述一下对需求的认识 2、项目模板项目内有很多底层通用的东西，特别是一个公司内容的项目，不同项目间共性的东西更多，很多时候开发也是copy一个项目，把原来的业务功能删减，有类似功能的再从不同项目里copy过来。这种情况将共性代码提出为一个base项目，后续项目都直接在base项目的基础上开发，明显会更舒爽很多。目前使用spring-boot搭建了一个后端web接口开发的模板项目，后续也会在《spring boot项目实战》系列文章进行分享。 3、代码生成代码生成器的原理就是读取表结构，生成对应的模板代码，所以开发一个项目先进行数据库设计。一、数据库设计有段时间设计数据库使用excel，后面发现修改、维护、查看都不怎么方便，现在在使用免费的workbench进行数据库设计，软件操作还算顺手，能够简单的体现模块、表之间的关系。在这方面根据个人感觉，用着顺手就行，建议使用专业的软件，excel之类的从效果上来说的确有一定的差距。建议每个字段都设置好注释，字段命名多个单词用下划线分割。 二、代码生成器本人开发了一个代码生成器，功能有： 生成指定数据库内所有表对应的模板代码（实体、dao、service、controller） 生成指定数据库内指定表对应的模板代码（实体、dao、service、controller）原理是通过sql查询数据内有哪些数据库，数据库内有哪些表，表里面的字段信息，然后通过freemarker来生成模板代码，如有需要可根据该项目调整对应的模板生成自己公司的代码。GitHub: https://github.com/q7322068/code-generation 4、在线文档生成公司项目是前后端分离的架构，刚开始都是通过excel来提供接口文档给前端，后来维护起来实在是太麻烦，调整了就要改excel，多个人维护起来，很快就乱套了，后来决定使用swagger2来构建在线api文档，以代码的形式来维护，代码调整时添加上指定格式的注释就能自动生成接口文档，前端通过在线文档来查看，配合起来更舒服。使用请参考：Spring Boot中使用Swagger2构建强大的RESTful API文档简化Swagger使用的自制Starter：spring-boot-starter-swagger，欢迎使用和吐槽spring-boot-starter-swagger 1.3.0.RELEASE：新增对JSR-303的支持和host的配置 5、自动构建代码开发好了，总是要在服务器上部署运行的，我现在的公司采用Jenkins来完成自动打包部署，提交svn代码，Jenkins自动打包（支持war包、jar包）部署至测试环境，预发布环境和正式环境基于测试环境的代码进行发布（通过脚本进行发布，实际上就是遍历某个文件夹下的文件，选择后进行copy）。 6、日志很重要刚到现在公司的时候，接手的项目日志千奇百怪，有打印到控制台的，有日志未生效的，有自己写到某个文件的（你没看错），加上项目文档严重缺失，有过类似体验的兄弟知道是啥感觉。所以抽取基础项目时直接定好日志规范，在规定目录下生成日志，日志完备了，日常运维也就简单了。 总结 提取一套基础框架，把该有的组件、工具类都放进去 设计数据库、代码生成，这样model、dao、service、controller都有了，注意啊比较完备的在线注释已经存在了^_^ 使用Jenkins自动构建发布，部署项目再也不需要自己上去svn up，ps,kill等一系列操作了； 日志很重要很重要，没日志的日子很难过滴希望这篇文章能诱发点你的“懒病”，每天只写“爽”的代码，想要懒就只能先勤快，为你的开发打造点顺手的武器吧。","categories":[{"name":"java实战","slug":"java实战","permalink":"http://www.onecoderspace.com/categories/java实战/"}],"tags":[{"name":"java实战 spirng-boot 项目高效开发 自动构建 代码生成","slug":"java实战-spirng-boot-项目高效开发-自动构建-代码生成","permalink":"http://www.onecoderspace.com/tags/java实战-spirng-boot-项目高效开发-自动构建-代码生成/"}]}]}